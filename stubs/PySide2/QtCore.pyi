from typing import Any, Callable, ClassVar, Dict, Iterable, List, Optional, Tuple, Union

from typing import overload
import datetime
import shiboken2
import typing
T = typing.TypeVar('T')
QtCriticalMsg: QtMsgType
QtDebugMsg: QtMsgType
QtFatalMsg: QtMsgType
QtInfoMsg: QtMsgType
QtSystemMsg: QtMsgType
QtWarningMsg: QtMsgType

class ClassInfo:
    def __init__(self, **info: typing.Dict[str,str]) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...

class MetaFunction:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __call__(self, *args: typing.Any) -> typing.Any: ...

class MetaSignal(type):
    @classmethod
    def __instancecheck__(cls, object: object) -> bool: ...

class Property:
    fdel: Any
    fget: Any
    freset: Any
    fset: Any
    def __init__(self, type: type, fget: typing.Union[typing.Callable,None] = ..., fset: typing.Union[typing.Callable,None] = ..., freset: typing.Union[typing.Callable,None] = ..., fdel: typing.Union[typing.Callable,None] = ..., doc: str = ..., notify: typing.Union[typing.Callable,None] = ..., designable: bool = ..., scriptable: bool = ..., stored: bool = ..., user: bool = ..., constant: bool = ..., final: bool = ...) -> Property: ...
    def deleter(self, func: typing.Callable) -> None: ...
    def getter(self, func: typing.Callable) -> None: ...
    def read(self, func: typing.Callable) -> None: ...
    def resetter(self, *args, **kwargs) -> Any: ...
    def setter(self, func: typing.Callable) -> None: ...
    def write(self, func: typing.Callable) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...

class QAbstractAnimation(QObject):
    class DeletionPolicy:
        DeleteWhenStopped: ClassVar[QAbstractAnimation.DeletionPolicy] = ...
        KeepWhenStopped: ClassVar[QAbstractAnimation.DeletionPolicy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __rmul__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __rsub__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __sub__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractAnimation.DeletionPolicy: ...

    class Direction:
        Backward: ClassVar[QAbstractAnimation.Direction] = ...
        Forward: ClassVar[QAbstractAnimation.Direction] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __rmul__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __rsub__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __sub__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractAnimation.Direction: ...

    class State:
        Paused: ClassVar[QAbstractAnimation.State] = ...
        Running: ClassVar[QAbstractAnimation.State] = ...
        Stopped: ClassVar[QAbstractAnimation.State] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __rmul__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __rsub__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __sub__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractAnimation.State: ...
    Backward: ClassVar[QAbstractAnimation.Direction] = ...
    DeleteWhenStopped: ClassVar[QAbstractAnimation.DeletionPolicy] = ...
    Forward: ClassVar[QAbstractAnimation.Direction] = ...
    KeepWhenStopped: ClassVar[QAbstractAnimation.DeletionPolicy] = ...
    Paused: ClassVar[QAbstractAnimation.State] = ...
    Running: ClassVar[QAbstractAnimation.State] = ...
    Stopped: ClassVar[QAbstractAnimation.State] = ...
    currentLoopChanged: ClassVar[Signal] = ...
    directionChanged: ClassVar[Signal] = ...
    finished: ClassVar[Signal] = ...
    stateChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def currentLoop(self) -> int: ...
    def currentLoopTime(self) -> int: ...
    def currentTime(self) -> int: ...
    def direction(self) -> QAbstractAnimation.Direction: ...
    def duration(self) -> int: ...
    def event(self, event: QEvent) -> bool: ...
    def group(self) -> QAnimationGroup: ...
    def loopCount(self) -> int: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def setCurrentTime(self, msecs: int) -> None: ...
    def setDirection(self, direction: QAbstractAnimation.Direction) -> None: ...
    def setLoopCount(self, loopCount: int) -> None: ...
    def setPaused(self, arg__1: bool) -> None: ...
    def start(self, policy: QAbstractAnimation.DeletionPolicy = ...) -> None: ...
    def state(self) -> QAbstractAnimation.State: ...
    def stop(self) -> None: ...
    def totalDuration(self) -> int: ...
    def updateCurrentTime(self, currentTime: int) -> None: ...
    def updateDirection(self, direction: QAbstractAnimation.Direction) -> None: ...
    def updateState(self, newState: QAbstractAnimation.State, oldState: QAbstractAnimation.State) -> None: ...

class QAbstractEventDispatcher(QObject):
    class TimerInfo(shiboken2.Object):
        interval: Any
        timerId: Any
        timerType: Any
        def __init__(self, id: int, i: int, t: Qt.TimerType) -> None: ...
    aboutToBlock: ClassVar[Signal] = ...
    awake: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def closingDown(self) -> None: ...
    def filterNativeEvent(self, eventType: typing.Union[QByteArray,bytes], message: int) -> typing.Tuple[bool,int]: ...
    def flush(self) -> None: ...
    def hasPendingEvents(self) -> bool: ...
    def installNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    @classmethod
    def instance(cls, thread: typing.Union[QThread,None] = ...) -> QAbstractEventDispatcher: ...
    def interrupt(self) -> None: ...
    def processEvents(self, flags: typing.Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag]) -> bool: ...
    def registerSocketNotifier(self, notifier: QSocketNotifier) -> None: ...
    @overload
    def registerTimer(self, interval: int, timerType: Qt.TimerType, object: QObject) -> int: ...
    @overload
    def registerTimer(self, timerId: int, interval: int, timerType: Qt.TimerType, object: QObject) -> None: ...
    def registeredTimers(self, object: QObject) -> typing.List[QAbstractEventDispatcher.TimerInfo]: ...
    def remainingTime(self, timerId: int) -> int: ...
    def removeNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    def startingUp(self) -> None: ...
    def unregisterSocketNotifier(self, notifier: QSocketNotifier) -> None: ...
    def unregisterTimer(self, timerId: int) -> bool: ...
    def unregisterTimers(self, object: QObject) -> bool: ...
    def wakeUp(self) -> None: ...

class QAbstractItemModel(QObject):
    class CheckIndexOption:
        DoNotUseParent: ClassVar[QAbstractItemModel.CheckIndexOption] = ...
        IndexIsValid: ClassVar[QAbstractItemModel.CheckIndexOption] = ...
        NoOption: ClassVar[QAbstractItemModel.CheckIndexOption] = ...
        ParentIsInvalid: ClassVar[QAbstractItemModel.CheckIndexOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QAbstractItemModel.CheckIndexOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...

    class CheckIndexOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QAbstractItemModel.CheckIndexOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractItemModel.CheckIndexOptions: ...

    class LayoutChangeHint:
        HorizontalSortHint: ClassVar[QAbstractItemModel.LayoutChangeHint] = ...
        NoLayoutChangeHint: ClassVar[QAbstractItemModel.LayoutChangeHint] = ...
        VerticalSortHint: ClassVar[QAbstractItemModel.LayoutChangeHint] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __rmul__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __rsub__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __sub__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractItemModel.LayoutChangeHint: ...
    HorizontalSortHint: ClassVar[QAbstractItemModel.LayoutChangeHint] = ...
    NoLayoutChangeHint: ClassVar[QAbstractItemModel.LayoutChangeHint] = ...
    VerticalSortHint: ClassVar[QAbstractItemModel.LayoutChangeHint] = ...
    columnsAboutToBeInserted: ClassVar[Signal] = ...
    columnsAboutToBeMoved: ClassVar[Signal] = ...
    columnsAboutToBeRemoved: ClassVar[Signal] = ...
    columnsInserted: ClassVar[Signal] = ...
    columnsMoved: ClassVar[Signal] = ...
    columnsRemoved: ClassVar[Signal] = ...
    dataChanged: ClassVar[Signal] = ...
    headerDataChanged: ClassVar[Signal] = ...
    layoutAboutToBeChanged: ClassVar[Signal] = ...
    layoutChanged: ClassVar[Signal] = ...
    modelAboutToBeReset: ClassVar[Signal] = ...
    modelReset: ClassVar[Signal] = ...
    rowsAboutToBeInserted: ClassVar[Signal] = ...
    rowsAboutToBeMoved: ClassVar[Signal] = ...
    rowsAboutToBeRemoved: ClassVar[Signal] = ...
    rowsInserted: ClassVar[Signal] = ...
    rowsMoved: ClassVar[Signal] = ...
    rowsRemoved: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def beginInsertColumns(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def beginInsertRows(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def beginMoveColumns(self, sourceParent: QModelIndex, sourceFirst: int, sourceLast: int, destinationParent: QModelIndex, destinationColumn: int) -> bool: ...
    def beginMoveRows(self, sourceParent: QModelIndex, sourceFirst: int, sourceLast: int, destinationParent: QModelIndex, destinationRow: int) -> bool: ...
    def beginRemoveColumns(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def beginRemoveRows(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def beginResetModel(self) -> None: ...
    def buddy(self, index: QModelIndex) -> QModelIndex: ...
    def canDropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def canFetchMore(self, parent: QModelIndex) -> bool: ...
    def changePersistentIndex(self, from_: QModelIndex, to: QModelIndex) -> None: ...
    def changePersistentIndexList(self, from_: typing.List[int], to: typing.List[int]) -> None: ...
    def checkIndex(self, index: QModelIndex, options: typing.Union[QAbstractItemModel.CheckIndexOptions,QAbstractItemModel.CheckIndexOption] = ...) -> bool: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    @overload
    def createIndex(self, row: int, column: int, id: int = ...) -> QModelIndex: ...
    @overload
    def createIndex(self, row: int, column: int, ptr: object) -> QModelIndex: ...
    def data(self, index: QModelIndex, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def decodeData(self, row: int, column: int, parent: QModelIndex, stream: QDataStream) -> bool: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def encodeData(self, indexes: typing.List[int], stream: QDataStream) -> None: ...
    def endInsertColumns(self) -> None: ...
    def endInsertRows(self) -> None: ...
    def endMoveColumns(self) -> None: ...
    def endMoveRows(self) -> None: ...
    def endRemoveColumns(self) -> None: ...
    def endRemoveRows(self) -> None: ...
    def endResetModel(self) -> None: ...
    def fetchMore(self, parent: QModelIndex) -> None: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def hasChildren(self, parent: QModelIndex = ...) -> bool: ...
    def hasIndex(self, row: int, column: int, parent: QModelIndex = ...) -> bool: ...
    def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def insertColumn(self, column: int, parent: QModelIndex = ...) -> bool: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRow(self, row: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def itemData(self, index: QModelIndex) -> typing.Dict[int,typing.Any]: ...
    def match(self, start: QModelIndex, role: Qt.ItemDataRole, value: typing.Any, hits: int = ..., flags: typing.Union[Qt.MatchFlags,Qt.MatchFlag] = ...) -> typing.List[int]: ...
    def mimeData(self, indexes: typing.List[QModelIndex]) -> QMimeData: ...
    def mimeTypes(self) -> typing.List[str]: ...
    def moveColumn(self, sourceParent: QModelIndex, sourceColumn: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveColumns(self, sourceParent: QModelIndex, sourceColumn: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveRow(self, sourceParent: QModelIndex, sourceRow: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveRows(self, sourceParent: QModelIndex, sourceRow: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    def persistentIndexList(self) -> typing.List[int]: ...
    def removeColumn(self, column: int, parent: QModelIndex = ...) -> bool: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeRow(self, row: int, parent: QModelIndex = ...) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def resetInternalData(self) -> None: ...
    def revert(self) -> None: ...
    def roleNames(self) -> typing.Dict[int,QByteArray]: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setHeaderData(self, section: int, orientation: Qt.Orientation, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int,typing.Any]) -> bool: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def sort(self, column: int, order: Qt.SortOrder = ...) -> None: ...
    def span(self, index: QModelIndex) -> QSize: ...
    def submit(self) -> bool: ...
    def supportedDragActions(self) -> typing.Union[Qt.DropActions,Qt.DropAction]: ...
    def supportedDropActions(self) -> typing.Union[Qt.DropActions,Qt.DropAction]: ...

class QAbstractListModel(QAbstractItemModel):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def columnCount(self, parent: QModelIndex) -> int: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def hasChildren(self, parent: QModelIndex) -> bool: ...
    def index(self, row: int, column: int = ..., parent: QModelIndex = ...) -> QModelIndex: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...

class QAbstractNativeEventFilter(shiboken2.Object):
    def __init__(self) -> None: ...
    def nativeEventFilter(self, eventType: typing.Union[QByteArray,bytes], message: int) -> typing.Tuple[bool,int]: ...

class QAbstractProxyModel(QAbstractItemModel):
    sourceModelChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def buddy(self, index: QModelIndex) -> QModelIndex: ...
    def canDropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def canFetchMore(self, parent: QModelIndex) -> bool: ...
    def data(self, proxyIndex: QModelIndex, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def fetchMore(self, parent: QModelIndex) -> None: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def hasChildren(self, parent: QModelIndex = ...) -> bool: ...
    def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def itemData(self, index: QModelIndex) -> typing.Dict[int,typing.Any]: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapSelectionFromSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapSelectionToSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def mimeData(self, indexes: typing.List[int]) -> QMimeData: ...
    def mimeTypes(self) -> typing.List[str]: ...
    def resetInternalData(self) -> None: ...
    def revert(self) -> None: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setHeaderData(self, section: int, orientation: Qt.Orientation, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int,typing.Any]) -> bool: ...
    def setSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def sort(self, column: int, order: Qt.SortOrder = ...) -> None: ...
    def sourceModel(self) -> QAbstractItemModel: ...
    def span(self, index: QModelIndex) -> QSize: ...
    def submit(self) -> bool: ...
    def supportedDragActions(self) -> typing.Union[Qt.DropActions,Qt.DropAction]: ...
    def supportedDropActions(self) -> typing.Union[Qt.DropActions,Qt.DropAction]: ...

class QAbstractState(QObject):
    activeChanged: ClassVar[Signal] = ...
    entered: ClassVar[Signal] = ...
    exited: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def active(self) -> bool: ...
    def event(self, e: QEvent) -> bool: ...
    def machine(self) -> QStateMachine: ...
    def onEntry(self, event: QEvent) -> None: ...
    def onExit(self, event: QEvent) -> None: ...
    def parentState(self) -> QState: ...

class QAbstractTableModel(QAbstractItemModel):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def hasChildren(self, parent: QModelIndex) -> bool: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...

class QAbstractTransition(QObject):
    class TransitionType:
        ExternalTransition: ClassVar[QAbstractTransition.TransitionType] = ...
        InternalTransition: ClassVar[QAbstractTransition.TransitionType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __and__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __rand__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __ror__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __sub__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
        def __xor__(self, other: typing.SupportsInt) -> QAbstractTransition.TransitionType: ...
    ExternalTransition: ClassVar[QAbstractTransition.TransitionType] = ...
    InternalTransition: ClassVar[QAbstractTransition.TransitionType] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    targetStateChanged: ClassVar[Signal] = ...
    targetStatesChanged: ClassVar[Signal] = ...
    triggered: ClassVar[Signal] = ...
    def __init__(self, sourceState: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def addAnimation(self, animation: QAbstractAnimation) -> None: ...
    def animations(self) -> typing.List[QAbstractAnimation]: ...
    def event(self, e: QEvent) -> bool: ...
    def eventTest(self, event: QEvent) -> bool: ...
    def machine(self) -> QStateMachine: ...
    def onTransition(self, event: QEvent) -> None: ...
    def removeAnimation(self, animation: QAbstractAnimation) -> None: ...
    def setTargetState(self, target: QAbstractState) -> None: ...
    def setTargetStates(self, targets: typing.Sequence[QAbstractState]) -> None: ...
    def setTransitionType(self, type: QAbstractTransition.TransitionType) -> None: ...
    def sourceState(self) -> QState: ...
    def targetState(self) -> QAbstractState: ...
    def targetStates(self) -> typing.List[QAbstractState]: ...
    def transitionType(self) -> QAbstractTransition.TransitionType: ...

class QAnimationGroup(QAbstractAnimation):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def addAnimation(self, animation: QAbstractAnimation) -> None: ...
    def animationAt(self, index: int) -> QAbstractAnimation: ...
    def animationCount(self) -> int: ...
    def clear(self) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def indexOfAnimation(self, animation: QAbstractAnimation) -> int: ...
    def insertAnimation(self, index: int, animation: QAbstractAnimation) -> None: ...
    def removeAnimation(self, animation: QAbstractAnimation) -> None: ...
    def takeAnimation(self, index: int) -> QAbstractAnimation: ...

class QBasicMutex(shiboken2.Object):
    def __init__(self) -> None: ...
    def isRecursive(self) -> bool: ...
    def lock(self) -> None: ...
    def tryLock(self) -> bool: ...
    def try_lock(self) -> bool: ...
    def unlock(self) -> None: ...

class QBasicTimer(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QBasicTimer) -> None: ...
    def isActive(self) -> bool: ...
    @overload
    def start(self, msec: int, obj: QObject) -> None: ...
    @overload
    def start(self, msec: int, timerType: Qt.TimerType, obj: QObject) -> None: ...
    def stop(self) -> None: ...
    def swap(self, other: QBasicTimer) -> None: ...
    def timerId(self) -> int: ...

class QBitArray(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QBitArray) -> None: ...
    @overload
    def __init__(self, size: int, val: bool = ...) -> None: ...
    def at(self, i: int) -> bool: ...
    def bits(self) -> bytes: ...
    def clear(self) -> None: ...
    def clearBit(self, i: int) -> None: ...
    @overload
    def count(self) -> int: ...
    @overload
    def count(self, on: bool) -> int: ...
    @overload
    def fill(self, val: bool, first: int, last: int) -> None: ...
    @overload
    def fill(self, val: bool, size: int = ...) -> bool: ...
    @classmethod
    def fromBits(cls, data: bytes, len: int) -> QBitArray: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def resize(self, size: int) -> None: ...
    @overload
    def setBit(self, i: int) -> None: ...
    @overload
    def setBit(self, i: int, val: bool) -> None: ...
    def size(self) -> int: ...
    def swap(self, other: QBitArray) -> None: ...
    def testBit(self, i: int) -> bool: ...
    def toggleBit(self, i: int) -> bool: ...
    def truncate(self, pos: int) -> None: ...
    def __and__(self, arg__2: QBitArray) -> QBitArray: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __delitem__(self, other) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index) -> Any: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iand__(self, arg__1: QBitArray) -> QBitArray: ...
    def __invert__(self) -> QBitArray: ...
    def __ior__(self, arg__1: QBitArray) -> QBitArray: ...
    def __ixor__(self, arg__1: QBitArray) -> QBitArray: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, arg__2: QBitArray) -> QBitArray: ...
    def __rand__(self, other) -> Any: ...
    def __ror__(self, other) -> Any: ...
    def __rxor__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> None: ...
    def __xor__(self, arg__2: QBitArray) -> QBitArray: ...

class QBuffer(QIODevice):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, buf: typing.Union[QByteArray,bytes], parent: typing.Union[QObject,None] = ..., aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    def atEnd(self) -> bool: ...
    def buffer(self) -> QByteArray: ...
    def canReadLine(self) -> bool: ...
    def close(self) -> None: ...
    def connectNotify(self, arg__1: QMetaMethod) -> None: ...
    def data(self) -> QByteArray: ...
    def disconnectNotify(self, arg__1: QMetaMethod) -> None: ...
    def open(self, openMode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> bool: ...
    def pos(self) -> int: ...
    def readData(self, data: bytes, maxlen: int) -> int: ...
    def seek(self, off: int) -> bool: ...
    def setBuffer(self, a: typing.Union[QByteArray,bytes]) -> None: ...
    def setData(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    def size(self) -> int: ...
    def writeData(self, data: bytes, len: int) -> int: ...

class QByteArray(shiboken2.Object):
    class Base64DecodingStatus:
        IllegalCharacter: ClassVar[QByteArray.Base64DecodingStatus] = ...
        IllegalInputLength: ClassVar[QByteArray.Base64DecodingStatus] = ...
        IllegalPadding: ClassVar[QByteArray.Base64DecodingStatus] = ...
        Ok: ClassVar[QByteArray.Base64DecodingStatus] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __and__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __rand__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __rmul__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __ror__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __rsub__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __rxor__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __sub__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...
        def __xor__(self, other: typing.SupportsInt) -> QByteArray.Base64DecodingStatus: ...

    class Base64Option:
        AbortOnBase64DecodingErrors: ClassVar[QByteArray.Base64Option] = ...
        Base64Encoding: ClassVar[QByteArray.Base64Option] = ...
        Base64UrlEncoding: ClassVar[QByteArray.Base64Option] = ...
        IgnoreBase64DecodingErrors: ClassVar[QByteArray.Base64Option] = ...
        KeepTrailingEquals: ClassVar[QByteArray.Base64Option] = ...
        OmitTrailingEquals: ClassVar[QByteArray.Base64Option] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QByteArray.Base64Option: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __rand__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __ror__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __rxor__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __xor__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...

    class Base64Options:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QByteArray.Base64Options: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __rand__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __ror__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __rxor__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...
        def __xor__(self, other: typing.SupportsInt) -> QByteArray.Base64Options: ...

    class FromBase64Result(shiboken2.Object):
        decoded: Any
        decodingStatus: Any
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, FromBase64Result: QByteArray.FromBase64Result) -> None: ...
        def swap(self, other: QByteArray.FromBase64Result) -> None: ...
        def __copy__(self) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
    AbortOnBase64DecodingErrors: ClassVar[QByteArray.Base64Option] = ...
    Base64Encoding: ClassVar[QByteArray.Base64Option] = ...
    Base64UrlEncoding: ClassVar[QByteArray.Base64Option] = ...
    IgnoreBase64DecodingErrors: ClassVar[QByteArray.Base64Option] = ...
    KeepTrailingEquals: ClassVar[QByteArray.Base64Option] = ...
    OmitTrailingEquals: ClassVar[QByteArray.Base64Option] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: bytearray) -> None: ...
    @overload
    def __init__(self, arg__1: bytes) -> None: ...
    @overload
    def __init__(self, arg__1: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, size: int, c: int) -> None: ...
    @overload
    def append(self, a: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def append(self, c: int) -> QByteArray: ...
    @overload
    def append(self, count: int, c: int) -> QByteArray: ...
    def at(self, i: int) -> int: ...
    def back(self) -> int: ...
    def capacity(self) -> int: ...
    def cbegin(self) -> bytes: ...
    def cend(self) -> bytes: ...
    def chop(self, n: int) -> None: ...
    def chopped(self, len: int) -> QByteArray: ...
    def clear(self) -> None: ...
    @overload
    def compare(self, a: typing.Union[QByteArray,bytes], cs: Qt.CaseSensitivity = ...) -> int: ...
    @overload
    def compare(self, c: bytes, cs: Qt.CaseSensitivity = ...) -> int: ...
    @overload
    def contains(self, a: typing.Union[QByteArray,bytes]) -> bool: ...
    @overload
    def contains(self, c: int) -> bool: ...
    @overload
    def count(self) -> int: ...
    @overload
    def count(self, a: typing.Union[QByteArray,bytes]) -> int: ...
    @overload
    def count(self, c: int) -> int: ...
    def data(self) -> bytes: ...
    @overload
    def endsWith(self, a: typing.Union[QByteArray,bytes]) -> bool: ...
    @overload
    def endsWith(self, c: int) -> bool: ...
    def fill(self, c: int, size: int = ...) -> QByteArray: ...
    @classmethod
    @overload
    def fromBase64(cls, base64: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @classmethod
    @overload
    def fromBase64(cls, base64: typing.Union[QByteArray,bytes], options: typing.Union[QByteArray.Base64Options,QByteArray.Base64Option]) -> QByteArray: ...
    @classmethod
    def fromBase64Encoding(cls, base64: typing.Union[QByteArray,bytes], options: typing.Union[QByteArray.Base64Options,QByteArray.Base64Option] = ...) -> QByteArray.FromBase64Result: ...
    @classmethod
    def fromHex(cls, hexEncoded: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @classmethod
    def fromPercentEncoding(cls, pctEncoded: typing.Union[QByteArray,bytes], percent: int = ...) -> QByteArray: ...
    @classmethod
    def fromRawData(cls, arg__1: bytes, size: int) -> QByteArray: ...
    def front(self) -> int: ...
    def indexOf(self, a: typing.Union[QByteArray,bytes], from_: int = ...) -> int: ...
    @overload
    def insert(self, i: int, a: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def insert(self, i: int, count: int, c: int) -> QByteArray: ...
    def isEmpty(self) -> bool: ...
    def isLower(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isSharedWith(self, other: typing.Union[QByteArray,bytes]) -> bool: ...
    def isUpper(self) -> bool: ...
    def lastIndexOf(self, a: typing.Union[QByteArray,bytes], from_: int = ...) -> int: ...
    def left(self, len: int) -> QByteArray: ...
    def leftJustified(self, width: int, fill: int = ..., truncate: bool = ...) -> QByteArray: ...
    def length(self) -> int: ...
    def mid(self, index: int, len: int = ...) -> QByteArray: ...
    @classmethod
    @overload
    def number(cls, arg__1: float, f: int = ..., prec: int = ...) -> QByteArray: ...
    @classmethod
    @overload
    def number(cls, arg__1: int, base: int = ...) -> QByteArray: ...
    @overload
    def prepend(self, a: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def prepend(self, c: int) -> QByteArray: ...
    @overload
    def prepend(self, count: int, c: int) -> QByteArray: ...
    def remove(self, index: int, len: int) -> QByteArray: ...
    def repeated(self, times: int) -> QByteArray: ...
    @overload
    def replace(self, before: typing.Union[QByteArray,bytes], after: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def replace(self, before: str, after: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def replace(self, before: int, after: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def replace(self, before: int, after: int) -> QByteArray: ...
    @overload
    def replace(self, index: int, len: int, s: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    def reserve(self, size: int) -> None: ...
    def resize(self, size: int) -> None: ...
    def right(self, len: int) -> QByteArray: ...
    def rightJustified(self, width: int, fill: int = ..., truncate: bool = ...) -> QByteArray: ...
    @overload
    def setNum(self, arg__1: float, f: int = ..., prec: int = ...) -> QByteArray: ...
    @overload
    def setNum(self, arg__1: int, base: int = ...) -> QByteArray: ...
    def setRawData(self, a: bytes, n: int) -> QByteArray: ...
    def shrink_to_fit(self) -> None: ...
    def simplified(self) -> QByteArray: ...
    def size(self) -> int: ...
    def split(self, sep: int) -> typing.List[QByteArray]: ...
    def squeeze(self) -> None: ...
    @overload
    def startsWith(self, a: typing.Union[QByteArray,bytes]) -> bool: ...
    @overload
    def startsWith(self, c: int) -> bool: ...
    def swap(self, other: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def toBase64(self) -> QByteArray: ...
    @overload
    def toBase64(self, options: typing.Union[QByteArray.Base64Options,QByteArray.Base64Option]) -> QByteArray: ...
    def toDouble(self) -> typing.Tuple[float,bool]: ...
    def toFloat(self) -> typing.Tuple[float,bool]: ...
    @overload
    def toHex(self) -> QByteArray: ...
    @overload
    def toHex(self, separator: int) -> QByteArray: ...
    def toInt(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toLong(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toLongLong(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toLower(self) -> QByteArray: ...
    def toPercentEncoding(self, exclude: typing.Union[QByteArray,bytes] = ..., include: typing.Union[QByteArray,bytes] = ..., percent: int = ...) -> QByteArray: ...
    def toShort(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toUInt(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toULong(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toULongLong(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toUShort(self, base: int = ...) -> typing.Tuple[int,bool]: ...
    def toUpper(self) -> QByteArray: ...
    def trimmed(self) -> QByteArray: ...
    def truncate(self, pos: int) -> None: ...
    @overload
    def __add__(self, a2: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def __add__(self, a2: int) -> QByteArray: ...
    @overload
    def __add__(self, arg__1: bytearray) -> QByteArray: ...
    @overload
    def __add__(self, arg__1: bytes) -> None: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __delitem__(self, other) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index) -> Any: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __iadd__(self, a: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @overload
    def __iadd__(self, arg__1: bytearray) -> QByteArray: ...
    @overload
    def __iadd__(self, c: int) -> QByteArray: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> None: ...

class QByteArrayMatcher(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QByteArrayMatcher) -> None: ...
    @overload
    def __init__(self, pattern: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, pattern: bytes, length: int) -> None: ...
    @overload
    def indexIn(self, ba: typing.Union[QByteArray,bytes], from_: int = ...) -> int: ...
    @overload
    def indexIn(self, str: bytes, len: int, from_: int = ...) -> int: ...
    def pattern(self) -> QByteArray: ...
    def setPattern(self, pattern: typing.Union[QByteArray,bytes]) -> None: ...
    def __copy__(self) -> None: ...

class QCalendar(shiboken2.Object):
    class System:
        Gregorian: ClassVar[QCalendar.System] = ...
        IslamicCivil: ClassVar[QCalendar.System] = ...
        Jalali: ClassVar[QCalendar.System] = ...
        Julian: ClassVar[QCalendar.System] = ...
        Last: ClassVar[QCalendar.System] = ...
        Milankovic: ClassVar[QCalendar.System] = ...
        User: ClassVar[QCalendar.System] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __and__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __rand__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __ror__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __sub__(self, other: typing.SupportsInt) -> QCalendar.System: ...
        def __xor__(self, other: typing.SupportsInt) -> QCalendar.System: ...

    class YearMonthDay(shiboken2.Object):
        day: Any
        month: Any
        year: Any
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, YearMonthDay: QCalendar.YearMonthDay) -> None: ...
        @overload
        def __init__(self, y: int, m: int = ..., d: int = ...) -> None: ...
        def isValid(self) -> bool: ...
        def __copy__(self) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, system: QCalendar.System) -> None: ...
    @classmethod
    def availableCalendars(cls) -> typing.List[str]: ...
    @overload
    def dateFromParts(self, parts: QCalendar.YearMonthDay) -> QDate: ...
    @overload
    def dateFromParts(self, year: int, month: int, day: int) -> QDate: ...
    def dayOfWeek(self, date: QDate) -> int: ...
    def daysInMonth(self, month: int, year: typing.Union[int,None] = ...) -> int: ...
    def daysInYear(self, year: int) -> int: ...
    def hasYearZero(self) -> bool: ...
    def isDateValid(self, year: int, month: int, day: int) -> bool: ...
    def isGregorian(self) -> bool: ...
    def isLeapYear(self, year: int) -> bool: ...
    def isLunar(self) -> bool: ...
    def isLuniSolar(self) -> bool: ...
    def isProleptic(self) -> bool: ...
    def isSolar(self) -> bool: ...
    def isValid(self) -> bool: ...
    def maximumDaysInMonth(self) -> int: ...
    def maximumMonthsInYear(self) -> int: ...
    def minimumDaysInMonth(self) -> int: ...
    def monthName(self, locale: QLocale, month: int, year: typing.Union[int,None] = ..., format: QLocale.FormatType = ...) -> str: ...
    def monthsInYear(self, year: int) -> int: ...
    def name(self) -> str: ...
    def partsFromDate(self, date: QDate) -> QCalendar.YearMonthDay: ...
    def standaloneMonthName(self, locale: QLocale, month: int, year: typing.Union[int,None] = ..., format: QLocale.FormatType = ...) -> str: ...
    def standaloneWeekDayName(self, locale: QLocale, day: int, format: QLocale.FormatType = ...) -> str: ...
    def weekDayName(self, locale: QLocale, day: int, format: QLocale.FormatType = ...) -> str: ...
    def __copy__(self) -> None: ...

class QCborArray(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QCborArray) -> None: ...
    def append(self, value: QCborValue) -> None: ...
    def at(self, i: int) -> QCborValue: ...
    def clear(self) -> None: ...
    def compare(self, other: QCborArray) -> int: ...
    def contains(self, value: QCborValue) -> bool: ...
    def empty(self) -> bool: ...
    def first(self) -> QCborValue: ...
    @classmethod
    def fromJsonArray(cls, array: QJsonArray) -> QCborArray: ...
    @classmethod
    def fromStringList(cls, list: typing.Sequence[str]) -> QCborArray: ...
    @classmethod
    def fromVariantList(cls, list: typing.Sequence[typing.Any]) -> QCborArray: ...
    def insert(self, i: int, value: QCborValue) -> None: ...
    def isEmpty(self) -> bool: ...
    def last(self) -> QCborValue: ...
    def pop_back(self) -> None: ...
    def pop_front(self) -> None: ...
    def prepend(self, value: QCborValue) -> None: ...
    def push_back(self, t: QCborValue) -> None: ...
    def push_front(self, t: QCborValue) -> None: ...
    def removeAt(self, i: int) -> None: ...
    def removeFirst(self) -> None: ...
    def removeLast(self) -> None: ...
    def size(self) -> int: ...
    def swap(self, other: QCborArray) -> None: ...
    def takeAt(self, i: int) -> QCborValue: ...
    def takeFirst(self) -> QCborValue: ...
    def takeLast(self) -> QCborValue: ...
    def toCborValue(self) -> QCborValue: ...
    def toJsonArray(self) -> QJsonArray: ...
    def toVariantList(self) -> typing.List[typing.Any]: ...
    def __add__(self, v: QCborValue) -> QCborArray: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, v: QCborValue) -> QCborArray: ...
    def __le__(self, other: object) -> bool: ...
    def __lshift__(self, v: QCborValue) -> QCborArray: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __rlshift__(self, other) -> Any: ...

class QCborError(shiboken2.Object):
    class Code:
        AdvancePastEnd: ClassVar[QCborError.Code] = ...
        DataTooLarge: ClassVar[QCborError.Code] = ...
        EndOfFile: ClassVar[QCborError.Code] = ...
        GarbageAtEnd: ClassVar[QCborError.Code] = ...
        IllegalNumber: ClassVar[QCborError.Code] = ...
        IllegalSimpleType: ClassVar[QCborError.Code] = ...
        IllegalType: ClassVar[QCborError.Code] = ...
        InputOutputError: ClassVar[QCborError.Code] = ...
        InvalidUtf8String: ClassVar[QCborError.Code] = ...
        NestingTooDeep: ClassVar[QCborError.Code] = ...
        NoError: ClassVar[QCborError.Code] = ...
        UnexpectedBreak: ClassVar[QCborError.Code] = ...
        UnknownError: ClassVar[QCborError.Code] = ...
        UnknownType: ClassVar[QCborError.Code] = ...
        UnsupportedType: ClassVar[QCborError.Code] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __and__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __sub__(self, other: typing.SupportsInt) -> QCborError.Code: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborError.Code: ...
    AdvancePastEnd: ClassVar[QCborError.Code] = ...
    DataTooLarge: ClassVar[QCborError.Code] = ...
    EndOfFile: ClassVar[QCborError.Code] = ...
    GarbageAtEnd: ClassVar[QCborError.Code] = ...
    IllegalNumber: ClassVar[QCborError.Code] = ...
    IllegalSimpleType: ClassVar[QCborError.Code] = ...
    IllegalType: ClassVar[QCborError.Code] = ...
    InputOutputError: ClassVar[QCborError.Code] = ...
    InvalidUtf8String: ClassVar[QCborError.Code] = ...
    NestingTooDeep: ClassVar[QCborError.Code] = ...
    NoError: ClassVar[QCborError.Code] = ...
    UnexpectedBreak: ClassVar[QCborError.Code] = ...
    UnknownError: ClassVar[QCborError.Code] = ...
    UnknownType: ClassVar[QCborError.Code] = ...
    UnsupportedType: ClassVar[QCborError.Code] = ...
    c: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QCborError: QCborError) -> None: ...
    def toString(self) -> str: ...
    def __copy__(self) -> None: ...

class QCborKnownTags:
    Base64: ClassVar[QCborKnownTags] = ...
    Base64url: ClassVar[QCborKnownTags] = ...
    Bigfloat: ClassVar[QCborKnownTags] = ...
    COSE_Encrypt: ClassVar[QCborKnownTags] = ...
    COSE_Encrypt0: ClassVar[QCborKnownTags] = ...
    COSE_Mac: ClassVar[QCborKnownTags] = ...
    COSE_Mac0: ClassVar[QCborKnownTags] = ...
    COSE_Sign: ClassVar[QCborKnownTags] = ...
    COSE_Sign1: ClassVar[QCborKnownTags] = ...
    DateTimeString: ClassVar[QCborKnownTags] = ...
    Decimal: ClassVar[QCborKnownTags] = ...
    EncodedCbor: ClassVar[QCborKnownTags] = ...
    ExpectedBase16: ClassVar[QCborKnownTags] = ...
    ExpectedBase64: ClassVar[QCborKnownTags] = ...
    ExpectedBase64url: ClassVar[QCborKnownTags] = ...
    MimeMessage: ClassVar[QCborKnownTags] = ...
    NegativeBignum: ClassVar[QCborKnownTags] = ...
    PositiveBignum: ClassVar[QCborKnownTags] = ...
    RegularExpression: ClassVar[QCborKnownTags] = ...
    Signature: ClassVar[QCborKnownTags] = ...
    UnixTime_t: ClassVar[QCborKnownTags] = ...
    Url: ClassVar[QCborKnownTags] = ...
    Uuid: ClassVar[QCborKnownTags] = ...
    values: ClassVar[dict] = ...
    name: Any
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __add__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __and__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> Any: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __pos__(self) -> Any: ...
    def __radd__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __rand__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __rmul__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __ror__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __rsub__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __rxor__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __sub__(self, other: typing.SupportsInt) -> QCborKnownTags: ...
    def __xor__(self, other: typing.SupportsInt) -> QCborKnownTags: ...

class QCborMap(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QCborMap) -> None: ...
    def clear(self) -> None: ...
    def compare(self, other: QCborMap) -> int: ...
    @overload
    def contains(self, key: QCborValue) -> bool: ...
    @overload
    def contains(self, key: str) -> bool: ...
    @overload
    def contains(self, key: int) -> bool: ...
    def empty(self) -> bool: ...
    @classmethod
    def fromJsonObject(cls, o: typing.Dict[str,QJsonValue]) -> QCborMap: ...
    @classmethod
    def fromVariantHash(cls, hash: typing.Dict[str,typing.Any]) -> QCborMap: ...
    @classmethod
    def fromVariantMap(cls, map: typing.Dict[str,typing.Any]) -> QCborMap: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> typing.List[QCborValue]: ...
    @overload
    def remove(self, key: QCborValue) -> None: ...
    @overload
    def remove(self, key: str) -> None: ...
    @overload
    def remove(self, key: int) -> None: ...
    def size(self) -> int: ...
    def swap(self, other: QCborMap) -> None: ...
    @overload
    def take(self, key: QCborValue) -> QCborValue: ...
    @overload
    def take(self, key: str) -> QCborValue: ...
    @overload
    def take(self, key: int) -> QCborValue: ...
    def toCborValue(self) -> QCborValue: ...
    def toJsonObject(self) -> typing.Dict[str,QJsonValue]: ...
    def toVariantHash(self) -> typing.Dict[str,typing.Any]: ...
    def toVariantMap(self) -> typing.Dict[str,typing.Any]: ...
    @overload
    def value(self, key: QCborValue) -> QCborValue: ...
    @overload
    def value(self, key: str) -> QCborValue: ...
    @overload
    def value(self, key: int) -> QCborValue: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QCborParserError(shiboken2.Object):
    error: Any
    offset: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QCborParserError: QCborParserError) -> None: ...
    def errorString(self) -> str: ...
    def __copy__(self) -> None: ...

class QCborSimpleType:
    False_: ClassVar[QCborSimpleType] = ...
    Null: ClassVar[QCborSimpleType] = ...
    True_: ClassVar[QCborSimpleType] = ...
    Undefined: ClassVar[QCborSimpleType] = ...
    values: ClassVar[dict] = ...
    name: Any
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __add__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __and__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> Any: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __pos__(self) -> Any: ...
    def __radd__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __rand__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __rmul__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __ror__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __rsub__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __rxor__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __sub__(self, other: typing.SupportsInt) -> QCborSimpleType: ...
    def __xor__(self, other: typing.SupportsInt) -> QCborSimpleType: ...

class QCborStreamReader(shiboken2.Object):
    class StringResultCode:
        EndOfString: ClassVar[QCborStreamReader.StringResultCode] = ...
        Error: ClassVar[QCborStreamReader.StringResultCode] = ...
        Ok: ClassVar[QCborStreamReader.StringResultCode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __and__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __sub__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborStreamReader.StringResultCode: ...

    class Type:
        Array: ClassVar[QCborStreamReader.Type] = ...
        ByteArray: ClassVar[QCborStreamReader.Type] = ...
        ByteString: ClassVar[QCborStreamReader.Type] = ...
        Double: ClassVar[QCborStreamReader.Type] = ...
        Float: ClassVar[QCborStreamReader.Type] = ...
        Float16: ClassVar[QCborStreamReader.Type] = ...
        HalfFloat: ClassVar[QCborStreamReader.Type] = ...
        Invalid: ClassVar[QCborStreamReader.Type] = ...
        Map: ClassVar[QCborStreamReader.Type] = ...
        NegativeInteger: ClassVar[QCborStreamReader.Type] = ...
        SimpleType: ClassVar[QCborStreamReader.Type] = ...
        String: ClassVar[QCborStreamReader.Type] = ...
        Tag: ClassVar[QCborStreamReader.Type] = ...
        TextString: ClassVar[QCborStreamReader.Type] = ...
        UnsignedInteger: ClassVar[QCborStreamReader.Type] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __and__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __sub__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborStreamReader.Type: ...
    Array: ClassVar[QCborStreamReader.Type] = ...
    ByteArray: ClassVar[QCborStreamReader.Type] = ...
    ByteString: ClassVar[QCborStreamReader.Type] = ...
    Double: ClassVar[QCborStreamReader.Type] = ...
    EndOfString: ClassVar[QCborStreamReader.StringResultCode] = ...
    Error: ClassVar[QCborStreamReader.StringResultCode] = ...
    Float: ClassVar[QCborStreamReader.Type] = ...
    Float16: ClassVar[QCborStreamReader.Type] = ...
    HalfFloat: ClassVar[QCborStreamReader.Type] = ...
    Invalid: ClassVar[QCborStreamReader.Type] = ...
    Map: ClassVar[QCborStreamReader.Type] = ...
    NegativeInteger: ClassVar[QCborStreamReader.Type] = ...
    Ok: ClassVar[QCborStreamReader.StringResultCode] = ...
    SimpleType: ClassVar[QCborStreamReader.Type] = ...
    String: ClassVar[QCborStreamReader.Type] = ...
    Tag: ClassVar[QCborStreamReader.Type] = ...
    TextString: ClassVar[QCborStreamReader.Type] = ...
    UnsignedInteger: ClassVar[QCborStreamReader.Type] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, data: bytes, len: int) -> None: ...
    @overload
    def __init__(self, data: bytearray, len: int) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def addData(self, data: bytes, len: int) -> None: ...
    @overload
    def addData(self, data: bytearray, len: int) -> None: ...
    def clear(self) -> None: ...
    def containerDepth(self) -> int: ...
    def currentOffset(self) -> int: ...
    def currentStringChunkSize(self) -> int: ...
    def device(self) -> QIODevice: ...
    def enterContainer(self) -> bool: ...
    def hasNext(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isBool(self) -> bool: ...
    def isByteArray(self) -> bool: ...
    def isContainer(self) -> bool: ...
    def isDouble(self) -> bool: ...
    def isFalse(self) -> bool: ...
    def isFloat(self) -> bool: ...
    def isFloat16(self) -> bool: ...
    def isInteger(self) -> bool: ...
    def isInvalid(self) -> bool: ...
    def isLengthKnown(self) -> bool: ...
    def isMap(self) -> bool: ...
    def isNegativeInteger(self) -> bool: ...
    def isNull(self) -> bool: ...
    @overload
    def isSimpleType(self) -> bool: ...
    @overload
    def isSimpleType(self, st: QCborSimpleType) -> bool: ...
    def isString(self) -> bool: ...
    def isTag(self) -> bool: ...
    def isTrue(self) -> bool: ...
    def isUndefined(self) -> bool: ...
    def isUnsignedInteger(self) -> bool: ...
    def isValid(self) -> bool: ...
    def lastError(self) -> QCborError: ...
    def leaveContainer(self) -> bool: ...
    def length(self) -> int: ...
    def next(self, maxRecursion: int = ...) -> bool: ...
    def parentContainerType(self) -> QCborStreamReader.Type: ...
    def readByteArray(self) -> QCborStringResultByteArray: ...
    def readString(self) -> QCborStringResultString: ...
    def reparse(self) -> None: ...
    def reset(self) -> None: ...
    def setDevice(self, device: QIODevice) -> None: ...
    def toBool(self) -> bool: ...
    def toDouble(self) -> float: ...
    def toFloat(self) -> float: ...
    def toInteger(self) -> int: ...
    def toSimpleType(self) -> QCborSimpleType: ...
    def toUnsignedInteger(self) -> int: ...
    def type(self) -> QCborStreamReader.Type: ...
    def __bool__(self) -> bool: ...

class QCborStreamWriter(shiboken2.Object):
    @overload
    def __init__(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def append(self, b: bool) -> None: ...
    @overload
    def append(self, ba: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def append(self, d: float) -> None: ...
    @overload
    def append(self, f: float) -> None: ...
    @overload
    def append(self, i: int) -> None: ...
    @overload
    def append(self, st: QCborSimpleType) -> None: ...
    @overload
    def append(self, str: bytes, size: int = ...) -> None: ...
    @overload
    def append(self, tag: QCborKnownTags) -> None: ...
    @overload
    def append(self, u: int) -> None: ...
    def appendByteString(self, data: bytes, len: int) -> None: ...
    def appendNull(self) -> None: ...
    def appendTextString(self, utf8: bytes, len: int) -> None: ...
    def appendUndefined(self) -> None: ...
    def device(self) -> QIODevice: ...
    def endArray(self) -> bool: ...
    def endMap(self) -> bool: ...
    def setDevice(self, device: QIODevice) -> None: ...
    @overload
    def startArray(self) -> None: ...
    @overload
    def startArray(self, count: int) -> None: ...
    @overload
    def startMap(self) -> None: ...
    @overload
    def startMap(self, count: int) -> None: ...

class QCborStringResultByteArray(shiboken2.Object):
    data: Any
    status: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QCborStringResultByteArray: QCborStringResultByteArray) -> None: ...
    def __copy__(self) -> None: ...

class QCborStringResultString(shiboken2.Object):
    data: Any
    status: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QCborStringResultString: QCborStringResultString) -> None: ...
    def __copy__(self) -> None: ...

class QCborValue(shiboken2.Object):
    class DiagnosticNotationOption:
        Compact: ClassVar[QCborValue.DiagnosticNotationOption] = ...
        ExtendedFormat: ClassVar[QCborValue.DiagnosticNotationOption] = ...
        LineWrapped: ClassVar[QCborValue.DiagnosticNotationOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QCborValue.DiagnosticNotationOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...

    class DiagnosticNotationOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QCborValue.DiagnosticNotationOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborValue.DiagnosticNotationOptions: ...

    class EncodingOption:
        NoTransformation: ClassVar[QCborValue.EncodingOption] = ...
        SortKeysInMaps: ClassVar[QCborValue.EncodingOption] = ...
        UseFloat: ClassVar[QCborValue.EncodingOption] = ...
        UseFloat16: ClassVar[QCborValue.EncodingOption] = ...
        UseIntegers: ClassVar[QCborValue.EncodingOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QCborValue.EncodingOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...

    class EncodingOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QCborValue.EncodingOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborValue.EncodingOptions: ...

    class Type:
        Array: ClassVar[QCborValue.Type] = ...
        ByteArray: ClassVar[QCborValue.Type] = ...
        DateTime: ClassVar[QCborValue.Type] = ...
        Double: ClassVar[QCborValue.Type] = ...
        False_: ClassVar[QCborValue.Type] = ...
        Integer: ClassVar[QCborValue.Type] = ...
        Invalid: ClassVar[QCborValue.Type] = ...
        Map: ClassVar[QCborValue.Type] = ...
        Null: ClassVar[QCborValue.Type] = ...
        RegularExpression: ClassVar[QCborValue.Type] = ...
        SimpleType: ClassVar[QCborValue.Type] = ...
        String: ClassVar[QCborValue.Type] = ...
        Tag: ClassVar[QCborValue.Type] = ...
        True_: ClassVar[QCborValue.Type] = ...
        Undefined: ClassVar[QCborValue.Type] = ...
        Url: ClassVar[QCborValue.Type] = ...
        Uuid: ClassVar[QCborValue.Type] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __and__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __rand__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __ror__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __sub__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
        def __xor__(self, other: typing.SupportsInt) -> QCborValue.Type: ...
    Array: ClassVar[QCborValue.Type] = ...
    ByteArray: ClassVar[QCborValue.Type] = ...
    Compact: ClassVar[QCborValue.DiagnosticNotationOption] = ...
    DateTime: ClassVar[QCborValue.Type] = ...
    Double: ClassVar[QCborValue.Type] = ...
    ExtendedFormat: ClassVar[QCborValue.DiagnosticNotationOption] = ...
    False_: ClassVar[QCborValue.Type] = ...
    Integer: ClassVar[QCborValue.Type] = ...
    Invalid: ClassVar[QCborValue.Type] = ...
    LineWrapped: ClassVar[QCborValue.DiagnosticNotationOption] = ...
    Map: ClassVar[QCborValue.Type] = ...
    NoTransformation: ClassVar[QCborValue.EncodingOption] = ...
    Null: ClassVar[QCborValue.Type] = ...
    RegularExpression: ClassVar[QCborValue.Type] = ...
    SimpleType: ClassVar[QCborValue.Type] = ...
    SortKeysInMaps: ClassVar[QCborValue.EncodingOption] = ...
    String: ClassVar[QCborValue.Type] = ...
    Tag: ClassVar[QCborValue.Type] = ...
    True_: ClassVar[QCborValue.Type] = ...
    Undefined: ClassVar[QCborValue.Type] = ...
    Url: ClassVar[QCborValue.Type] = ...
    UseFloat: ClassVar[QCborValue.EncodingOption] = ...
    UseFloat16: ClassVar[QCborValue.EncodingOption] = ...
    UseIntegers: ClassVar[QCborValue.EncodingOption] = ...
    Uuid: ClassVar[QCborValue.Type] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a: QCborArray) -> None: ...
    @overload
    def __init__(self, b_: bool) -> None: ...
    @overload
    def __init__(self, ba: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, dt: QDateTime) -> None: ...
    @overload
    def __init__(self, i: int) -> None: ...
    @overload
    def __init__(self, m: QCborMap) -> None: ...
    @overload
    def __init__(self, other: QCborValue) -> None: ...
    @overload
    def __init__(self, rx: QRegularExpression) -> None: ...
    @overload
    def __init__(self, s: str) -> None: ...
    @overload
    def __init__(self, s: bytes) -> None: ...
    @overload
    def __init__(self, st: QCborSimpleType) -> None: ...
    @overload
    def __init__(self, t_: QCborKnownTags, tv: QCborValue = ...) -> None: ...
    @overload
    def __init__(self, t_: QCborValue.Type) -> None: ...
    @overload
    def __init__(self, u: int) -> None: ...
    @overload
    def __init__(self, url: QUrl) -> None: ...
    @overload
    def __init__(self, uuid: QUuid) -> None: ...
    @overload
    def __init__(self, v: float) -> None: ...
    def compare(self, other: QCborValue) -> int: ...
    @classmethod
    @overload
    def fromCbor(cls, ba: typing.Union[QByteArray,bytes], error: typing.Union[QCborParserError,None] = ...) -> QCborValue: ...
    @classmethod
    @overload
    def fromCbor(cls, data: bytes, len: int, error: typing.Union[QCborParserError,None] = ...) -> QCborValue: ...
    @classmethod
    @overload
    def fromCbor(cls, data: bytearray, len: int, error: typing.Union[QCborParserError,None] = ...) -> QCborValue: ...
    @classmethod
    @overload
    def fromCbor(cls, reader: QCborStreamReader) -> QCborValue: ...
    @classmethod
    def fromJsonValue(cls, v: QJsonValue) -> QCborValue: ...
    @classmethod
    def fromVariant(cls, variant: typing.Any) -> QCborValue: ...
    def isArray(self) -> bool: ...
    def isBool(self) -> bool: ...
    def isByteArray(self) -> bool: ...
    def isContainer(self) -> bool: ...
    def isDateTime(self) -> bool: ...
    def isDouble(self) -> bool: ...
    def isFalse(self) -> bool: ...
    def isInteger(self) -> bool: ...
    def isInvalid(self) -> bool: ...
    def isMap(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isRegularExpression(self) -> bool: ...
    @overload
    def isSimpleType(self) -> bool: ...
    @overload
    def isSimpleType(self, st: QCborSimpleType) -> bool: ...
    def isString(self) -> bool: ...
    def isTag(self) -> bool: ...
    def isTrue(self) -> bool: ...
    def isUndefined(self) -> bool: ...
    def isUrl(self) -> bool: ...
    def isUuid(self) -> bool: ...
    def swap(self, other: QCborValue) -> None: ...
    def taggedValue(self, defaultValue: QCborValue = ...) -> QCborValue: ...
    @overload
    def toArray(self) -> QCborArray: ...
    @overload
    def toArray(self, defaultValue: QCborArray) -> QCborArray: ...
    def toBool(self, defaultValue: bool = ...) -> bool: ...
    def toByteArray(self, defaultValue: typing.Union[QByteArray,bytes] = ...) -> QByteArray: ...
    @overload
    def toCbor(self, opt: typing.Union[QCborValue.EncodingOptions,QCborValue.EncodingOption] = ...) -> QByteArray: ...
    @overload
    def toCbor(self, writer: QCborStreamWriter, opt: typing.Union[QCborValue.EncodingOptions,QCborValue.EncodingOption] = ...) -> None: ...
    def toDateTime(self, defaultValue: QDateTime = ...) -> QDateTime: ...
    def toDiagnosticNotation(self, opts: typing.Union[QCborValue.DiagnosticNotationOptions,QCborValue.DiagnosticNotationOption] = ...) -> str: ...
    def toDouble(self, defaultValue: float = ...) -> float: ...
    def toInteger(self, defaultValue: int = ...) -> int: ...
    def toJsonValue(self) -> QJsonValue: ...
    @overload
    def toMap(self) -> QCborMap: ...
    @overload
    def toMap(self, defaultValue: QCborMap) -> QCborMap: ...
    def toRegularExpression(self, defaultValue: QRegularExpression = ...) -> QRegularExpression: ...
    def toSimpleType(self, defaultValue: QCborSimpleType = ...) -> QCborSimpleType: ...
    def toString(self, defaultValue: str = ...) -> str: ...
    def toUrl(self, defaultValue: QUrl = ...) -> QUrl: ...
    def toUuid(self, defaultValue: QUuid = ...) -> QUuid: ...
    def toVariant(self) -> typing.Any: ...
    def type(self) -> QCborValue.Type: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QChildEvent(QEvent):
    def __init__(self, type: QEvent.Type, child: QObject) -> None: ...
    def added(self) -> bool: ...
    def child(self) -> QObject: ...
    def polished(self) -> bool: ...
    def removed(self) -> bool: ...

class QCollator(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QCollator) -> None: ...
    @overload
    def __init__(self, locale: QLocale) -> None: ...
    def caseSensitivity(self) -> Qt.CaseSensitivity: ...
    @overload
    def compare(self, s1: bytes, len1: int, s2: bytes, len2: int) -> int: ...
    @overload
    def compare(self, s1: str, s2: str) -> int: ...
    def ignorePunctuation(self) -> bool: ...
    def locale(self) -> QLocale: ...
    def numericMode(self) -> bool: ...
    def setCaseSensitivity(self, cs: Qt.CaseSensitivity) -> None: ...
    def setIgnorePunctuation(self, on: bool) -> None: ...
    def setLocale(self, locale: QLocale) -> None: ...
    def setNumericMode(self, on: bool) -> None: ...
    def sortKey(self, string: str) -> QCollatorSortKey: ...
    def swap(self, other: QCollator) -> None: ...
    def __call__(self, s1: str, s2: str) -> bool: ...

class QCollatorSortKey(shiboken2.Object):
    def __init__(self, other: QCollatorSortKey) -> None: ...
    def compare(self, key: QCollatorSortKey) -> int: ...
    def swap(self, other: QCollatorSortKey) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QCommandLineOption(shiboken2.Object):
    class Flag:
        HiddenFromHelp: ClassVar[QCommandLineOption.Flag] = ...
        ShortOptionStyle: ClassVar[QCommandLineOption.Flag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QCommandLineOption.Flag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __rand__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __ror__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __xor__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...

    class Flags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QCommandLineOption.Flags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __rand__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __ror__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
        def __xor__(self, other: typing.SupportsInt) -> QCommandLineOption.Flags: ...
    HiddenFromHelp: ClassVar[QCommandLineOption.Flag] = ...
    ShortOptionStyle: ClassVar[QCommandLineOption.Flag] = ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, name: str, description: str, valueName: str = ..., defaultValue: str = ...) -> None: ...
    @overload
    def __init__(self, names: typing.Sequence[str]) -> None: ...
    @overload
    def __init__(self, names: typing.Sequence[str], description: str, valueName: str = ..., defaultValue: str = ...) -> None: ...
    @overload
    def __init__(self, other: QCommandLineOption) -> None: ...
    def defaultValues(self) -> typing.List[str]: ...
    def description(self) -> str: ...
    def flags(self) -> typing.Union[QCommandLineOption.Flags,QCommandLineOption.Flag]: ...
    def isHidden(self) -> bool: ...
    def names(self) -> typing.List[str]: ...
    def setDefaultValue(self, defaultValue: str) -> None: ...
    def setDefaultValues(self, defaultValues: typing.Sequence[str]) -> None: ...
    def setDescription(self, description: str) -> None: ...
    def setFlags(self, aflags: typing.Union[QCommandLineOption.Flags,QCommandLineOption.Flag]) -> None: ...
    def setHidden(self, hidden: bool) -> None: ...
    def setValueName(self, name: str) -> None: ...
    def swap(self, other: QCommandLineOption) -> None: ...
    def valueName(self) -> str: ...

class QCommandLineParser(shiboken2.Object):
    class OptionsAfterPositionalArgumentsMode:
        ParseAsOptions: ClassVar[QCommandLineParser.OptionsAfterPositionalArgumentsMode] = ...
        ParseAsPositionalArguments: ClassVar[QCommandLineParser.OptionsAfterPositionalArgumentsMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __and__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QCommandLineParser.OptionsAfterPositionalArgumentsMode: ...

    class SingleDashWordOptionMode:
        ParseAsCompactedShortOptions: ClassVar[QCommandLineParser.SingleDashWordOptionMode] = ...
        ParseAsLongOptions: ClassVar[QCommandLineParser.SingleDashWordOptionMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __and__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QCommandLineParser.SingleDashWordOptionMode: ...
    ParseAsCompactedShortOptions: ClassVar[QCommandLineParser.SingleDashWordOptionMode] = ...
    ParseAsLongOptions: ClassVar[QCommandLineParser.SingleDashWordOptionMode] = ...
    ParseAsOptions: ClassVar[QCommandLineParser.OptionsAfterPositionalArgumentsMode] = ...
    ParseAsPositionalArguments: ClassVar[QCommandLineParser.OptionsAfterPositionalArgumentsMode] = ...
    def __init__(self) -> None: ...
    def addHelpOption(self) -> QCommandLineOption: ...
    def addOption(self, commandLineOption: QCommandLineOption) -> bool: ...
    def addOptions(self, options: typing.Sequence[QCommandLineOption]) -> bool: ...
    def addPositionalArgument(self, name: str, description: str, syntax: str = ...) -> None: ...
    def addVersionOption(self) -> QCommandLineOption: ...
    def applicationDescription(self) -> str: ...
    def clearPositionalArguments(self) -> None: ...
    def errorText(self) -> str: ...
    def helpText(self) -> str: ...
    @overload
    def isSet(self, name: str) -> bool: ...
    @overload
    def isSet(self, option: QCommandLineOption) -> bool: ...
    def optionNames(self) -> typing.List[str]: ...
    def parse(self, arguments: typing.Sequence[str]) -> bool: ...
    def positionalArguments(self) -> typing.List[str]: ...
    @overload
    def process(self, app: QCoreApplication) -> None: ...
    @overload
    def process(self, arguments: typing.Sequence[str]) -> None: ...
    def setApplicationDescription(self, description: str) -> None: ...
    def setOptionsAfterPositionalArgumentsMode(self, mode: QCommandLineParser.OptionsAfterPositionalArgumentsMode) -> None: ...
    def setSingleDashWordOptionMode(self, parsingMode: QCommandLineParser.SingleDashWordOptionMode) -> None: ...
    def showHelp(self, exitCode: int = ...) -> None: ...
    def showVersion(self) -> None: ...
    def unknownOptionNames(self) -> typing.List[str]: ...
    @overload
    def value(self, name: str) -> str: ...
    @overload
    def value(self, option: QCommandLineOption) -> str: ...
    @overload
    def values(self, name: str) -> typing.List[str]: ...
    @overload
    def values(self, option: QCommandLineOption) -> typing.List[str]: ...

class QConcatenateTablesProxyModel(QAbstractItemModel):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., columnsAboutToBeInserted: typing.Callable = ..., columnsAboutToBeMoved: typing.Callable = ..., columnsAboutToBeRemoved: typing.Callable = ..., columnsInserted: typing.Callable = ..., columnsMoved: typing.Callable = ..., columnsRemoved: typing.Callable = ..., dataChanged: typing.Callable = ..., destroyed: typing.Callable = ..., headerDataChanged: typing.Callable = ..., layoutAboutToBeChanged: typing.Callable = ..., layoutChanged: typing.Callable = ..., modelAboutToBeReset: typing.Callable = ..., modelReset: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., rowsAboutToBeInserted: typing.Callable = ..., rowsAboutToBeMoved: typing.Callable = ..., rowsAboutToBeRemoved: typing.Callable = ..., rowsInserted: typing.Callable = ..., rowsMoved: typing.Callable = ..., rowsRemoved: typing.Callable = ...) -> None: ...
    def addSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...
    def canDropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    def data(self, index: QModelIndex, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def itemData(self, proxyIndex: QModelIndex) -> typing.Dict[int,typing.Any]: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def mimeData(self, indexes: typing.List[int]) -> QMimeData: ...
    def mimeTypes(self) -> typing.List[str]: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, index: QModelIndex) -> QModelIndex: ...
    def removeSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int,typing.Any]) -> bool: ...
    def sourceModels(self) -> typing.List[QAbstractItemModel]: ...
    def span(self, index: QModelIndex) -> QSize: ...

class QCoreApplication(QObject):
    ApplicationFlags: ClassVar[int] = ...
    aboutToQuit: ClassVar[Signal] = ...
    applicationNameChanged: ClassVar[Signal] = ...
    applicationVersionChanged: ClassVar[Signal] = ...
    organizationDomainChanged: ClassVar[Signal] = ...
    organizationNameChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, arg__1: typing.Sequence[str], destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @classmethod
    def addLibraryPath(cls, arg__1: str) -> None: ...
    @classmethod
    def applicationDirPath(cls) -> str: ...
    @classmethod
    def applicationFilePath(cls) -> str: ...
    @classmethod
    def applicationName(cls) -> str: ...
    @classmethod
    def applicationPid(cls) -> int: ...
    @classmethod
    def applicationVersion(cls) -> str: ...
    @classmethod
    def arguments(cls) -> typing.List[str]: ...
    @classmethod
    def closingDown(cls) -> bool: ...
    def event(self, arg__1: QEvent) -> bool: ...
    @classmethod
    def eventDispatcher(cls) -> QAbstractEventDispatcher: ...
    @classmethod
    def exec_(cls) -> int: ...
    @classmethod
    def exit(cls, retcode: int = ...) -> None: ...
    @classmethod
    def flush(cls) -> None: ...
    @classmethod
    def hasPendingEvents(cls) -> bool: ...
    def installNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    @classmethod
    def installTranslator(cls, messageFile: QTranslator) -> bool: ...
    @classmethod
    def instance(cls: typing.Type[T]) -> T: ...
    @classmethod
    def isQuitLockEnabled(cls) -> bool: ...
    @classmethod
    def isSetuidAllowed(cls) -> bool: ...
    @classmethod
    def libraryPaths(cls) -> typing.List[str]: ...
    def notify(self, arg__1: QObject, arg__2: QEvent) -> bool: ...
    @classmethod
    def organizationDomain(cls) -> str: ...
    @classmethod
    def organizationName(cls) -> str: ...
    @classmethod
    def postEvent(cls, receiver: QObject, event: QEvent, priority: int = ...) -> None: ...
    @classmethod
    @overload
    def processEvents(cls, flags: typing.Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag], maxtime: int) -> None: ...
    @classmethod
    @overload
    def processEvents(cls, flags: typing.Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag] = ...) -> None: ...
    @classmethod
    def quit(cls) -> None: ...
    @classmethod
    def removeLibraryPath(cls, arg__1: str) -> None: ...
    def removeNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    @classmethod
    def removePostedEvents(cls, receiver: QObject, eventType: int = ...) -> None: ...
    @classmethod
    def removeTranslator(cls, messageFile: QTranslator) -> bool: ...
    @classmethod
    def sendEvent(cls, receiver: QObject, event: QEvent) -> bool: ...
    @classmethod
    def sendPostedEvents(cls, receiver: typing.Union[QObject,None] = ..., event_type: int = ...) -> None: ...
    @classmethod
    def setApplicationName(cls, application: str) -> None: ...
    @classmethod
    def setApplicationVersion(cls, version: str) -> None: ...
    @classmethod
    def setAttribute(cls, attribute: Qt.ApplicationAttribute, on: bool = ...) -> None: ...
    @classmethod
    def setEventDispatcher(cls, eventDispatcher: QAbstractEventDispatcher) -> None: ...
    @classmethod
    def setLibraryPaths(cls, arg__1: typing.Sequence[str]) -> None: ...
    @classmethod
    def setOrganizationDomain(cls, orgDomain: str) -> None: ...
    @classmethod
    def setOrganizationName(cls, orgName: str) -> None: ...
    @classmethod
    def setQuitLockEnabled(cls, enabled: bool) -> None: ...
    @classmethod
    def setSetuidAllowed(cls, allow: bool) -> None: ...
    def shutdown(self) -> None: ...
    @classmethod
    def startingUp(cls) -> bool: ...
    @classmethod
    def testAttribute(cls, attribute: Qt.ApplicationAttribute) -> bool: ...
    @classmethod
    def translate(cls, context: bytes, key: bytes, disambiguation: typing.Union[bytes,None] = ..., n: int = ...) -> str: ...

class QCryptographicHash(shiboken2.Object):
    class Algorithm:
        Keccak_224: ClassVar[QCryptographicHash.Algorithm] = ...
        Keccak_256: ClassVar[QCryptographicHash.Algorithm] = ...
        Keccak_384: ClassVar[QCryptographicHash.Algorithm] = ...
        Keccak_512: ClassVar[QCryptographicHash.Algorithm] = ...
        Md4: ClassVar[QCryptographicHash.Algorithm] = ...
        Md5: ClassVar[QCryptographicHash.Algorithm] = ...
        RealSha3_224: ClassVar[QCryptographicHash.Algorithm] = ...
        RealSha3_256: ClassVar[QCryptographicHash.Algorithm] = ...
        RealSha3_384: ClassVar[QCryptographicHash.Algorithm] = ...
        RealSha3_512: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha1: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha224: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha256: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha384: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha3_224: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha3_256: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha3_384: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha3_512: ClassVar[QCryptographicHash.Algorithm] = ...
        Sha512: ClassVar[QCryptographicHash.Algorithm] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __and__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __rand__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __rmul__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __ror__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __rsub__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __rxor__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __sub__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
        def __xor__(self, other: typing.SupportsInt) -> QCryptographicHash.Algorithm: ...
    Keccak_224: ClassVar[QCryptographicHash.Algorithm] = ...
    Keccak_256: ClassVar[QCryptographicHash.Algorithm] = ...
    Keccak_384: ClassVar[QCryptographicHash.Algorithm] = ...
    Keccak_512: ClassVar[QCryptographicHash.Algorithm] = ...
    Md4: ClassVar[QCryptographicHash.Algorithm] = ...
    Md5: ClassVar[QCryptographicHash.Algorithm] = ...
    RealSha3_224: ClassVar[QCryptographicHash.Algorithm] = ...
    RealSha3_256: ClassVar[QCryptographicHash.Algorithm] = ...
    RealSha3_384: ClassVar[QCryptographicHash.Algorithm] = ...
    RealSha3_512: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha1: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha224: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha256: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha384: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha3_224: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha3_256: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha3_384: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha3_512: ClassVar[QCryptographicHash.Algorithm] = ...
    Sha512: ClassVar[QCryptographicHash.Algorithm] = ...
    def __init__(self, method: QCryptographicHash.Algorithm) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def addData(self, data: bytes, length: int) -> None: ...
    @overload
    def addData(self, device: QIODevice) -> bool: ...
    @classmethod
    def hash(cls, data: typing.Union[QByteArray,bytes], method: QCryptographicHash.Algorithm) -> QByteArray: ...
    @classmethod
    def hashLength(cls, method: QCryptographicHash.Algorithm) -> int: ...
    def reset(self) -> None: ...
    def result(self) -> QByteArray: ...

class QDataStream(shiboken2.Object):
    class ByteOrder:
        BigEndian: ClassVar[QDataStream.ByteOrder] = ...
        LittleEndian: ClassVar[QDataStream.ByteOrder] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __and__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __rand__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __ror__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __sub__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...
        def __xor__(self, other: typing.SupportsInt) -> QDataStream.ByteOrder: ...

    class FloatingPointPrecision:
        DoublePrecision: ClassVar[QDataStream.FloatingPointPrecision] = ...
        SinglePrecision: ClassVar[QDataStream.FloatingPointPrecision] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __and__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __rand__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __ror__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __sub__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...
        def __xor__(self, other: typing.SupportsInt) -> QDataStream.FloatingPointPrecision: ...

    class Status:
        Ok: ClassVar[QDataStream.Status] = ...
        ReadCorruptData: ClassVar[QDataStream.Status] = ...
        ReadPastEnd: ClassVar[QDataStream.Status] = ...
        WriteFailed: ClassVar[QDataStream.Status] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __and__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __rand__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __ror__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __sub__(self, other: typing.SupportsInt) -> QDataStream.Status: ...
        def __xor__(self, other: typing.SupportsInt) -> QDataStream.Status: ...

    class Version:
        Qt_1_0: ClassVar[QDataStream.Version] = ...
        Qt_2_0: ClassVar[QDataStream.Version] = ...
        Qt_2_1: ClassVar[QDataStream.Version] = ...
        Qt_3_0: ClassVar[QDataStream.Version] = ...
        Qt_3_1: ClassVar[QDataStream.Version] = ...
        Qt_3_3: ClassVar[QDataStream.Version] = ...
        Qt_4_0: ClassVar[QDataStream.Version] = ...
        Qt_4_1: ClassVar[QDataStream.Version] = ...
        Qt_4_2: ClassVar[QDataStream.Version] = ...
        Qt_4_3: ClassVar[QDataStream.Version] = ...
        Qt_4_4: ClassVar[QDataStream.Version] = ...
        Qt_4_5: ClassVar[QDataStream.Version] = ...
        Qt_4_6: ClassVar[QDataStream.Version] = ...
        Qt_4_7: ClassVar[QDataStream.Version] = ...
        Qt_4_8: ClassVar[QDataStream.Version] = ...
        Qt_4_9: ClassVar[QDataStream.Version] = ...
        Qt_5_0: ClassVar[QDataStream.Version] = ...
        Qt_5_1: ClassVar[QDataStream.Version] = ...
        Qt_5_10: ClassVar[QDataStream.Version] = ...
        Qt_5_11: ClassVar[QDataStream.Version] = ...
        Qt_5_12: ClassVar[QDataStream.Version] = ...
        Qt_5_13: ClassVar[QDataStream.Version] = ...
        Qt_5_14: ClassVar[QDataStream.Version] = ...
        Qt_5_15: ClassVar[QDataStream.Version] = ...
        Qt_5_2: ClassVar[QDataStream.Version] = ...
        Qt_5_3: ClassVar[QDataStream.Version] = ...
        Qt_5_4: ClassVar[QDataStream.Version] = ...
        Qt_5_5: ClassVar[QDataStream.Version] = ...
        Qt_5_6: ClassVar[QDataStream.Version] = ...
        Qt_5_7: ClassVar[QDataStream.Version] = ...
        Qt_5_8: ClassVar[QDataStream.Version] = ...
        Qt_5_9: ClassVar[QDataStream.Version] = ...
        Qt_DefaultCompiledVersion: ClassVar[QDataStream.Version] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __and__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __rand__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __ror__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __sub__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
        def __xor__(self, other: typing.SupportsInt) -> QDataStream.Version: ...
    BigEndian: ClassVar[QDataStream.ByteOrder] = ...
    DoublePrecision: ClassVar[QDataStream.FloatingPointPrecision] = ...
    LittleEndian: ClassVar[QDataStream.ByteOrder] = ...
    Ok: ClassVar[QDataStream.Status] = ...
    Qt_1_0: ClassVar[QDataStream.Version] = ...
    Qt_2_0: ClassVar[QDataStream.Version] = ...
    Qt_2_1: ClassVar[QDataStream.Version] = ...
    Qt_3_0: ClassVar[QDataStream.Version] = ...
    Qt_3_1: ClassVar[QDataStream.Version] = ...
    Qt_3_3: ClassVar[QDataStream.Version] = ...
    Qt_4_0: ClassVar[QDataStream.Version] = ...
    Qt_4_1: ClassVar[QDataStream.Version] = ...
    Qt_4_2: ClassVar[QDataStream.Version] = ...
    Qt_4_3: ClassVar[QDataStream.Version] = ...
    Qt_4_4: ClassVar[QDataStream.Version] = ...
    Qt_4_5: ClassVar[QDataStream.Version] = ...
    Qt_4_6: ClassVar[QDataStream.Version] = ...
    Qt_4_7: ClassVar[QDataStream.Version] = ...
    Qt_4_8: ClassVar[QDataStream.Version] = ...
    Qt_4_9: ClassVar[QDataStream.Version] = ...
    Qt_5_0: ClassVar[QDataStream.Version] = ...
    Qt_5_1: ClassVar[QDataStream.Version] = ...
    Qt_5_10: ClassVar[QDataStream.Version] = ...
    Qt_5_11: ClassVar[QDataStream.Version] = ...
    Qt_5_12: ClassVar[QDataStream.Version] = ...
    Qt_5_13: ClassVar[QDataStream.Version] = ...
    Qt_5_14: ClassVar[QDataStream.Version] = ...
    Qt_5_15: ClassVar[QDataStream.Version] = ...
    Qt_5_2: ClassVar[QDataStream.Version] = ...
    Qt_5_3: ClassVar[QDataStream.Version] = ...
    Qt_5_4: ClassVar[QDataStream.Version] = ...
    Qt_5_5: ClassVar[QDataStream.Version] = ...
    Qt_5_6: ClassVar[QDataStream.Version] = ...
    Qt_5_7: ClassVar[QDataStream.Version] = ...
    Qt_5_8: ClassVar[QDataStream.Version] = ...
    Qt_5_9: ClassVar[QDataStream.Version] = ...
    Qt_DefaultCompiledVersion: ClassVar[QDataStream.Version] = ...
    ReadCorruptData: ClassVar[QDataStream.Status] = ...
    ReadPastEnd: ClassVar[QDataStream.Status] = ...
    SinglePrecision: ClassVar[QDataStream.FloatingPointPrecision] = ...
    WriteFailed: ClassVar[QDataStream.Status] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, arg__1: typing.Union[QByteArray,bytes], flags: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> None: ...
    @overload
    def __init__(self, arg__1: QIODevice) -> None: ...
    def abortTransaction(self) -> None: ...
    def atEnd(self) -> bool: ...
    def byteOrder(self) -> QDataStream.ByteOrder: ...
    def commitTransaction(self) -> bool: ...
    def device(self) -> QIODevice: ...
    def floatingPointPrecision(self) -> QDataStream.FloatingPointPrecision: ...
    def readBool(self) -> bool: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    def readInt16(self) -> int: ...
    def readInt32(self) -> int: ...
    def readInt64(self) -> int: ...
    def readInt8(self) -> int: ...
    def readQChar(self) -> str: ...
    def readQString(self) -> str: ...
    def readQStringList(self) -> typing.List[str]: ...
    def readQVariant(self) -> typing.Any: ...
    def readRawData(self, arg__1: bytes, len: int) -> int: ...
    def readString(self) -> str: ...
    def readUInt16(self) -> int: ...
    def readUInt32(self) -> int: ...
    def readUInt64(self) -> int: ...
    def readUInt8(self) -> int: ...
    def resetStatus(self) -> None: ...
    def rollbackTransaction(self) -> None: ...
    def setByteOrder(self, arg__1: QDataStream.ByteOrder) -> None: ...
    def setDevice(self, arg__1: QIODevice) -> None: ...
    def setFloatingPointPrecision(self, precision: QDataStream.FloatingPointPrecision) -> None: ...
    def setStatus(self, status: QDataStream.Status) -> None: ...
    def setVersion(self, arg__1: int) -> None: ...
    def skipRawData(self, len: int) -> int: ...
    def startTransaction(self) -> None: ...
    def status(self) -> QDataStream.Status: ...
    def unsetDevice(self) -> None: ...
    def version(self) -> int: ...
    def writeBool(self, arg__1: bool) -> None: ...
    def writeDouble(self, arg__1: float) -> None: ...
    def writeFloat(self, arg__1: float) -> None: ...
    def writeInt16(self, arg__1: int) -> None: ...
    def writeInt32(self, arg__1: int) -> None: ...
    def writeInt64(self, arg__1: int) -> None: ...
    def writeInt8(self, arg__1: int) -> None: ...
    def writeQChar(self, arg__1: str) -> None: ...
    def writeQString(self, arg__1: str) -> None: ...
    def writeQStringList(self, arg__1: typing.Sequence[str]) -> None: ...
    def writeQVariant(self, arg__1: typing.Any) -> None: ...
    def writeRawData(self, arg__1: bytes, len: int) -> int: ...
    def writeString(self, arg__1: str) -> None: ...
    def writeUInt16(self, arg__1: int) -> None: ...
    def writeUInt32(self, arg__1: int) -> None: ...
    def writeUInt64(self, arg__1: int) -> None: ...
    def writeUInt8(self, arg__1: int) -> None: ...
    @overload
    def __lshift__(self, arg__1: str) -> None: ...
    @overload
    def __lshift__(self, arg__2: QBitArray) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: typing.Union[QByteArray,bytes]) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QCborArray) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QCborMap) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QCborValue) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QDate) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QDateTime) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QEasingCurve) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QJsonArray) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QJsonDocument) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QJsonValue) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QLine) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QLineF) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QLocale) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QMargins) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QMarginsF) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QPoint) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QPointF) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QRect) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QRectF) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QSize) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QSizeF) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QTime) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QUrl) -> QDataStream: ...
    @overload
    def __lshift__(self, arg__2: QUuid) -> QDataStream: ...
    @overload
    def __lshift__(self, re: QRegularExpression) -> QDataStream: ...
    @overload
    def __lshift__(self, regExp: QRegExp) -> QDataStream: ...
    @overload
    def __lshift__(self, tz: QTimeZone) -> QDataStream: ...
    @overload
    def __lshift__(self, version: QVersionNumber) -> QDataStream: ...
    def __rlshift__(self, other) -> Any: ...
    def __rrshift__(self, other) -> Any: ...
    @overload
    def __rshift__(self, arg__2: QBitArray) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: typing.Union[QByteArray,bytes]) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QCborArray) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QCborMap) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QCborValue) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QDate) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QDateTime) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QEasingCurve) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QJsonArray) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QJsonDocument) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QJsonValue) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QLine) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QLineF) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QLocale) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QMargins) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QMarginsF) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QPoint) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QPointF) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QRect) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QRectF) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QSize) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QSizeF) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QTime) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QUrl) -> QDataStream: ...
    @overload
    def __rshift__(self, arg__2: QUuid) -> QDataStream: ...
    @overload
    def __rshift__(self, re: QRegularExpression) -> QDataStream: ...
    @overload
    def __rshift__(self, regExp: QRegExp) -> QDataStream: ...
    @overload
    def __rshift__(self, tz: QTimeZone) -> QDataStream: ...
    @overload
    def __rshift__(self, version: QVersionNumber) -> QDataStream: ...

class QDate(shiboken2.Object):
    class MonthNameType:
        DateFormat: ClassVar[QDate.MonthNameType] = ...
        StandaloneFormat: ClassVar[QDate.MonthNameType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __and__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __rand__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __ror__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __sub__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
        def __xor__(self, other: typing.SupportsInt) -> QDate.MonthNameType: ...
    DateFormat: ClassVar[QDate.MonthNameType] = ...
    StandaloneFormat: ClassVar[QDate.MonthNameType] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QDate: QDate) -> None: ...
    @overload
    def __init__(self, y: int, m: int, d: int) -> None: ...
    @overload
    def __init__(self, y: int, m: int, d: int, cal: QCalendar) -> None: ...
    @overload
    def __init__(self, date: datetime.date) -> None: ...
    def addDays(self, days: int) -> QDate: ...
    @overload
    def addMonths(self, months: int) -> QDate: ...
    @overload
    def addMonths(self, months: int, cal: QCalendar) -> QDate: ...
    @overload
    def addYears(self, years: int) -> QDate: ...
    @overload
    def addYears(self, years: int, cal: QCalendar) -> QDate: ...
    @classmethod
    def currentDate(cls) -> QDate: ...
    @overload
    def day(self) -> int: ...
    @overload
    def day(self, cal: QCalendar) -> int: ...
    @overload
    def dayOfWeek(self) -> int: ...
    @overload
    def dayOfWeek(self, cal: QCalendar) -> int: ...
    @overload
    def dayOfYear(self) -> int: ...
    @overload
    def dayOfYear(self, cal: QCalendar) -> int: ...
    @overload
    def daysInMonth(self) -> int: ...
    @overload
    def daysInMonth(self, cal: QCalendar) -> int: ...
    @overload
    def daysInYear(self) -> int: ...
    @overload
    def daysInYear(self, cal: QCalendar) -> int: ...
    def daysTo(self, arg__1: QDate) -> int: ...
    @overload
    def endOfDay(self, spec: Qt.TimeSpec = ..., offsetSeconds: int = ...) -> QDateTime: ...
    @overload
    def endOfDay(self, zone: QTimeZone) -> QDateTime: ...
    @classmethod
    def fromJulianDay(cls, jd_: int) -> QDate: ...
    @classmethod
    @overload
    def fromString(cls, s: str, f: Qt.DateFormat = ...) -> QDate: ...
    @classmethod
    @overload
    def fromString(cls, s: str, format: str) -> QDate: ...
    @classmethod
    @overload
    def fromString(cls, s: str, format: str, cal: QCalendar) -> QDate: ...
    def getDate(self) -> typing.Tuple[int,int,int]: ...
    @classmethod
    def isLeapYear(cls, year: int) -> bool: ...
    def isNull(self) -> bool: ...
    @classmethod
    @overload
    def isValid(cls, self) -> bool: ...
    @classmethod
    @overload
    def isValid(cls, y: int, m: int, d: int) -> bool: ...
    @classmethod
    def longDayName(cls, weekday: int, type: QDate.MonthNameType = ...) -> str: ...
    @classmethod
    def longMonthName(cls, month: int, type: QDate.MonthNameType = ...) -> str: ...
    @overload
    def month(self) -> int: ...
    @overload
    def month(self, cal: QCalendar) -> int: ...
    @overload
    def setDate(self, year: int, month: int, day: int) -> bool: ...
    @overload
    def setDate(self, year: int, month: int, day: int, cal: QCalendar) -> bool: ...
    @classmethod
    def shortDayName(cls, weekday: int, type: QDate.MonthNameType = ...) -> str: ...
    @classmethod
    def shortMonthName(cls, month: int, type: QDate.MonthNameType = ...) -> str: ...
    @overload
    def startOfDay(self, spec: Qt.TimeSpec = ..., offsetSeconds: int = ...) -> QDateTime: ...
    @overload
    def startOfDay(self, zone: QTimeZone) -> QDateTime: ...
    def toJulianDay(self) -> int: ...
    def toPython(self) -> object: ...
    @overload
    def toString(self, format: Qt.DateFormat, cal: QCalendar) -> str: ...
    @overload
    def toString(self, format: Qt.DateFormat = ...) -> str: ...
    @overload
    def toString(self, format: str) -> str: ...
    @overload
    def toString(self, format: str, cal: QCalendar) -> str: ...
    def weekNumber(self) -> typing.Tuple[int,int]: ...
    @overload
    def year(self) -> int: ...
    @overload
    def year(self, cal: QCalendar) -> int: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QDateTime(shiboken2.Object):
    class YearRange:
        First: ClassVar[QDateTime.YearRange] = ...
        Last: ClassVar[QDateTime.YearRange] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __and__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __rand__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __ror__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __sub__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
        def __xor__(self, other: typing.SupportsInt) -> QDateTime.YearRange: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QDate) -> None: ...
    @overload
    def __init__(self, arg__1: QDate, arg__2: QTime, spec: Qt.TimeSpec = ...) -> None: ...
    @overload
    def __init__(self, arg__1: int, arg__2: int, arg__3: int, arg__4: int, arg__5: int, arg__6: int) -> None: ...
    @overload
    def __init__(self, arg__1: int, arg__2: int, arg__3: int, arg__4: int, arg__5: int, arg__6: int, arg__7: int, arg__8: int = ...) -> None: ...
    @overload
    def __init__(self, date: QDate, time: QTime, spec: Qt.TimeSpec, offsetSeconds: int) -> None: ...
    @overload
    def __init__(self, date: QDate, time: QTime, timeZone: QTimeZone) -> None: ...
    @overload
    def __init__(self, other: QDateTime) -> None: ...
    @overload
    def __init__(self, datetime: datetime.datetime) -> None: ...
    def addDays(self, days: int) -> QDateTime: ...
    def addMSecs(self, msecs: int) -> QDateTime: ...
    def addMonths(self, months: int) -> QDateTime: ...
    def addSecs(self, secs: int) -> QDateTime: ...
    def addYears(self, years: int) -> QDateTime: ...
    @classmethod
    def currentDateTime(cls) -> QDateTime: ...
    @classmethod
    def currentDateTimeUtc(cls) -> QDateTime: ...
    @classmethod
    def currentMSecsSinceEpoch(cls) -> int: ...
    @classmethod
    def currentSecsSinceEpoch(cls) -> int: ...
    def date(self) -> QDate: ...
    def daysTo(self, arg__1: QDateTime) -> int: ...
    @classmethod
    @overload
    def fromMSecsSinceEpoch(cls, msecs: int) -> QDateTime: ...
    @classmethod
    @overload
    def fromMSecsSinceEpoch(cls, msecs: int, spec: Qt.TimeSpec, offsetFromUtc: int = ...) -> QDateTime: ...
    @classmethod
    @overload
    def fromMSecsSinceEpoch(cls, msecs: int, timeZone: QTimeZone) -> QDateTime: ...
    @classmethod
    @overload
    def fromSecsSinceEpoch(cls, secs: int, spe: Qt.TimeSpec = ..., offsetFromUtc: int = ...) -> QDateTime: ...
    @classmethod
    @overload
    def fromSecsSinceEpoch(cls, secs: int, timeZone: QTimeZone) -> QDateTime: ...
    @classmethod
    @overload
    def fromString(cls, s: str, f: Qt.DateFormat = ...) -> QDateTime: ...
    @classmethod
    @overload
    def fromString(cls, s: str, format: str) -> QDateTime: ...
    @classmethod
    @overload
    def fromString(cls, s: str, format: str, cal: QCalendar) -> QDateTime: ...
    @classmethod
    @overload
    def fromTime_t(cls, secsSince1Jan1970UTC: int) -> QDateTime: ...
    @classmethod
    @overload
    def fromTime_t(cls, secsSince1Jan1970UTC: int, spec: Qt.TimeSpec, offsetFromUtc: int = ...) -> QDateTime: ...
    @classmethod
    @overload
    def fromTime_t(cls, secsSince1Jan1970UTC: int, timeZone: QTimeZone) -> QDateTime: ...
    def isDaylightTime(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isValid(self) -> bool: ...
    def msecsTo(self, arg__1: QDateTime) -> int: ...
    def offsetFromUtc(self) -> int: ...
    def secsTo(self, arg__1: QDateTime) -> int: ...
    def setDate(self, date: QDate) -> None: ...
    def setMSecsSinceEpoch(self, msecs: int) -> None: ...
    def setOffsetFromUtc(self, offsetSeconds: int) -> None: ...
    def setSecsSinceEpoch(self, secs: int) -> None: ...
    def setTime(self, time: QTime) -> None: ...
    def setTimeSpec(self, spec: Qt.TimeSpec) -> None: ...
    def setTimeZone(self, toZone: QTimeZone) -> None: ...
    def setTime_t(self, secsSince1Jan1970UTC: int) -> None: ...
    def setUtcOffset(self, seconds: int) -> None: ...
    def swap(self, other: QDateTime) -> None: ...
    def time(self) -> QTime: ...
    def timeSpec(self) -> Qt.TimeSpec: ...
    def timeZone(self) -> QTimeZone: ...
    def timeZoneAbbreviation(self) -> str: ...
    def toLocalTime(self) -> QDateTime: ...
    def toMSecsSinceEpoch(self) -> int: ...
    def toOffsetFromUtc(self, offsetSeconds: int) -> QDateTime: ...
    def toPython(self) -> object: ...
    def toSecsSinceEpoch(self) -> int: ...
    @overload
    def toString(self, format: Qt.DateFormat = ...) -> str: ...
    @overload
    def toString(self, format: str) -> str: ...
    @overload
    def toString(self, format: str, cal: QCalendar) -> str: ...
    def toTimeSpec(self, spec: Qt.TimeSpec) -> QDateTime: ...
    def toTimeZone(self, toZone: QTimeZone) -> QDateTime: ...
    def toTime_t(self) -> int: ...
    def toUTC(self) -> QDateTime: ...
    def utcOffset(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QDeadlineTimer(shiboken2.Object):
    class ForeverConstant:
        Forever: ClassVar[QDeadlineTimer.ForeverConstant] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __and__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __rand__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __rmul__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __ror__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __rsub__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __sub__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
        def __xor__(self, other: typing.SupportsInt) -> QDeadlineTimer.ForeverConstant: ...
    Forever: ClassVar[QDeadlineTimer.ForeverConstant] = ...
    @overload
    def __init__(self, QDeadlineTimer: QDeadlineTimer) -> None: ...
    @overload
    def __init__(self, arg__1: QDeadlineTimer.ForeverConstant, type_: Qt.TimerType = ...) -> None: ...
    @overload
    def __init__(self, msecs: int, type: Qt.TimerType = ...) -> None: ...
    @overload
    def __init__(self, type_: Qt.TimerType = ...) -> None: ...
    def _q_data(self) -> typing.Tuple[int,int]: ...
    @classmethod
    def addNSecs(cls, dt: QDeadlineTimer, nsecs: int) -> QDeadlineTimer: ...
    @classmethod
    def current(cls, timerType: Qt.TimerType = ...) -> QDeadlineTimer: ...
    def deadline(self) -> int: ...
    def deadlineNSecs(self) -> int: ...
    def hasExpired(self) -> bool: ...
    def isForever(self) -> bool: ...
    def remainingTime(self) -> int: ...
    def remainingTimeNSecs(self) -> int: ...
    def setDeadline(self, msecs: int, timerType: Qt.TimerType = ...) -> None: ...
    def setPreciseDeadline(self, secs: int, nsecs: int = ..., type: Qt.TimerType = ...) -> None: ...
    def setPreciseRemainingTime(self, secs: int, nsecs: int = ..., type: Qt.TimerType = ...) -> None: ...
    def setRemainingTime(self, msecs: int, type: Qt.TimerType = ...) -> None: ...
    def setTimerType(self, type: Qt.TimerType) -> None: ...
    def swap(self, other: QDeadlineTimer) -> None: ...
    def timerType(self) -> Qt.TimerType: ...
    def __copy__(self) -> None: ...
    def __iadd__(self, msecs: int) -> QDeadlineTimer: ...
    def __isub__(self, msecs: int) -> QDeadlineTimer: ...

class QDir(shiboken2.Object):
    class Filter:
        AccessMask: ClassVar[QDir.Filter] = ...
        AllDirs: ClassVar[QDir.Filter] = ...
        AllEntries: ClassVar[QDir.Filter] = ...
        CaseSensitive: ClassVar[QDir.Filter] = ...
        Dirs: ClassVar[QDir.Filter] = ...
        Drives: ClassVar[QDir.Filter] = ...
        Executable: ClassVar[QDir.Filter] = ...
        Files: ClassVar[QDir.Filter] = ...
        Hidden: ClassVar[QDir.Filter] = ...
        Modified: ClassVar[QDir.Filter] = ...
        NoDot: ClassVar[QDir.Filter] = ...
        NoDotAndDotDot: ClassVar[QDir.Filter] = ...
        NoDotDot: ClassVar[QDir.Filter] = ...
        NoFilter: ClassVar[QDir.Filter] = ...
        NoSymLinks: ClassVar[QDir.Filter] = ...
        PermissionMask: ClassVar[QDir.Filter] = ...
        Readable: ClassVar[QDir.Filter] = ...
        System: ClassVar[QDir.Filter] = ...
        TypeMask: ClassVar[QDir.Filter] = ...
        Writable: ClassVar[QDir.Filter] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QDir.Filter: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __rand__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __ror__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __xor__(self, other: typing.SupportsInt) -> QDir.Filters: ...

    class Filters:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QDir.Filters: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __rand__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __ror__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDir.Filters: ...
        def __xor__(self, other: typing.SupportsInt) -> QDir.Filters: ...

    class SortFlag:
        DirsFirst: ClassVar[QDir.SortFlag] = ...
        DirsLast: ClassVar[QDir.SortFlag] = ...
        IgnoreCase: ClassVar[QDir.SortFlag] = ...
        LocaleAware: ClassVar[QDir.SortFlag] = ...
        Name: ClassVar[QDir.SortFlag] = ...
        NoSort: ClassVar[QDir.SortFlag] = ...
        Reversed: ClassVar[QDir.SortFlag] = ...
        Size: ClassVar[QDir.SortFlag] = ...
        SortByMask: ClassVar[QDir.SortFlag] = ...
        Time: ClassVar[QDir.SortFlag] = ...
        Type: ClassVar[QDir.SortFlag] = ...
        Unsorted: ClassVar[QDir.SortFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QDir.SortFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...

    class SortFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QDir.SortFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QDir.SortFlags: ...
    AccessMask: ClassVar[QDir.Filter] = ...
    AllDirs: ClassVar[QDir.Filter] = ...
    AllEntries: ClassVar[QDir.Filter] = ...
    CaseSensitive: ClassVar[QDir.Filter] = ...
    Dirs: ClassVar[QDir.Filter] = ...
    DirsFirst: ClassVar[QDir.SortFlag] = ...
    DirsLast: ClassVar[QDir.SortFlag] = ...
    Drives: ClassVar[QDir.Filter] = ...
    Executable: ClassVar[QDir.Filter] = ...
    Files: ClassVar[QDir.Filter] = ...
    Hidden: ClassVar[QDir.Filter] = ...
    IgnoreCase: ClassVar[QDir.SortFlag] = ...
    LocaleAware: ClassVar[QDir.SortFlag] = ...
    Modified: ClassVar[QDir.Filter] = ...
    Name: ClassVar[QDir.SortFlag] = ...
    NoDot: ClassVar[QDir.Filter] = ...
    NoDotAndDotDot: ClassVar[QDir.Filter] = ...
    NoDotDot: ClassVar[QDir.Filter] = ...
    NoFilter: ClassVar[QDir.Filter] = ...
    NoSort: ClassVar[QDir.SortFlag] = ...
    NoSymLinks: ClassVar[QDir.Filter] = ...
    PermissionMask: ClassVar[QDir.Filter] = ...
    Readable: ClassVar[QDir.Filter] = ...
    Reversed: ClassVar[QDir.SortFlag] = ...
    Size: ClassVar[QDir.SortFlag] = ...
    SortByMask: ClassVar[QDir.SortFlag] = ...
    System: ClassVar[QDir.Filter] = ...
    Time: ClassVar[QDir.SortFlag] = ...
    Type: ClassVar[QDir.SortFlag] = ...
    TypeMask: ClassVar[QDir.Filter] = ...
    Unsorted: ClassVar[QDir.SortFlag] = ...
    Writable: ClassVar[QDir.Filter] = ...
    @overload
    def __init__(self, arg__1: QDir) -> None: ...
    @overload
    def __init__(self, path: str, nameFilter: str, sort: typing.Union[QDir.SortFlags,QDir.SortFlag] = ..., filter: typing.Union[QDir.Filters,QDir.Filter] = ...) -> None: ...
    @overload
    def __init__(self, path: str = ...) -> None: ...
    def absoluteFilePath(self, fileName: str) -> str: ...
    def absolutePath(self) -> str: ...
    @classmethod
    def addResourceSearchPath(cls, path: str) -> None: ...
    @classmethod
    def addSearchPath(cls, prefix: str, path: str) -> None: ...
    def canonicalPath(self) -> str: ...
    def cd(self, dirName: str) -> bool: ...
    def cdUp(self) -> bool: ...
    @classmethod
    def cleanPath(cls, path: str) -> str: ...
    def count(self) -> int: ...
    @classmethod
    def current(cls) -> QDir: ...
    @classmethod
    def currentPath(cls) -> str: ...
    def dirName(self) -> str: ...
    @classmethod
    def drives(cls) -> typing.List[QFileInfo]: ...
    @overload
    def entryInfoList(self, filters: typing.Union[QDir.Filters,QDir.Filter] = ..., sort: typing.Union[QDir.SortFlags,QDir.SortFlag] = ...) -> typing.List[QFileInfo]: ...
    @overload
    def entryInfoList(self, nameFilters: typing.Sequence[str], filters: typing.Union[QDir.Filters,QDir.Filter] = ..., sort: typing.Union[QDir.SortFlags,QDir.SortFlag] = ...) -> typing.List[QFileInfo]: ...
    @overload
    def entryList(self, filters: typing.Union[QDir.Filters,QDir.Filter] = ..., sort: typing.Union[QDir.SortFlags,QDir.SortFlag] = ...) -> typing.List[str]: ...
    @overload
    def entryList(self, nameFilters: typing.Sequence[str], filters: typing.Union[QDir.Filters,QDir.Filter] = ..., sort: typing.Union[QDir.SortFlags,QDir.SortFlag] = ...) -> typing.List[str]: ...
    @overload
    def exists(self) -> bool: ...
    @overload
    def exists(self, name: str) -> bool: ...
    def filePath(self, fileName: str) -> str: ...
    def filter(self) -> typing.Union[QDir.Filters,QDir.Filter]: ...
    @classmethod
    def fromNativeSeparators(cls, pathName: str) -> str: ...
    @classmethod
    def home(cls) -> QDir: ...
    @classmethod
    def homePath(cls) -> str: ...
    def isAbsolute(self) -> bool: ...
    @classmethod
    def isAbsolutePath(cls, path: str) -> bool: ...
    def isEmpty(self, filters: typing.Union[QDir.Filters,QDir.Filter] = ...) -> bool: ...
    def isReadable(self) -> bool: ...
    def isRelative(self) -> bool: ...
    @classmethod
    def isRelativePath(cls, path: str) -> bool: ...
    def isRoot(self) -> bool: ...
    @classmethod
    def listSeparator(cls) -> str: ...
    def makeAbsolute(self) -> bool: ...
    @classmethod
    @overload
    def match(cls, filter: str, fileName: str) -> bool: ...
    @classmethod
    @overload
    def match(cls, filters: typing.Sequence[str], fileName: str) -> bool: ...
    def mkdir(self, dirName: str) -> bool: ...
    def mkpath(self, dirPath: str) -> bool: ...
    def nameFilters(self) -> typing.List[str]: ...
    @classmethod
    def nameFiltersFromString(cls, nameFilter: str) -> typing.List[str]: ...
    def path(self) -> str: ...
    def refresh(self) -> None: ...
    def relativeFilePath(self, fileName: str) -> str: ...
    def remove(self, fileName: str) -> bool: ...
    def removeRecursively(self) -> bool: ...
    def rename(self, oldName: str, newName: str) -> bool: ...
    def rmdir(self, dirName: str) -> bool: ...
    def rmpath(self, dirPath: str) -> bool: ...
    @classmethod
    def root(cls) -> QDir: ...
    @classmethod
    def rootPath(cls) -> str: ...
    @classmethod
    def searchPaths(cls, prefix: str) -> typing.List[str]: ...
    @classmethod
    def separator(cls) -> str: ...
    @classmethod
    def setCurrent(cls, path: str) -> bool: ...
    def setFilter(self, filter: typing.Union[QDir.Filters,QDir.Filter]) -> None: ...
    def setNameFilters(self, nameFilters: typing.Sequence[str]) -> None: ...
    def setPath(self, path: str) -> None: ...
    @classmethod
    def setSearchPaths(cls, prefix: str, searchPaths: typing.Sequence[str]) -> None: ...
    def setSorting(self, sort: typing.Union[QDir.SortFlags,QDir.SortFlag]) -> None: ...
    def sorting(self) -> typing.Union[QDir.SortFlags,QDir.SortFlag]: ...
    def swap(self, other: QDir) -> None: ...
    @classmethod
    def temp(cls) -> QDir: ...
    @classmethod
    def tempPath(cls) -> str: ...
    @classmethod
    def toNativeSeparators(cls, pathName: str) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QDirIterator(shiboken2.Object):
    class IteratorFlag:
        FollowSymlinks: ClassVar[QDirIterator.IteratorFlag] = ...
        NoIteratorFlags: ClassVar[QDirIterator.IteratorFlag] = ...
        Subdirectories: ClassVar[QDirIterator.IteratorFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QDirIterator.IteratorFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...

    class IteratorFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QDirIterator.IteratorFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QDirIterator.IteratorFlags: ...
    FollowSymlinks: ClassVar[QDirIterator.IteratorFlag] = ...
    NoIteratorFlags: ClassVar[QDirIterator.IteratorFlag] = ...
    Subdirectories: ClassVar[QDirIterator.IteratorFlag] = ...
    @overload
    def __init__(self, dir: QDir, flags: typing.Union[QDirIterator.IteratorFlags,QDirIterator.IteratorFlag] = ...) -> None: ...
    @overload
    def __init__(self, path: str, filter: typing.Union[QDir.Filters,QDir.Filter], flags: typing.Union[QDirIterator.IteratorFlags,QDirIterator.IteratorFlag] = ...) -> None: ...
    @overload
    def __init__(self, path: str, flags: typing.Union[QDirIterator.IteratorFlags,QDirIterator.IteratorFlag] = ...) -> None: ...
    @overload
    def __init__(self, path: str, nameFilters: typing.Sequence[str], filters: typing.Union[QDir.Filters,QDir.Filter] = ..., flags: typing.Union[QDirIterator.IteratorFlags,QDirIterator.IteratorFlag] = ...) -> None: ...
    def fileInfo(self) -> QFileInfo: ...
    def fileName(self) -> str: ...
    def filePath(self) -> str: ...
    def hasNext(self) -> bool: ...
    def next(self) -> str: ...
    def path(self) -> str: ...

class QDynamicPropertyChangeEvent(QEvent):
    def __init__(self, name: typing.Union[QByteArray,bytes]) -> None: ...
    def propertyName(self) -> str: ...

class QEasingCurve(shiboken2.Object):
    class Type:
        BezierSpline: ClassVar[QEasingCurve.Type] = ...
        CosineCurve: ClassVar[QEasingCurve.Type] = ...
        Custom: ClassVar[QEasingCurve.Type] = ...
        InBack: ClassVar[QEasingCurve.Type] = ...
        InBounce: ClassVar[QEasingCurve.Type] = ...
        InCirc: ClassVar[QEasingCurve.Type] = ...
        InCubic: ClassVar[QEasingCurve.Type] = ...
        InCurve: ClassVar[QEasingCurve.Type] = ...
        InElastic: ClassVar[QEasingCurve.Type] = ...
        InExpo: ClassVar[QEasingCurve.Type] = ...
        InOutBack: ClassVar[QEasingCurve.Type] = ...
        InOutBounce: ClassVar[QEasingCurve.Type] = ...
        InOutCirc: ClassVar[QEasingCurve.Type] = ...
        InOutCubic: ClassVar[QEasingCurve.Type] = ...
        InOutElastic: ClassVar[QEasingCurve.Type] = ...
        InOutExpo: ClassVar[QEasingCurve.Type] = ...
        InOutQuad: ClassVar[QEasingCurve.Type] = ...
        InOutQuart: ClassVar[QEasingCurve.Type] = ...
        InOutQuint: ClassVar[QEasingCurve.Type] = ...
        InOutSine: ClassVar[QEasingCurve.Type] = ...
        InQuad: ClassVar[QEasingCurve.Type] = ...
        InQuart: ClassVar[QEasingCurve.Type] = ...
        InQuint: ClassVar[QEasingCurve.Type] = ...
        InSine: ClassVar[QEasingCurve.Type] = ...
        Linear: ClassVar[QEasingCurve.Type] = ...
        NCurveTypes: ClassVar[QEasingCurve.Type] = ...
        OutBack: ClassVar[QEasingCurve.Type] = ...
        OutBounce: ClassVar[QEasingCurve.Type] = ...
        OutCirc: ClassVar[QEasingCurve.Type] = ...
        OutCubic: ClassVar[QEasingCurve.Type] = ...
        OutCurve: ClassVar[QEasingCurve.Type] = ...
        OutElastic: ClassVar[QEasingCurve.Type] = ...
        OutExpo: ClassVar[QEasingCurve.Type] = ...
        OutInBack: ClassVar[QEasingCurve.Type] = ...
        OutInBounce: ClassVar[QEasingCurve.Type] = ...
        OutInCirc: ClassVar[QEasingCurve.Type] = ...
        OutInCubic: ClassVar[QEasingCurve.Type] = ...
        OutInElastic: ClassVar[QEasingCurve.Type] = ...
        OutInExpo: ClassVar[QEasingCurve.Type] = ...
        OutInQuad: ClassVar[QEasingCurve.Type] = ...
        OutInQuart: ClassVar[QEasingCurve.Type] = ...
        OutInQuint: ClassVar[QEasingCurve.Type] = ...
        OutInSine: ClassVar[QEasingCurve.Type] = ...
        OutQuad: ClassVar[QEasingCurve.Type] = ...
        OutQuart: ClassVar[QEasingCurve.Type] = ...
        OutQuint: ClassVar[QEasingCurve.Type] = ...
        OutSine: ClassVar[QEasingCurve.Type] = ...
        SineCurve: ClassVar[QEasingCurve.Type] = ...
        TCBSpline: ClassVar[QEasingCurve.Type] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __and__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __rand__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __rmul__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __ror__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __rsub__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __rxor__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __sub__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
        def __xor__(self, other: typing.SupportsInt) -> QEasingCurve.Type: ...
    BezierSpline: ClassVar[QEasingCurve.Type] = ...
    CosineCurve: ClassVar[QEasingCurve.Type] = ...
    Custom: ClassVar[QEasingCurve.Type] = ...
    InBack: ClassVar[QEasingCurve.Type] = ...
    InBounce: ClassVar[QEasingCurve.Type] = ...
    InCirc: ClassVar[QEasingCurve.Type] = ...
    InCubic: ClassVar[QEasingCurve.Type] = ...
    InCurve: ClassVar[QEasingCurve.Type] = ...
    InElastic: ClassVar[QEasingCurve.Type] = ...
    InExpo: ClassVar[QEasingCurve.Type] = ...
    InOutBack: ClassVar[QEasingCurve.Type] = ...
    InOutBounce: ClassVar[QEasingCurve.Type] = ...
    InOutCirc: ClassVar[QEasingCurve.Type] = ...
    InOutCubic: ClassVar[QEasingCurve.Type] = ...
    InOutElastic: ClassVar[QEasingCurve.Type] = ...
    InOutExpo: ClassVar[QEasingCurve.Type] = ...
    InOutQuad: ClassVar[QEasingCurve.Type] = ...
    InOutQuart: ClassVar[QEasingCurve.Type] = ...
    InOutQuint: ClassVar[QEasingCurve.Type] = ...
    InOutSine: ClassVar[QEasingCurve.Type] = ...
    InQuad: ClassVar[QEasingCurve.Type] = ...
    InQuart: ClassVar[QEasingCurve.Type] = ...
    InQuint: ClassVar[QEasingCurve.Type] = ...
    InSine: ClassVar[QEasingCurve.Type] = ...
    Linear: ClassVar[QEasingCurve.Type] = ...
    NCurveTypes: ClassVar[QEasingCurve.Type] = ...
    OutBack: ClassVar[QEasingCurve.Type] = ...
    OutBounce: ClassVar[QEasingCurve.Type] = ...
    OutCirc: ClassVar[QEasingCurve.Type] = ...
    OutCubic: ClassVar[QEasingCurve.Type] = ...
    OutCurve: ClassVar[QEasingCurve.Type] = ...
    OutElastic: ClassVar[QEasingCurve.Type] = ...
    OutExpo: ClassVar[QEasingCurve.Type] = ...
    OutInBack: ClassVar[QEasingCurve.Type] = ...
    OutInBounce: ClassVar[QEasingCurve.Type] = ...
    OutInCirc: ClassVar[QEasingCurve.Type] = ...
    OutInCubic: ClassVar[QEasingCurve.Type] = ...
    OutInElastic: ClassVar[QEasingCurve.Type] = ...
    OutInExpo: ClassVar[QEasingCurve.Type] = ...
    OutInQuad: ClassVar[QEasingCurve.Type] = ...
    OutInQuart: ClassVar[QEasingCurve.Type] = ...
    OutInQuint: ClassVar[QEasingCurve.Type] = ...
    OutInSine: ClassVar[QEasingCurve.Type] = ...
    OutQuad: ClassVar[QEasingCurve.Type] = ...
    OutQuart: ClassVar[QEasingCurve.Type] = ...
    OutQuint: ClassVar[QEasingCurve.Type] = ...
    OutSine: ClassVar[QEasingCurve.Type] = ...
    SineCurve: ClassVar[QEasingCurve.Type] = ...
    TCBSpline: ClassVar[QEasingCurve.Type] = ...
    @overload
    def __init__(self, other: QEasingCurve) -> None: ...
    @overload
    def __init__(self, type: QEasingCurve.Type = ...) -> None: ...
    def addCubicBezierSegment(self, c1: QPointF, c2: QPointF, endPoint: QPointF) -> None: ...
    def addTCBSegment(self, nextPoint: QPointF, t: float, c: float, b: float) -> None: ...
    def amplitude(self) -> float: ...
    def customType(self) -> object: ...
    def overshoot(self) -> float: ...
    def period(self) -> float: ...
    def setAmplitude(self, amplitude: float) -> None: ...
    def setCustomType(self, arg__1: object) -> None: ...
    def setOvershoot(self, overshoot: float) -> None: ...
    def setPeriod(self, period: float) -> None: ...
    def setType(self, type: QEasingCurve.Type) -> None: ...
    def swap(self, other: QEasingCurve) -> None: ...
    def toCubicSpline(self) -> typing.List[QPointF]: ...
    def type(self) -> QEasingCurve.Type: ...
    def valueForProgress(self, progress: float) -> float: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QElapsedTimer(shiboken2.Object):
    class ClockType:
        MachAbsoluteTime: ClassVar[QElapsedTimer.ClockType] = ...
        MonotonicClock: ClassVar[QElapsedTimer.ClockType] = ...
        PerformanceCounter: ClassVar[QElapsedTimer.ClockType] = ...
        SystemTime: ClassVar[QElapsedTimer.ClockType] = ...
        TickCounter: ClassVar[QElapsedTimer.ClockType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __and__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __rand__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __ror__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __sub__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
        def __xor__(self, other: typing.SupportsInt) -> QElapsedTimer.ClockType: ...
    MachAbsoluteTime: ClassVar[QElapsedTimer.ClockType] = ...
    MonotonicClock: ClassVar[QElapsedTimer.ClockType] = ...
    PerformanceCounter: ClassVar[QElapsedTimer.ClockType] = ...
    SystemTime: ClassVar[QElapsedTimer.ClockType] = ...
    TickCounter: ClassVar[QElapsedTimer.ClockType] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QElapsedTimer: QElapsedTimer) -> None: ...
    @classmethod
    def clockType(cls) -> QElapsedTimer.ClockType: ...
    def elapsed(self) -> int: ...
    def hasExpired(self, timeout: int) -> bool: ...
    def invalidate(self) -> None: ...
    @classmethod
    def isMonotonic(cls) -> bool: ...
    def isValid(self) -> bool: ...
    def msecsSinceReference(self) -> int: ...
    def msecsTo(self, other: QElapsedTimer) -> int: ...
    def nsecsElapsed(self) -> int: ...
    def restart(self) -> int: ...
    def secsTo(self, other: QElapsedTimer) -> int: ...
    def start(self) -> None: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QEvent(shiboken2.Object):
    class Type:
        AcceptDropsChange: ClassVar[QEvent.Type] = ...
        ActionAdded: ClassVar[QEvent.Type] = ...
        ActionChanged: ClassVar[QEvent.Type] = ...
        ActionRemoved: ClassVar[QEvent.Type] = ...
        ActivateControl: ClassVar[QEvent.Type] = ...
        ActivationChange: ClassVar[QEvent.Type] = ...
        ApplicationActivate: ClassVar[QEvent.Type] = ...
        ApplicationActivated: ClassVar[QEvent.Type] = ...
        ApplicationDeactivate: ClassVar[QEvent.Type] = ...
        ApplicationDeactivated: ClassVar[QEvent.Type] = ...
        ApplicationFontChange: ClassVar[QEvent.Type] = ...
        ApplicationLayoutDirectionChange: ClassVar[QEvent.Type] = ...
        ApplicationPaletteChange: ClassVar[QEvent.Type] = ...
        ApplicationStateChange: ClassVar[QEvent.Type] = ...
        ApplicationWindowIconChange: ClassVar[QEvent.Type] = ...
        ChildAdded: ClassVar[QEvent.Type] = ...
        ChildPolished: ClassVar[QEvent.Type] = ...
        ChildRemoved: ClassVar[QEvent.Type] = ...
        Clipboard: ClassVar[QEvent.Type] = ...
        Close: ClassVar[QEvent.Type] = ...
        CloseSoftwareInputPanel: ClassVar[QEvent.Type] = ...
        ContentsRectChange: ClassVar[QEvent.Type] = ...
        ContextMenu: ClassVar[QEvent.Type] = ...
        Create: ClassVar[QEvent.Type] = ...
        CursorChange: ClassVar[QEvent.Type] = ...
        DeactivateControl: ClassVar[QEvent.Type] = ...
        DeferredDelete: ClassVar[QEvent.Type] = ...
        Destroy: ClassVar[QEvent.Type] = ...
        DragEnter: ClassVar[QEvent.Type] = ...
        DragLeave: ClassVar[QEvent.Type] = ...
        DragMove: ClassVar[QEvent.Type] = ...
        DragResponse: ClassVar[QEvent.Type] = ...
        Drop: ClassVar[QEvent.Type] = ...
        DynamicPropertyChange: ClassVar[QEvent.Type] = ...
        EmbeddingControl: ClassVar[QEvent.Type] = ...
        EnabledChange: ClassVar[QEvent.Type] = ...
        Enter: ClassVar[QEvent.Type] = ...
        EnterWhatsThisMode: ClassVar[QEvent.Type] = ...
        Expose: ClassVar[QEvent.Type] = ...
        FileOpen: ClassVar[QEvent.Type] = ...
        FocusAboutToChange: ClassVar[QEvent.Type] = ...
        FocusIn: ClassVar[QEvent.Type] = ...
        FocusOut: ClassVar[QEvent.Type] = ...
        FontChange: ClassVar[QEvent.Type] = ...
        FutureCallOut: ClassVar[QEvent.Type] = ...
        Gesture: ClassVar[QEvent.Type] = ...
        GestureOverride: ClassVar[QEvent.Type] = ...
        GrabKeyboard: ClassVar[QEvent.Type] = ...
        GrabMouse: ClassVar[QEvent.Type] = ...
        GraphicsSceneContextMenu: ClassVar[QEvent.Type] = ...
        GraphicsSceneDragEnter: ClassVar[QEvent.Type] = ...
        GraphicsSceneDragLeave: ClassVar[QEvent.Type] = ...
        GraphicsSceneDragMove: ClassVar[QEvent.Type] = ...
        GraphicsSceneDrop: ClassVar[QEvent.Type] = ...
        GraphicsSceneHelp: ClassVar[QEvent.Type] = ...
        GraphicsSceneHoverEnter: ClassVar[QEvent.Type] = ...
        GraphicsSceneHoverLeave: ClassVar[QEvent.Type] = ...
        GraphicsSceneHoverMove: ClassVar[QEvent.Type] = ...
        GraphicsSceneMouseDoubleClick: ClassVar[QEvent.Type] = ...
        GraphicsSceneMouseMove: ClassVar[QEvent.Type] = ...
        GraphicsSceneMousePress: ClassVar[QEvent.Type] = ...
        GraphicsSceneMouseRelease: ClassVar[QEvent.Type] = ...
        GraphicsSceneMove: ClassVar[QEvent.Type] = ...
        GraphicsSceneResize: ClassVar[QEvent.Type] = ...
        GraphicsSceneWheel: ClassVar[QEvent.Type] = ...
        HelpRequest: ClassVar[QEvent.Type] = ...
        Hide: ClassVar[QEvent.Type] = ...
        HideToParent: ClassVar[QEvent.Type] = ...
        HoverEnter: ClassVar[QEvent.Type] = ...
        HoverLeave: ClassVar[QEvent.Type] = ...
        HoverMove: ClassVar[QEvent.Type] = ...
        IconDrag: ClassVar[QEvent.Type] = ...
        IconTextChange: ClassVar[QEvent.Type] = ...
        InputMethod: ClassVar[QEvent.Type] = ...
        InputMethodQuery: ClassVar[QEvent.Type] = ...
        KeyPress: ClassVar[QEvent.Type] = ...
        KeyRelease: ClassVar[QEvent.Type] = ...
        KeyboardLayoutChange: ClassVar[QEvent.Type] = ...
        LanguageChange: ClassVar[QEvent.Type] = ...
        LayoutDirectionChange: ClassVar[QEvent.Type] = ...
        LayoutRequest: ClassVar[QEvent.Type] = ...
        Leave: ClassVar[QEvent.Type] = ...
        LeaveWhatsThisMode: ClassVar[QEvent.Type] = ...
        LocaleChange: ClassVar[QEvent.Type] = ...
        MacGLClearDrawable: ClassVar[QEvent.Type] = ...
        MacGLWindowChange: ClassVar[QEvent.Type] = ...
        MacSizeChange: ClassVar[QEvent.Type] = ...
        MaxUser: ClassVar[QEvent.Type] = ...
        MetaCall: ClassVar[QEvent.Type] = ...
        ModifiedChange: ClassVar[QEvent.Type] = ...
        MouseButtonDblClick: ClassVar[QEvent.Type] = ...
        MouseButtonPress: ClassVar[QEvent.Type] = ...
        MouseButtonRelease: ClassVar[QEvent.Type] = ...
        MouseMove: ClassVar[QEvent.Type] = ...
        MouseTrackingChange: ClassVar[QEvent.Type] = ...
        Move: ClassVar[QEvent.Type] = ...
        NativeGesture: ClassVar[QEvent.Type] = ...
        NetworkReplyUpdated: ClassVar[QEvent.Type] = ...
        NonClientAreaMouseButtonDblClick: ClassVar[QEvent.Type] = ...
        NonClientAreaMouseButtonPress: ClassVar[QEvent.Type] = ...
        NonClientAreaMouseButtonRelease: ClassVar[QEvent.Type] = ...
        NonClientAreaMouseMove: ClassVar[QEvent.Type] = ...
        None_: ClassVar[QEvent.Type] = ...
        OkRequest: ClassVar[QEvent.Type] = ...
        OrientationChange: ClassVar[QEvent.Type] = ...
        Paint: ClassVar[QEvent.Type] = ...
        PaletteChange: ClassVar[QEvent.Type] = ...
        ParentAboutToChange: ClassVar[QEvent.Type] = ...
        ParentChange: ClassVar[QEvent.Type] = ...
        PlatformPanel: ClassVar[QEvent.Type] = ...
        PlatformSurface: ClassVar[QEvent.Type] = ...
        Pointer: ClassVar[QEvent.Type] = ...
        Polish: ClassVar[QEvent.Type] = ...
        PolishRequest: ClassVar[QEvent.Type] = ...
        QueryWhatsThis: ClassVar[QEvent.Type] = ...
        Quit: ClassVar[QEvent.Type] = ...
        ReadOnlyChange: ClassVar[QEvent.Type] = ...
        RequestSoftwareInputPanel: ClassVar[QEvent.Type] = ...
        Resize: ClassVar[QEvent.Type] = ...
        ScreenChangeInternal: ClassVar[QEvent.Type] = ...
        Scroll: ClassVar[QEvent.Type] = ...
        ScrollPrepare: ClassVar[QEvent.Type] = ...
        Shortcut: ClassVar[QEvent.Type] = ...
        ShortcutOverride: ClassVar[QEvent.Type] = ...
        Show: ClassVar[QEvent.Type] = ...
        ShowToParent: ClassVar[QEvent.Type] = ...
        ShowWindowRequest: ClassVar[QEvent.Type] = ...
        SockAct: ClassVar[QEvent.Type] = ...
        SockClose: ClassVar[QEvent.Type] = ...
        Speech: ClassVar[QEvent.Type] = ...
        StateMachineSignal: ClassVar[QEvent.Type] = ...
        StateMachineWrapped: ClassVar[QEvent.Type] = ...
        StatusTip: ClassVar[QEvent.Type] = ...
        Style: ClassVar[QEvent.Type] = ...
        StyleAnimationUpdate: ClassVar[QEvent.Type] = ...
        StyleChange: ClassVar[QEvent.Type] = ...
        TabletEnterProximity: ClassVar[QEvent.Type] = ...
        TabletLeaveProximity: ClassVar[QEvent.Type] = ...
        TabletMove: ClassVar[QEvent.Type] = ...
        TabletPress: ClassVar[QEvent.Type] = ...
        TabletRelease: ClassVar[QEvent.Type] = ...
        TabletTrackingChange: ClassVar[QEvent.Type] = ...
        ThemeChange: ClassVar[QEvent.Type] = ...
        ThreadChange: ClassVar[QEvent.Type] = ...
        Timer: ClassVar[QEvent.Type] = ...
        ToolBarChange: ClassVar[QEvent.Type] = ...
        ToolTip: ClassVar[QEvent.Type] = ...
        ToolTipChange: ClassVar[QEvent.Type] = ...
        TouchBegin: ClassVar[QEvent.Type] = ...
        TouchCancel: ClassVar[QEvent.Type] = ...
        TouchEnd: ClassVar[QEvent.Type] = ...
        TouchUpdate: ClassVar[QEvent.Type] = ...
        UngrabKeyboard: ClassVar[QEvent.Type] = ...
        UngrabMouse: ClassVar[QEvent.Type] = ...
        UpdateLater: ClassVar[QEvent.Type] = ...
        UpdateRequest: ClassVar[QEvent.Type] = ...
        User: ClassVar[QEvent.Type] = ...
        WhatsThis: ClassVar[QEvent.Type] = ...
        WhatsThisClicked: ClassVar[QEvent.Type] = ...
        Wheel: ClassVar[QEvent.Type] = ...
        WinEventAct: ClassVar[QEvent.Type] = ...
        WinIdChange: ClassVar[QEvent.Type] = ...
        WindowActivate: ClassVar[QEvent.Type] = ...
        WindowBlocked: ClassVar[QEvent.Type] = ...
        WindowChangeInternal: ClassVar[QEvent.Type] = ...
        WindowDeactivate: ClassVar[QEvent.Type] = ...
        WindowIconChange: ClassVar[QEvent.Type] = ...
        WindowStateChange: ClassVar[QEvent.Type] = ...
        WindowTitleChange: ClassVar[QEvent.Type] = ...
        WindowUnblocked: ClassVar[QEvent.Type] = ...
        ZOrderChange: ClassVar[QEvent.Type] = ...
        ZeroTimerEvent: ClassVar[QEvent.Type] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __and__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __rand__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __rmul__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __ror__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __rsub__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __rxor__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __sub__(self, other: typing.SupportsInt) -> QEvent.Type: ...
        def __xor__(self, other: typing.SupportsInt) -> QEvent.Type: ...
    AcceptDropsChange: ClassVar[QEvent.Type] = ...
    ActionAdded: ClassVar[QEvent.Type] = ...
    ActionChanged: ClassVar[QEvent.Type] = ...
    ActionRemoved: ClassVar[QEvent.Type] = ...
    ActivateControl: ClassVar[QEvent.Type] = ...
    ActivationChange: ClassVar[QEvent.Type] = ...
    ApplicationActivate: ClassVar[QEvent.Type] = ...
    ApplicationActivated: ClassVar[QEvent.Type] = ...
    ApplicationDeactivate: ClassVar[QEvent.Type] = ...
    ApplicationDeactivated: ClassVar[QEvent.Type] = ...
    ApplicationFontChange: ClassVar[QEvent.Type] = ...
    ApplicationLayoutDirectionChange: ClassVar[QEvent.Type] = ...
    ApplicationPaletteChange: ClassVar[QEvent.Type] = ...
    ApplicationStateChange: ClassVar[QEvent.Type] = ...
    ApplicationWindowIconChange: ClassVar[QEvent.Type] = ...
    ChildAdded: ClassVar[QEvent.Type] = ...
    ChildPolished: ClassVar[QEvent.Type] = ...
    ChildRemoved: ClassVar[QEvent.Type] = ...
    Clipboard: ClassVar[QEvent.Type] = ...
    Close: ClassVar[QEvent.Type] = ...
    CloseSoftwareInputPanel: ClassVar[QEvent.Type] = ...
    ContentsRectChange: ClassVar[QEvent.Type] = ...
    ContextMenu: ClassVar[QEvent.Type] = ...
    Create: ClassVar[QEvent.Type] = ...
    CursorChange: ClassVar[QEvent.Type] = ...
    DeactivateControl: ClassVar[QEvent.Type] = ...
    DeferredDelete: ClassVar[QEvent.Type] = ...
    Destroy: ClassVar[QEvent.Type] = ...
    DragEnter: ClassVar[QEvent.Type] = ...
    DragLeave: ClassVar[QEvent.Type] = ...
    DragMove: ClassVar[QEvent.Type] = ...
    DragResponse: ClassVar[QEvent.Type] = ...
    Drop: ClassVar[QEvent.Type] = ...
    DynamicPropertyChange: ClassVar[QEvent.Type] = ...
    EmbeddingControl: ClassVar[QEvent.Type] = ...
    EnabledChange: ClassVar[QEvent.Type] = ...
    Enter: ClassVar[QEvent.Type] = ...
    EnterWhatsThisMode: ClassVar[QEvent.Type] = ...
    Expose: ClassVar[QEvent.Type] = ...
    FileOpen: ClassVar[QEvent.Type] = ...
    FocusAboutToChange: ClassVar[QEvent.Type] = ...
    FocusIn: ClassVar[QEvent.Type] = ...
    FocusOut: ClassVar[QEvent.Type] = ...
    FontChange: ClassVar[QEvent.Type] = ...
    FutureCallOut: ClassVar[QEvent.Type] = ...
    Gesture: ClassVar[QEvent.Type] = ...
    GestureOverride: ClassVar[QEvent.Type] = ...
    GrabKeyboard: ClassVar[QEvent.Type] = ...
    GrabMouse: ClassVar[QEvent.Type] = ...
    GraphicsSceneContextMenu: ClassVar[QEvent.Type] = ...
    GraphicsSceneDragEnter: ClassVar[QEvent.Type] = ...
    GraphicsSceneDragLeave: ClassVar[QEvent.Type] = ...
    GraphicsSceneDragMove: ClassVar[QEvent.Type] = ...
    GraphicsSceneDrop: ClassVar[QEvent.Type] = ...
    GraphicsSceneHelp: ClassVar[QEvent.Type] = ...
    GraphicsSceneHoverEnter: ClassVar[QEvent.Type] = ...
    GraphicsSceneHoverLeave: ClassVar[QEvent.Type] = ...
    GraphicsSceneHoverMove: ClassVar[QEvent.Type] = ...
    GraphicsSceneMouseDoubleClick: ClassVar[QEvent.Type] = ...
    GraphicsSceneMouseMove: ClassVar[QEvent.Type] = ...
    GraphicsSceneMousePress: ClassVar[QEvent.Type] = ...
    GraphicsSceneMouseRelease: ClassVar[QEvent.Type] = ...
    GraphicsSceneMove: ClassVar[QEvent.Type] = ...
    GraphicsSceneResize: ClassVar[QEvent.Type] = ...
    GraphicsSceneWheel: ClassVar[QEvent.Type] = ...
    HelpRequest: ClassVar[QEvent.Type] = ...
    Hide: ClassVar[QEvent.Type] = ...
    HideToParent: ClassVar[QEvent.Type] = ...
    HoverEnter: ClassVar[QEvent.Type] = ...
    HoverLeave: ClassVar[QEvent.Type] = ...
    HoverMove: ClassVar[QEvent.Type] = ...
    IconDrag: ClassVar[QEvent.Type] = ...
    IconTextChange: ClassVar[QEvent.Type] = ...
    InputMethod: ClassVar[QEvent.Type] = ...
    InputMethodQuery: ClassVar[QEvent.Type] = ...
    KeyPress: ClassVar[QEvent.Type] = ...
    KeyRelease: ClassVar[QEvent.Type] = ...
    KeyboardLayoutChange: ClassVar[QEvent.Type] = ...
    LanguageChange: ClassVar[QEvent.Type] = ...
    LayoutDirectionChange: ClassVar[QEvent.Type] = ...
    LayoutRequest: ClassVar[QEvent.Type] = ...
    Leave: ClassVar[QEvent.Type] = ...
    LeaveWhatsThisMode: ClassVar[QEvent.Type] = ...
    LocaleChange: ClassVar[QEvent.Type] = ...
    MacGLClearDrawable: ClassVar[QEvent.Type] = ...
    MacGLWindowChange: ClassVar[QEvent.Type] = ...
    MacSizeChange: ClassVar[QEvent.Type] = ...
    MaxUser: ClassVar[QEvent.Type] = ...
    MetaCall: ClassVar[QEvent.Type] = ...
    ModifiedChange: ClassVar[QEvent.Type] = ...
    MouseButtonDblClick: ClassVar[QEvent.Type] = ...
    MouseButtonPress: ClassVar[QEvent.Type] = ...
    MouseButtonRelease: ClassVar[QEvent.Type] = ...
    MouseMove: ClassVar[QEvent.Type] = ...
    MouseTrackingChange: ClassVar[QEvent.Type] = ...
    Move: ClassVar[QEvent.Type] = ...
    NativeGesture: ClassVar[QEvent.Type] = ...
    NetworkReplyUpdated: ClassVar[QEvent.Type] = ...
    NonClientAreaMouseButtonDblClick: ClassVar[QEvent.Type] = ...
    NonClientAreaMouseButtonPress: ClassVar[QEvent.Type] = ...
    NonClientAreaMouseButtonRelease: ClassVar[QEvent.Type] = ...
    NonClientAreaMouseMove: ClassVar[QEvent.Type] = ...
    None_: ClassVar[QEvent.Type] = ...
    OkRequest: ClassVar[QEvent.Type] = ...
    OrientationChange: ClassVar[QEvent.Type] = ...
    Paint: ClassVar[QEvent.Type] = ...
    PaletteChange: ClassVar[QEvent.Type] = ...
    ParentAboutToChange: ClassVar[QEvent.Type] = ...
    ParentChange: ClassVar[QEvent.Type] = ...
    PlatformPanel: ClassVar[QEvent.Type] = ...
    PlatformSurface: ClassVar[QEvent.Type] = ...
    Pointer: ClassVar[QEvent.Type] = ...
    Polish: ClassVar[QEvent.Type] = ...
    PolishRequest: ClassVar[QEvent.Type] = ...
    QueryWhatsThis: ClassVar[QEvent.Type] = ...
    Quit: ClassVar[QEvent.Type] = ...
    ReadOnlyChange: ClassVar[QEvent.Type] = ...
    RequestSoftwareInputPanel: ClassVar[QEvent.Type] = ...
    Resize: ClassVar[QEvent.Type] = ...
    ScreenChangeInternal: ClassVar[QEvent.Type] = ...
    Scroll: ClassVar[QEvent.Type] = ...
    ScrollPrepare: ClassVar[QEvent.Type] = ...
    Shortcut: ClassVar[QEvent.Type] = ...
    ShortcutOverride: ClassVar[QEvent.Type] = ...
    Show: ClassVar[QEvent.Type] = ...
    ShowToParent: ClassVar[QEvent.Type] = ...
    ShowWindowRequest: ClassVar[QEvent.Type] = ...
    SockAct: ClassVar[QEvent.Type] = ...
    SockClose: ClassVar[QEvent.Type] = ...
    Speech: ClassVar[QEvent.Type] = ...
    StateMachineSignal: ClassVar[QEvent.Type] = ...
    StateMachineWrapped: ClassVar[QEvent.Type] = ...
    StatusTip: ClassVar[QEvent.Type] = ...
    Style: ClassVar[QEvent.Type] = ...
    StyleAnimationUpdate: ClassVar[QEvent.Type] = ...
    StyleChange: ClassVar[QEvent.Type] = ...
    TabletEnterProximity: ClassVar[QEvent.Type] = ...
    TabletLeaveProximity: ClassVar[QEvent.Type] = ...
    TabletMove: ClassVar[QEvent.Type] = ...
    TabletPress: ClassVar[QEvent.Type] = ...
    TabletRelease: ClassVar[QEvent.Type] = ...
    TabletTrackingChange: ClassVar[QEvent.Type] = ...
    ThemeChange: ClassVar[QEvent.Type] = ...
    ThreadChange: ClassVar[QEvent.Type] = ...
    Timer: ClassVar[QEvent.Type] = ...
    ToolBarChange: ClassVar[QEvent.Type] = ...
    ToolTip: ClassVar[QEvent.Type] = ...
    ToolTipChange: ClassVar[QEvent.Type] = ...
    TouchBegin: ClassVar[QEvent.Type] = ...
    TouchCancel: ClassVar[QEvent.Type] = ...
    TouchEnd: ClassVar[QEvent.Type] = ...
    TouchUpdate: ClassVar[QEvent.Type] = ...
    UngrabKeyboard: ClassVar[QEvent.Type] = ...
    UngrabMouse: ClassVar[QEvent.Type] = ...
    UpdateLater: ClassVar[QEvent.Type] = ...
    UpdateRequest: ClassVar[QEvent.Type] = ...
    User: ClassVar[QEvent.Type] = ...
    WhatsThis: ClassVar[QEvent.Type] = ...
    WhatsThisClicked: ClassVar[QEvent.Type] = ...
    Wheel: ClassVar[QEvent.Type] = ...
    WinEventAct: ClassVar[QEvent.Type] = ...
    WinIdChange: ClassVar[QEvent.Type] = ...
    WindowActivate: ClassVar[QEvent.Type] = ...
    WindowBlocked: ClassVar[QEvent.Type] = ...
    WindowChangeInternal: ClassVar[QEvent.Type] = ...
    WindowDeactivate: ClassVar[QEvent.Type] = ...
    WindowIconChange: ClassVar[QEvent.Type] = ...
    WindowStateChange: ClassVar[QEvent.Type] = ...
    WindowTitleChange: ClassVar[QEvent.Type] = ...
    WindowUnblocked: ClassVar[QEvent.Type] = ...
    ZOrderChange: ClassVar[QEvent.Type] = ...
    ZeroTimerEvent: ClassVar[QEvent.Type] = ...
    @overload
    def __init__(self, other: QEvent) -> None: ...
    @overload
    def __init__(self, type: QEvent.Type) -> None: ...
    def accept(self) -> None: ...
    def ignore(self) -> None: ...
    def isAccepted(self) -> bool: ...
    @classmethod
    def registerEventType(cls, hint: int = ...) -> int: ...
    def setAccepted(self, accepted: bool) -> None: ...
    def spontaneous(self) -> bool: ...
    def type(self) -> QEvent.Type: ...

class QEventLoop(QObject):
    class ProcessEventsFlag:
        AllEvents: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        DialogExec: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        EventLoopExec: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        ExcludeSocketNotifiers: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        ExcludeUserInputEvents: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        WaitForMoreEvents: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        X11ExcludeTimers: ClassVar[QEventLoop.ProcessEventsFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QEventLoop.ProcessEventsFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...

    class ProcessEventsFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QEventLoop.ProcessEventsFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QEventLoop.ProcessEventsFlags: ...
    AllEvents: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    DialogExec: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    EventLoopExec: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    ExcludeSocketNotifiers: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    ExcludeUserInputEvents: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    WaitForMoreEvents: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    X11ExcludeTimers: ClassVar[QEventLoop.ProcessEventsFlag] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def exec_(self, flags: typing.Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag] = ...) -> int: ...
    def exit(self, returnCode: int = ...) -> None: ...
    def isRunning(self) -> bool: ...
    @overload
    def processEvents(self, flags: typing.Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag], maximumTime: int) -> None: ...
    @overload
    def processEvents(self, flags: typing.Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag] = ...) -> bool: ...
    def quit(self) -> None: ...
    def wakeUp(self) -> None: ...

class QEventTransition(QAbstractTransition):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, object: QObject, type: QEvent.Type, sourceState: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., eventSource: QObject = ..., eventType: typing.Any = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., targetState: typing.Any = ..., targetStateChanged: typing.Callable = ..., targetStates: typing.Any = ..., targetStatesChanged: typing.Callable = ..., transitionType: QEventTransition.TransitionType = ..., triggered: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, sourceState: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., eventSource: QObject = ..., eventType: typing.Any = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., targetState: typing.Any = ..., targetStateChanged: typing.Callable = ..., targetStates: typing.Any = ..., targetStatesChanged: typing.Callable = ..., transitionType: QEventTransition.TransitionType = ..., triggered: typing.Callable = ...) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def eventSource(self) -> QObject: ...
    def eventTest(self, event: QEvent) -> bool: ...
    def eventType(self) -> QEvent.Type: ...
    def onTransition(self, event: QEvent) -> None: ...
    def setEventSource(self, object: QObject) -> None: ...
    def setEventType(self, type: QEvent.Type) -> None: ...

class QFactoryInterface(shiboken2.Object):
    def __init__(self) -> None: ...
    def keys(self) -> typing.List[str]: ...

class QFile(QFileDevice):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, name: str, aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, name: str, parent: typing.Optional[QObject], aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Optional[QObject], aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @classmethod
    @overload
    def copy(cls, fileName: str, newName: str) -> bool: ...
    @classmethod
    @overload
    def copy(cls, self, newName: str) -> bool: ...
    @classmethod
    @overload
    def decodeName(cls, localFileName: typing.Union[QByteArray,bytes]) -> str: ...
    @classmethod
    @overload
    def decodeName(cls, localFileName: bytes) -> str: ...
    @classmethod
    def encodeName(cls, fileName: str) -> QByteArray: ...
    @classmethod
    @overload
    def exists(cls, fileName: str) -> bool: ...
    @classmethod
    @overload
    def exists(cls, self) -> bool: ...
    def fileName(self) -> str: ...
    @classmethod
    @overload
    def link(cls, oldname: str, newName: str) -> bool: ...
    @classmethod
    @overload
    def link(cls, self, newName: str) -> bool: ...
    @classmethod
    @overload
    def moveToTrash(cls, fileName: str) -> typing.Tuple[bool,str]: ...
    @classmethod
    @overload
    def moveToTrash(cls, self) -> bool: ...
    @overload
    def open(self, fd: int, ioFlags: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag], handleFlags: typing.Union[QFileDevice.FileHandleFlags,QFileDevice.FileHandleFlag] = ...) -> bool: ...
    @overload
    def open(self, flags: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> bool: ...
    @classmethod
    @overload
    def permissions(cls, filename: str) -> typing.Union[QFileDevice.Permissions,QFileDevice.Permission]: ...
    @classmethod
    @overload
    def permissions(cls, self) -> typing.Union[QFileDevice.Permissions,QFileDevice.Permission]: ...
    @classmethod
    @overload
    def readLink(cls, fileName: str) -> str: ...
    @classmethod
    @overload
    def readLink(cls, self) -> str: ...
    @classmethod
    @overload
    def remove(cls, fileName: str) -> bool: ...
    @classmethod
    @overload
    def remove(cls, self) -> bool: ...
    @classmethod
    @overload
    def rename(cls, oldName: str, newName: str) -> bool: ...
    @classmethod
    @overload
    def rename(cls, self, newName: str) -> bool: ...
    @classmethod
    @overload
    def resize(cls, filename: str, sz: int) -> bool: ...
    @classmethod
    @overload
    def resize(cls, self, sz: int) -> bool: ...
    def setFileName(self, name: str) -> None: ...
    @classmethod
    @overload
    def setPermissions(cls, filename: str, permissionSpec: typing.Union[QFileDevice.Permissions,QFileDevice.Permission]) -> bool: ...
    @classmethod
    @overload
    def setPermissions(cls, self, permissionSpec: typing.Union[QFileDevice.Permissions,QFileDevice.Permission]) -> bool: ...
    def size(self) -> int: ...
    @classmethod
    @overload
    def symLinkTarget(cls, fileName: str) -> str: ...
    @classmethod
    @overload
    def symLinkTarget(cls, self) -> str: ...

class QFileDevice(QIODevice):
    class FileError:
        AbortError: ClassVar[QFileDevice.FileError] = ...
        CopyError: ClassVar[QFileDevice.FileError] = ...
        FatalError: ClassVar[QFileDevice.FileError] = ...
        NoError: ClassVar[QFileDevice.FileError] = ...
        OpenError: ClassVar[QFileDevice.FileError] = ...
        PermissionsError: ClassVar[QFileDevice.FileError] = ...
        PositionError: ClassVar[QFileDevice.FileError] = ...
        ReadError: ClassVar[QFileDevice.FileError] = ...
        RemoveError: ClassVar[QFileDevice.FileError] = ...
        RenameError: ClassVar[QFileDevice.FileError] = ...
        ResizeError: ClassVar[QFileDevice.FileError] = ...
        ResourceError: ClassVar[QFileDevice.FileError] = ...
        TimeOutError: ClassVar[QFileDevice.FileError] = ...
        UnspecifiedError: ClassVar[QFileDevice.FileError] = ...
        WriteError: ClassVar[QFileDevice.FileError] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __rmul__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __rsub__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __sub__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.FileError: ...

    class FileHandleFlag:
        AutoCloseHandle: ClassVar[QFileDevice.FileHandleFlag] = ...
        DontCloseHandle: ClassVar[QFileDevice.FileHandleFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QFileDevice.FileHandleFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...

    class FileHandleFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QFileDevice.FileHandleFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.FileHandleFlags: ...

    class FileTime:
        FileAccessTime: ClassVar[QFileDevice.FileTime] = ...
        FileBirthTime: ClassVar[QFileDevice.FileTime] = ...
        FileMetadataChangeTime: ClassVar[QFileDevice.FileTime] = ...
        FileModificationTime: ClassVar[QFileDevice.FileTime] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __rmul__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __rsub__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __sub__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.FileTime: ...

    class MemoryMapFlags:
        MapPrivateOption: ClassVar[QFileDevice.MemoryMapFlags] = ...
        NoOptions: ClassVar[QFileDevice.MemoryMapFlags] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __rmul__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __rsub__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __sub__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.MemoryMapFlags: ...

    class Permission:
        ExeGroup: ClassVar[QFileDevice.Permission] = ...
        ExeOther: ClassVar[QFileDevice.Permission] = ...
        ExeOwner: ClassVar[QFileDevice.Permission] = ...
        ExeUser: ClassVar[QFileDevice.Permission] = ...
        ReadGroup: ClassVar[QFileDevice.Permission] = ...
        ReadOther: ClassVar[QFileDevice.Permission] = ...
        ReadOwner: ClassVar[QFileDevice.Permission] = ...
        ReadUser: ClassVar[QFileDevice.Permission] = ...
        WriteGroup: ClassVar[QFileDevice.Permission] = ...
        WriteOther: ClassVar[QFileDevice.Permission] = ...
        WriteOwner: ClassVar[QFileDevice.Permission] = ...
        WriteUser: ClassVar[QFileDevice.Permission] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QFileDevice.Permission: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...

    class Permissions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QFileDevice.Permissions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __rand__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __ror__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
        def __xor__(self, other: typing.SupportsInt) -> QFileDevice.Permissions: ...
    AbortError: ClassVar[QFileDevice.FileError] = ...
    AutoCloseHandle: ClassVar[QFileDevice.FileHandleFlag] = ...
    CopyError: ClassVar[QFileDevice.FileError] = ...
    DontCloseHandle: ClassVar[QFileDevice.FileHandleFlag] = ...
    ExeGroup: ClassVar[QFileDevice.Permission] = ...
    ExeOther: ClassVar[QFileDevice.Permission] = ...
    ExeOwner: ClassVar[QFileDevice.Permission] = ...
    ExeUser: ClassVar[QFileDevice.Permission] = ...
    FatalError: ClassVar[QFileDevice.FileError] = ...
    FileAccessTime: ClassVar[QFileDevice.FileTime] = ...
    FileBirthTime: ClassVar[QFileDevice.FileTime] = ...
    FileMetadataChangeTime: ClassVar[QFileDevice.FileTime] = ...
    FileModificationTime: ClassVar[QFileDevice.FileTime] = ...
    MapPrivateOption: ClassVar[QFileDevice.MemoryMapFlags] = ...
    NoError: ClassVar[QFileDevice.FileError] = ...
    NoOptions: ClassVar[QFileDevice.MemoryMapFlags] = ...
    OpenError: ClassVar[QFileDevice.FileError] = ...
    PermissionsError: ClassVar[QFileDevice.FileError] = ...
    PositionError: ClassVar[QFileDevice.FileError] = ...
    ReadError: ClassVar[QFileDevice.FileError] = ...
    ReadGroup: ClassVar[QFileDevice.Permission] = ...
    ReadOther: ClassVar[QFileDevice.Permission] = ...
    ReadOwner: ClassVar[QFileDevice.Permission] = ...
    ReadUser: ClassVar[QFileDevice.Permission] = ...
    RemoveError: ClassVar[QFileDevice.FileError] = ...
    RenameError: ClassVar[QFileDevice.FileError] = ...
    ResizeError: ClassVar[QFileDevice.FileError] = ...
    ResourceError: ClassVar[QFileDevice.FileError] = ...
    TimeOutError: ClassVar[QFileDevice.FileError] = ...
    UnspecifiedError: ClassVar[QFileDevice.FileError] = ...
    WriteError: ClassVar[QFileDevice.FileError] = ...
    WriteGroup: ClassVar[QFileDevice.Permission] = ...
    WriteOther: ClassVar[QFileDevice.Permission] = ...
    WriteOwner: ClassVar[QFileDevice.Permission] = ...
    WriteUser: ClassVar[QFileDevice.Permission] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Optional[QObject], aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    def atEnd(self) -> bool: ...
    def close(self) -> None: ...
    def error(self) -> QFileDevice.FileError: ...
    def fileName(self) -> str: ...
    def fileTime(self, time: QFileDevice.FileTime) -> QDateTime: ...
    def flush(self) -> bool: ...
    def handle(self) -> int: ...
    def isSequential(self) -> bool: ...
    def map(self, offset: int, size: int, flags: QFileDevice.MemoryMapFlags = ...) -> bytes: ...
    def permissions(self) -> typing.Union[QFileDevice.Permissions,QFileDevice.Permission]: ...
    def pos(self) -> int: ...
    def readData(self, data: bytes, maxlen: int) -> int: ...
    def readLineData(self, data: bytes, maxlen: int) -> int: ...
    def resize(self, sz: int) -> bool: ...
    def seek(self, offset: int) -> bool: ...
    def setFileTime(self, newDate: QDateTime, fileTime: QFileDevice.FileTime) -> bool: ...
    def setPermissions(self, permissionSpec: typing.Union[QFileDevice.Permissions,QFileDevice.Permission]) -> bool: ...
    def size(self) -> int: ...
    def unmap(self, address: bytes) -> bool: ...
    def unsetError(self) -> None: ...
    def writeData(self, data: bytes, len: int) -> int: ...

class QFileInfo(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dir: QDir, file: str) -> None: ...
    @overload
    def __init__(self, file: QFile) -> None: ...
    @overload
    def __init__(self, file: str) -> None: ...
    @overload
    def __init__(self, fileinfo: QFileInfo) -> None: ...
    def absoluteDir(self) -> QDir: ...
    def absoluteFilePath(self) -> str: ...
    def absolutePath(self) -> str: ...
    def baseName(self) -> str: ...
    def birthTime(self) -> QDateTime: ...
    def bundleName(self) -> str: ...
    def caching(self) -> bool: ...
    def canonicalFilePath(self) -> str: ...
    def canonicalPath(self) -> str: ...
    def completeBaseName(self) -> str: ...
    def completeSuffix(self) -> str: ...
    def created(self) -> QDateTime: ...
    def dir(self) -> QDir: ...
    @classmethod
    @overload
    def exists(cls, file: str) -> bool: ...
    @classmethod
    @overload
    def exists(cls, self) -> bool: ...
    def fileName(self) -> str: ...
    def filePath(self) -> str: ...
    def group(self) -> str: ...
    def groupId(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def isBundle(self) -> bool: ...
    def isDir(self) -> bool: ...
    def isExecutable(self) -> bool: ...
    def isFile(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def isJunction(self) -> bool: ...
    def isNativePath(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isRelative(self) -> bool: ...
    def isRoot(self) -> bool: ...
    def isShortcut(self) -> bool: ...
    def isSymLink(self) -> bool: ...
    def isSymbolicLink(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def lastModified(self) -> QDateTime: ...
    def lastRead(self) -> QDateTime: ...
    def makeAbsolute(self) -> bool: ...
    def metadataChangeTime(self) -> QDateTime: ...
    def owner(self) -> str: ...
    def ownerId(self) -> int: ...
    def path(self) -> str: ...
    def readLink(self) -> str: ...
    def refresh(self) -> None: ...
    def setCaching(self, on: bool) -> None: ...
    @overload
    def setFile(self, dir: QDir, file: str) -> None: ...
    @overload
    def setFile(self, file: QFile) -> None: ...
    @overload
    def setFile(self, file: str) -> None: ...
    def size(self) -> int: ...
    def suffix(self) -> str: ...
    def swap(self, other: QFileInfo) -> None: ...
    def symLinkTarget(self) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QFileSelector(QObject):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def allSelectors(self) -> typing.List[str]: ...
    def extraSelectors(self) -> typing.List[str]: ...
    @overload
    def select(self, filePath: QUrl) -> QUrl: ...
    @overload
    def select(self, filePath: str) -> str: ...
    def setExtraSelectors(self, list: typing.Sequence[str]) -> None: ...

class QFileSystemWatcher(QObject):
    directoryChanged: ClassVar[Signal] = ...
    fileChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., directoryChanged: typing.Callable = ..., fileChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, paths: typing.Sequence[str], parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., directoryChanged: typing.Callable = ..., fileChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def addPath(self, file: str) -> bool: ...
    def addPaths(self, files: typing.Sequence[str]) -> typing.List[str]: ...
    def directories(self) -> typing.List[str]: ...
    def files(self) -> typing.List[str]: ...
    def removePath(self, file: str) -> bool: ...
    def removePaths(self, files: typing.Sequence[str]) -> typing.List[str]: ...

class QFinalState(QAbstractState):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QState,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., exited: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def onEntry(self, event: QEvent) -> None: ...
    def onExit(self, event: QEvent) -> None: ...

class QFutureInterfaceBase(shiboken2.Object):
    class State:
        Canceled: ClassVar[QFutureInterfaceBase.State] = ...
        Finished: ClassVar[QFutureInterfaceBase.State] = ...
        NoState: ClassVar[QFutureInterfaceBase.State] = ...
        Paused: ClassVar[QFutureInterfaceBase.State] = ...
        Running: ClassVar[QFutureInterfaceBase.State] = ...
        Started: ClassVar[QFutureInterfaceBase.State] = ...
        Throttled: ClassVar[QFutureInterfaceBase.State] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __and__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __rand__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __rmul__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __ror__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __rsub__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __rxor__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __sub__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
        def __xor__(self, other: typing.SupportsInt) -> QFutureInterfaceBase.State: ...
    Canceled: ClassVar[QFutureInterfaceBase.State] = ...
    Finished: ClassVar[QFutureInterfaceBase.State] = ...
    NoState: ClassVar[QFutureInterfaceBase.State] = ...
    Paused: ClassVar[QFutureInterfaceBase.State] = ...
    Running: ClassVar[QFutureInterfaceBase.State] = ...
    Started: ClassVar[QFutureInterfaceBase.State] = ...
    Throttled: ClassVar[QFutureInterfaceBase.State] = ...
    @overload
    def __init__(self, initialState: QFutureInterfaceBase.State = ...) -> None: ...
    @overload
    def __init__(self, other: QFutureInterfaceBase) -> None: ...
    def cancel(self) -> None: ...
    def derefT(self) -> bool: ...
    def expectedResultCount(self) -> int: ...
    def isCanceled(self) -> bool: ...
    def isFinished(self) -> bool: ...
    def isPaused(self) -> bool: ...
    def isProgressUpdateNeeded(self) -> bool: ...
    def isResultReadyAt(self, index: int) -> bool: ...
    def isRunning(self) -> bool: ...
    def isStarted(self) -> bool: ...
    def isThrottled(self) -> bool: ...
    @overload
    def mutex(self) -> QMutex: ...
    @overload
    def mutex(self, arg__1: int) -> QMutex: ...
    def progressMaximum(self) -> int: ...
    def progressMinimum(self) -> int: ...
    def progressText(self) -> str: ...
    def progressValue(self) -> int: ...
    def queryState(self, state: QFutureInterfaceBase.State) -> bool: ...
    def refT(self) -> bool: ...
    def reportCanceled(self) -> None: ...
    def reportFinished(self) -> None: ...
    def reportResultsReady(self, beginIndex: int, endIndex: int) -> None: ...
    def reportStarted(self) -> None: ...
    def resultCount(self) -> int: ...
    def setExpectedResultCount(self, resultCount: int) -> None: ...
    def setFilterMode(self, enable: bool) -> None: ...
    def setPaused(self, paused: bool) -> None: ...
    def setProgressRange(self, minimum: int, maximum: int) -> None: ...
    def setProgressValue(self, progressValue: int) -> None: ...
    def setProgressValueAndText(self, progressValue: int, progressText: str) -> None: ...
    def setRunnable(self, runnable: QRunnable) -> None: ...
    def setThreadPool(self, pool: QThreadPool) -> None: ...
    def setThrottled(self, enable: bool) -> None: ...
    def togglePaused(self) -> None: ...
    def waitForFinished(self) -> None: ...
    def waitForNextResult(self) -> bool: ...
    def waitForResult(self, resultIndex: int) -> None: ...
    def waitForResume(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QGenericArgument(shiboken2.Object):
    @overload
    def __init__(self, QGenericArgument: QGenericArgument) -> None: ...
    @overload
    def __init__(self, aName: typing.Union[bytes,None] = ..., aData: typing.Union[int,None] = ...) -> None: ...
    def data(self) -> int: ...
    def name(self) -> bytes: ...
    def __copy__(self) -> None: ...

class QGenericReturnArgument(QGenericArgument):
    @overload
    def __init__(self, QGenericReturnArgument: QGenericReturnArgument) -> None: ...
    @overload
    def __init__(self, aName: typing.Union[bytes,None] = ..., aData: typing.Union[int,None] = ...) -> None: ...
    def __copy__(self) -> None: ...

class QHistoryState(QAbstractState):
    class HistoryType:
        DeepHistory: ClassVar[QHistoryState.HistoryType] = ...
        ShallowHistory: ClassVar[QHistoryState.HistoryType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __and__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __rand__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __ror__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __sub__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
        def __xor__(self, other: typing.SupportsInt) -> QHistoryState.HistoryType: ...
    DeepHistory: ClassVar[QHistoryState.HistoryType] = ...
    ShallowHistory: ClassVar[QHistoryState.HistoryType] = ...
    defaultStateChanged: ClassVar[Signal] = ...
    defaultTransitionChanged: ClassVar[Signal] = ...
    historyTypeChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, parent: typing.Union[QState,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., defaultState: QAbstractState = ..., defaultStateChanged: typing.Callable = ..., defaultTransition: QAbstractTransition = ..., defaultTransitionChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., exited: typing.Callable = ..., historyType: QHistoryState.HistoryType = ..., historyTypeChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, type: QHistoryState.HistoryType, parent: typing.Union[QState,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., defaultState: QAbstractState = ..., defaultStateChanged: typing.Callable = ..., defaultTransition: QAbstractTransition = ..., defaultTransitionChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., exited: typing.Callable = ..., historyType: QHistoryState.HistoryType = ..., historyTypeChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def defaultState(self) -> QAbstractState: ...
    def defaultTransition(self) -> QAbstractTransition: ...
    def event(self, e: QEvent) -> bool: ...
    def historyType(self) -> QHistoryState.HistoryType: ...
    def onEntry(self, event: QEvent) -> None: ...
    def onExit(self, event: QEvent) -> None: ...
    def setDefaultState(self, state: QAbstractState) -> None: ...
    def setDefaultTransition(self, transition: QAbstractTransition) -> None: ...
    def setHistoryType(self, type: QHistoryState.HistoryType) -> None: ...

class QIODevice(QObject):
    class OpenMode:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QIODevice.OpenMode: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...

    class OpenModeFlag:
        Append: ClassVar[QIODevice.OpenModeFlag] = ...
        ExistingOnly: ClassVar[QIODevice.OpenModeFlag] = ...
        NewOnly: ClassVar[QIODevice.OpenModeFlag] = ...
        NotOpen: ClassVar[QIODevice.OpenModeFlag] = ...
        ReadOnly: ClassVar[QIODevice.OpenModeFlag] = ...
        ReadWrite: ClassVar[QIODevice.OpenModeFlag] = ...
        Text: ClassVar[QIODevice.OpenModeFlag] = ...
        Truncate: ClassVar[QIODevice.OpenModeFlag] = ...
        Unbuffered: ClassVar[QIODevice.OpenModeFlag] = ...
        WriteOnly: ClassVar[QIODevice.OpenModeFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QIODevice.OpenModeFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QIODevice.OpenMode: ...
    Append: ClassVar[QIODevice.OpenModeFlag] = ...
    ExistingOnly: ClassVar[QIODevice.OpenModeFlag] = ...
    NewOnly: ClassVar[QIODevice.OpenModeFlag] = ...
    NotOpen: ClassVar[QIODevice.OpenModeFlag] = ...
    ReadOnly: ClassVar[QIODevice.OpenModeFlag] = ...
    ReadWrite: ClassVar[QIODevice.OpenModeFlag] = ...
    Text: ClassVar[QIODevice.OpenModeFlag] = ...
    Truncate: ClassVar[QIODevice.OpenModeFlag] = ...
    Unbuffered: ClassVar[QIODevice.OpenModeFlag] = ...
    WriteOnly: ClassVar[QIODevice.OpenModeFlag] = ...
    aboutToClose: ClassVar[Signal] = ...
    bytesWritten: ClassVar[Signal] = ...
    channelBytesWritten: ClassVar[Signal] = ...
    channelReadyRead: ClassVar[Signal] = ...
    readChannelFinished: ClassVar[Signal] = ...
    readyRead: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Optional[QObject], destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def atEnd(self) -> bool: ...
    def bytesAvailable(self) -> int: ...
    def bytesToWrite(self) -> int: ...
    def canReadLine(self) -> bool: ...
    def close(self) -> None: ...
    def commitTransaction(self) -> None: ...
    def currentReadChannel(self) -> int: ...
    def currentWriteChannel(self) -> int: ...
    def errorString(self) -> str: ...
    def getChar(self, c: bytes) -> bool: ...
    def isOpen(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isSequential(self) -> bool: ...
    def isTextModeEnabled(self) -> bool: ...
    def isTransactionStarted(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def open(self, mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> bool: ...
    def openMode(self) -> typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]: ...
    def peek(self, maxlen: int) -> QByteArray: ...
    def pos(self) -> int: ...
    def putChar(self, c: int) -> bool: ...
    def read(self, maxlen: int) -> QByteArray: ...
    def readAll(self) -> QByteArray: ...
    def readChannelCount(self) -> int: ...
    def readData(self, data: bytes, maxlen: int) -> int: ...
    def readLine(self, maxlen: int = ...) -> QByteArray: ...
    def readLineData(self, data: bytes, maxlen: int) -> int: ...
    def reset(self) -> bool: ...
    def rollbackTransaction(self) -> None: ...
    def seek(self, pos: int) -> bool: ...
    def setCurrentReadChannel(self, channel: int) -> None: ...
    def setCurrentWriteChannel(self, channel: int) -> None: ...
    def setErrorString(self, errorString: str) -> None: ...
    def setOpenMode(self, openMode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> None: ...
    def setTextModeEnabled(self, enabled: bool) -> None: ...
    def size(self) -> int: ...
    def skip(self, maxSize: int) -> int: ...
    def startTransaction(self) -> None: ...
    def ungetChar(self, c: int) -> None: ...
    def waitForBytesWritten(self, msecs: int) -> bool: ...
    def waitForReadyRead(self, msecs: int) -> bool: ...
    def write(self, data: typing.Union[QByteArray,bytes]) -> int: ...
    def writeChannelCount(self) -> int: ...
    def writeData(self, data: bytes, len: int) -> int: ...

class QIdentityProxyModel(QAbstractProxyModel):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., columnsAboutToBeInserted: typing.Callable = ..., columnsAboutToBeMoved: typing.Callable = ..., columnsAboutToBeRemoved: typing.Callable = ..., columnsInserted: typing.Callable = ..., columnsMoved: typing.Callable = ..., columnsRemoved: typing.Callable = ..., dataChanged: typing.Callable = ..., destroyed: typing.Callable = ..., headerDataChanged: typing.Callable = ..., layoutAboutToBeChanged: typing.Callable = ..., layoutChanged: typing.Callable = ..., modelAboutToBeReset: typing.Callable = ..., modelReset: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., rowsAboutToBeInserted: typing.Callable = ..., rowsAboutToBeMoved: typing.Callable = ..., rowsAboutToBeRemoved: typing.Callable = ..., rowsInserted: typing.Callable = ..., rowsMoved: typing.Callable = ..., rowsRemoved: typing.Callable = ..., sourceModel: typing.Any = ..., sourceModelChanged: typing.Callable = ...) -> None: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapSelectionFromSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapSelectionToSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def match(self, start: QModelIndex, role: Qt.ItemDataRole, value: typing.Any, hits: int = ..., flags: typing.Union[Qt.MatchFlags,Qt.MatchFlag] = ...) -> typing.List[int]: ...
    def moveColumns(self, sourceParent: QModelIndex, sourceColumn: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveRows(self, sourceParent: QModelIndex, sourceRow: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def setSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...

class QItemSelection(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QItemSelection: QItemSelection) -> None: ...
    @overload
    def __init__(self, topLeft: QModelIndex, bottomRight: QModelIndex) -> None: ...
    @overload
    def append(self, t: QItemSelectionRange) -> None: ...
    @overload
    def append(self, t: typing.Sequence[QItemSelectionRange]) -> None: ...
    def at(self, i: int) -> QItemSelectionRange: ...
    def back(self) -> QItemSelectionRange: ...
    def clear(self) -> None: ...
    def constFirst(self) -> QItemSelectionRange: ...
    def constLast(self) -> QItemSelectionRange: ...
    def contains(self, index: QModelIndex) -> bool: ...
    @overload
    def count(self) -> int: ...
    @overload
    def count(self, t: QItemSelectionRange) -> int: ...
    def detachShared(self) -> None: ...
    def empty(self) -> bool: ...
    def endsWith(self, t: QItemSelectionRange) -> bool: ...
    def first(self) -> QItemSelectionRange: ...
    @classmethod
    def fromSet(cls, set: typing.Set[QItemSelectionRange]) -> typing.List[QItemSelectionRange]: ...
    @classmethod
    def fromVector(cls, vector: typing.List[QItemSelectionRange]) -> typing.List[QItemSelectionRange]: ...
    def front(self) -> QItemSelectionRange: ...
    def indexOf(self, t: QItemSelectionRange, from_: int = ...) -> int: ...
    def indexes(self) -> typing.List[QModelIndex]: ...
    def insert(self, i: int, t: QItemSelectionRange) -> None: ...
    def isEmpty(self) -> bool: ...
    def isSharedWith(self, other: typing.Sequence[QItemSelectionRange]) -> bool: ...
    def last(self) -> QItemSelectionRange: ...
    def lastIndexOf(self, t: QItemSelectionRange, from_: int = ...) -> int: ...
    def length(self) -> int: ...
    def merge(self, other: QItemSelection, command: typing.Union[QItemSelectionModel.SelectionFlags,QItemSelectionModel.SelectionFlag]) -> None: ...
    def mid(self, pos: int, length: int = ...) -> typing.List[QItemSelectionRange]: ...
    def move(self, from_: int, to: int) -> None: ...
    def pop_back(self) -> None: ...
    def pop_front(self) -> None: ...
    def prepend(self, t: QItemSelectionRange) -> None: ...
    def push_back(self, t: QItemSelectionRange) -> None: ...
    def push_front(self, t: QItemSelectionRange) -> None: ...
    def removeAll(self, t: QItemSelectionRange) -> int: ...
    def removeAt(self, i: int) -> None: ...
    def removeFirst(self) -> None: ...
    def removeLast(self) -> None: ...
    def removeOne(self, t: QItemSelectionRange) -> bool: ...
    def replace(self, i: int, t: QItemSelectionRange) -> None: ...
    def reserve(self, size: int) -> None: ...
    def select(self, topLeft: QModelIndex, bottomRight: QModelIndex) -> None: ...
    def setSharable(self, sharable: bool) -> None: ...
    def size(self) -> int: ...
    @classmethod
    def split(cls, range: QItemSelectionRange, other: QItemSelectionRange, result: QItemSelection) -> None: ...
    def startsWith(self, t: QItemSelectionRange) -> bool: ...
    @overload
    def swap(self, i: int, j: int) -> None: ...
    @overload
    def swap(self, other: typing.Sequence[QItemSelectionRange]) -> None: ...
    def swapItemsAt(self, i: int, j: int) -> None: ...
    def takeAt(self, i: int) -> QItemSelectionRange: ...
    def takeFirst(self) -> QItemSelectionRange: ...
    def takeLast(self) -> QItemSelectionRange: ...
    def toSet(self) -> typing.Set[QItemSelectionRange]: ...
    def toVector(self) -> typing.List[QItemSelectionRange]: ...
    @overload
    def value(self, i: int) -> QItemSelectionRange: ...
    @overload
    def value(self, i: int, defaultValue: QItemSelectionRange) -> QItemSelectionRange: ...
    def __add__(self, l: typing.Sequence[QItemSelectionRange]) -> typing.List[QItemSelectionRange]: ...
    def __copy__(self) -> None: ...
    def __delitem__(self, other) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index) -> Any: ...
    def __gt__(self, other: object) -> bool: ...
    @overload
    def __iadd__(self, l: typing.Sequence[QItemSelectionRange]) -> typing.List[QItemSelectionRange]: ...
    @overload
    def __iadd__(self, t: QItemSelectionRange) -> typing.List[QItemSelectionRange]: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    @overload
    def __lshift__(self, l: typing.Sequence[QItemSelectionRange]) -> typing.List[QItemSelectionRange]: ...
    @overload
    def __lshift__(self, t: QItemSelectionRange) -> typing.List[QItemSelectionRange]: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __rlshift__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> None: ...

class QItemSelectionModel(QObject):
    class SelectionFlag:
        Clear: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        ClearAndSelect: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        Columns: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        Current: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        Deselect: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        NoUpdate: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        Rows: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        Select: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        SelectCurrent: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        Toggle: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        ToggleCurrent: ClassVar[QItemSelectionModel.SelectionFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QItemSelectionModel.SelectionFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...

    class SelectionFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QItemSelectionModel.SelectionFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QItemSelectionModel.SelectionFlags: ...
    Clear: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    ClearAndSelect: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    Columns: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    Current: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    Deselect: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    NoUpdate: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    Rows: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    Select: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    SelectCurrent: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    Toggle: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    ToggleCurrent: ClassVar[QItemSelectionModel.SelectionFlag] = ...
    currentChanged: ClassVar[Signal] = ...
    currentColumnChanged: ClassVar[Signal] = ...
    currentRowChanged: ClassVar[Signal] = ...
    modelChanged: ClassVar[Signal] = ...
    selectionChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, model: QAbstractItemModel, parent: typing.Optional[QObject], currentChanged: typing.Callable = ..., currentColumnChanged: typing.Callable = ..., currentIndex: QModelIndex = ..., currentRowChanged: typing.Callable = ..., destroyed: typing.Callable = ..., hasSelection: bool = ..., modelChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., selectedIndexes: typing.List[int] = ..., selection: QItemSelection = ..., selectionChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, model: typing.Union[QAbstractItemModel,None] = ..., currentChanged: typing.Callable = ..., currentColumnChanged: typing.Callable = ..., currentIndex: QModelIndex = ..., currentRowChanged: typing.Callable = ..., destroyed: typing.Callable = ..., hasSelection: bool = ..., modelChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., selectedIndexes: typing.List[int] = ..., selection: QItemSelection = ..., selectionChanged: typing.Callable = ...) -> None: ...
    def clear(self) -> None: ...
    def clearCurrentIndex(self) -> None: ...
    def clearSelection(self) -> None: ...
    def columnIntersectsSelection(self, column: int, parent: QModelIndex = ...) -> bool: ...
    def currentIndex(self) -> QModelIndex: ...
    def emitSelectionChanged(self, newSelection: QItemSelection, oldSelection: QItemSelection) -> None: ...
    def hasSelection(self) -> bool: ...
    def isColumnSelected(self, column: int, parent: QModelIndex = ...) -> bool: ...
    def isRowSelected(self, row: int, parent: QModelIndex = ...) -> bool: ...
    def isSelected(self, index: QModelIndex) -> bool: ...
    def model(self) -> QAbstractItemModel: ...
    def reset(self) -> None: ...
    def rowIntersectsSelection(self, row: int, parent: QModelIndex = ...) -> bool: ...
    @overload
    def select(self, index: QModelIndex, command: typing.Union[QItemSelectionModel.SelectionFlags,QItemSelectionModel.SelectionFlag]) -> None: ...
    @overload
    def select(self, selection: QItemSelection, command: typing.Union[QItemSelectionModel.SelectionFlags,QItemSelectionModel.SelectionFlag]) -> None: ...
    def selectedColumns(self, row: int = ...) -> typing.List[QModelIndex]: ...
    def selectedIndexes(self) -> typing.List[QModelIndex]: ...
    def selectedRows(self, column: int = ...) -> typing.List[QModelIndex]: ...
    def selection(self) -> QItemSelection: ...
    def setCurrentIndex(self, index: QModelIndex, command: typing.Union[QItemSelectionModel.SelectionFlags,QItemSelectionModel.SelectionFlag]) -> None: ...
    def setModel(self, model: typing.Optional[QAbstractItemModel]) -> None: ...

class QItemSelectionRange(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, index: QModelIndex) -> None: ...
    @overload
    def __init__(self, other: QItemSelectionRange) -> None: ...
    @overload
    def __init__(self, topL: QModelIndex, bottomR: QModelIndex) -> None: ...
    def bottom(self) -> int: ...
    def bottomRight(self) -> QPersistentModelIndex: ...
    @overload
    def contains(self, index: QModelIndex) -> bool: ...
    @overload
    def contains(self, row: int, column: int, parentIndex: QModelIndex) -> bool: ...
    def height(self) -> int: ...
    def indexes(self) -> typing.List[QModelIndex]: ...
    def intersected(self, other: QItemSelectionRange) -> QItemSelectionRange: ...
    def intersects(self, other: QItemSelectionRange) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isValid(self) -> bool: ...
    def left(self) -> int: ...
    def model(self) -> QAbstractItemModel: ...
    def parent(self) -> QModelIndex: ...
    def right(self) -> int: ...
    def swap(self, other: QItemSelectionRange) -> None: ...
    def top(self) -> int: ...
    def topLeft(self) -> QPersistentModelIndex: ...
    def width(self) -> int: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QJsonArray(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QJsonArray) -> None: ...
    def append(self, value: QJsonValue) -> None: ...
    def at(self, i: int) -> QJsonValue: ...
    def contains(self, element: QJsonValue) -> bool: ...
    def count(self) -> int: ...
    def empty(self) -> bool: ...
    def first(self) -> QJsonValue: ...
    @classmethod
    def fromStringList(cls, list: typing.Sequence[str]) -> QJsonArray: ...
    @classmethod
    def fromVariantList(cls, list: typing.Sequence[typing.Any]) -> QJsonArray: ...
    def insert(self, i: int, value: QJsonValue) -> None: ...
    def isEmpty(self) -> bool: ...
    def last(self) -> QJsonValue: ...
    def pop_back(self) -> None: ...
    def pop_front(self) -> None: ...
    def prepend(self, value: QJsonValue) -> None: ...
    def push_back(self, t: QJsonValue) -> None: ...
    def push_front(self, t: QJsonValue) -> None: ...
    def removeAt(self, i: int) -> None: ...
    def removeFirst(self) -> None: ...
    def removeLast(self) -> None: ...
    def replace(self, i: int, value: QJsonValue) -> None: ...
    def size(self) -> int: ...
    def swap(self, other: QJsonArray) -> None: ...
    def takeAt(self, i: int) -> QJsonValue: ...
    def toVariantList(self) -> typing.List[typing.Any]: ...
    def __add__(self, v: QJsonValue) -> QJsonArray: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, v: QJsonValue) -> QJsonArray: ...
    def __le__(self, other: object) -> bool: ...
    def __lshift__(self, v: QJsonValue) -> QJsonArray: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __rlshift__(self, other) -> Any: ...

class QJsonDocument(shiboken2.Object):
    class DataValidation:
        BypassValidation: ClassVar[QJsonDocument.DataValidation] = ...
        Validate: ClassVar[QJsonDocument.DataValidation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __and__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __rand__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __rmul__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __ror__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __rsub__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __rxor__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __sub__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...
        def __xor__(self, other: typing.SupportsInt) -> QJsonDocument.DataValidation: ...

    class JsonFormat:
        Compact: ClassVar[QJsonDocument.JsonFormat] = ...
        Indented: ClassVar[QJsonDocument.JsonFormat] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __and__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __rand__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __rmul__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __ror__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __rsub__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __rxor__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __sub__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
        def __xor__(self, other: typing.SupportsInt) -> QJsonDocument.JsonFormat: ...
    BypassValidation: ClassVar[QJsonDocument.DataValidation] = ...
    Compact: ClassVar[QJsonDocument.JsonFormat] = ...
    Indented: ClassVar[QJsonDocument.JsonFormat] = ...
    Validate: ClassVar[QJsonDocument.DataValidation] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, array: QJsonArray) -> None: ...
    @overload
    def __init__(self, object: typing.Dict[str,QJsonValue]) -> None: ...
    @overload
    def __init__(self, other: QJsonDocument) -> None: ...
    def array(self) -> QJsonArray: ...
    @classmethod
    def fromBinaryData(cls, data: typing.Union[QByteArray,bytes], validation: QJsonDocument.DataValidation = ...) -> QJsonDocument: ...
    @classmethod
    def fromJson(cls, json: typing.Union[QByteArray,bytes], error: typing.Union[QJsonParseError,None] = ...) -> QJsonDocument: ...
    @classmethod
    def fromRawData(cls, data: bytes, size: int, validation: QJsonDocument.DataValidation = ...) -> QJsonDocument: ...
    @classmethod
    def fromVariant(cls, variant: typing.Any) -> QJsonDocument: ...
    def isArray(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isObject(self) -> bool: ...
    def object(self) -> typing.Dict[str,QJsonValue]: ...
    def rawData(self) -> typing.Tuple[bytes,int]: ...
    def setArray(self, array: QJsonArray) -> None: ...
    def setObject(self, object: typing.Dict[str,QJsonValue]) -> None: ...
    def swap(self, other: QJsonDocument) -> None: ...
    def toBinaryData(self) -> QByteArray: ...
    @overload
    def toJson(self) -> QByteArray: ...
    @overload
    def toJson(self, format: QJsonDocument.JsonFormat) -> QByteArray: ...
    def toVariant(self) -> typing.Any: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QJsonParseError(shiboken2.Object):
    class ParseError:
        DeepNesting: ClassVar[QJsonParseError.ParseError] = ...
        DocumentTooLarge: ClassVar[QJsonParseError.ParseError] = ...
        GarbageAtEnd: ClassVar[QJsonParseError.ParseError] = ...
        IllegalEscapeSequence: ClassVar[QJsonParseError.ParseError] = ...
        IllegalNumber: ClassVar[QJsonParseError.ParseError] = ...
        IllegalUTF8String: ClassVar[QJsonParseError.ParseError] = ...
        IllegalValue: ClassVar[QJsonParseError.ParseError] = ...
        MissingNameSeparator: ClassVar[QJsonParseError.ParseError] = ...
        MissingObject: ClassVar[QJsonParseError.ParseError] = ...
        MissingValueSeparator: ClassVar[QJsonParseError.ParseError] = ...
        NoError: ClassVar[QJsonParseError.ParseError] = ...
        TerminationByNumber: ClassVar[QJsonParseError.ParseError] = ...
        UnterminatedArray: ClassVar[QJsonParseError.ParseError] = ...
        UnterminatedObject: ClassVar[QJsonParseError.ParseError] = ...
        UnterminatedString: ClassVar[QJsonParseError.ParseError] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __and__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __rand__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __rmul__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __ror__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __rsub__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __rxor__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __sub__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
        def __xor__(self, other: typing.SupportsInt) -> QJsonParseError.ParseError: ...
    DeepNesting: ClassVar[QJsonParseError.ParseError] = ...
    DocumentTooLarge: ClassVar[QJsonParseError.ParseError] = ...
    GarbageAtEnd: ClassVar[QJsonParseError.ParseError] = ...
    IllegalEscapeSequence: ClassVar[QJsonParseError.ParseError] = ...
    IllegalNumber: ClassVar[QJsonParseError.ParseError] = ...
    IllegalUTF8String: ClassVar[QJsonParseError.ParseError] = ...
    IllegalValue: ClassVar[QJsonParseError.ParseError] = ...
    MissingNameSeparator: ClassVar[QJsonParseError.ParseError] = ...
    MissingObject: ClassVar[QJsonParseError.ParseError] = ...
    MissingValueSeparator: ClassVar[QJsonParseError.ParseError] = ...
    NoError: ClassVar[QJsonParseError.ParseError] = ...
    TerminationByNumber: ClassVar[QJsonParseError.ParseError] = ...
    UnterminatedArray: ClassVar[QJsonParseError.ParseError] = ...
    UnterminatedObject: ClassVar[QJsonParseError.ParseError] = ...
    UnterminatedString: ClassVar[QJsonParseError.ParseError] = ...
    error: Any
    offset: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QJsonParseError: QJsonParseError) -> None: ...
    def errorString(self) -> str: ...
    def __copy__(self) -> None: ...

class QJsonValue(shiboken2.Object):
    class Type:
        Array: ClassVar[QJsonValue.Type] = ...
        Bool: ClassVar[QJsonValue.Type] = ...
        Double: ClassVar[QJsonValue.Type] = ...
        Null: ClassVar[QJsonValue.Type] = ...
        Object: ClassVar[QJsonValue.Type] = ...
        String: ClassVar[QJsonValue.Type] = ...
        Undefined: ClassVar[QJsonValue.Type] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __and__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __rand__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __rmul__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __ror__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __rsub__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __rxor__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __sub__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
        def __xor__(self, other: typing.SupportsInt) -> QJsonValue.Type: ...
    Array: ClassVar[QJsonValue.Type] = ...
    Bool: ClassVar[QJsonValue.Type] = ...
    Double: ClassVar[QJsonValue.Type] = ...
    Null: ClassVar[QJsonValue.Type] = ...
    Object: ClassVar[QJsonValue.Type] = ...
    String: ClassVar[QJsonValue.Type] = ...
    Undefined: ClassVar[QJsonValue.Type] = ...
    @overload
    def __init__(self, a: QJsonArray) -> None: ...
    @overload
    def __init__(self, arg__1: QJsonValue.Type = ...) -> None: ...
    @overload
    def __init__(self, b: bool) -> None: ...
    @overload
    def __init__(self, n: float) -> None: ...
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, o: typing.Dict[str,QJsonValue]) -> None: ...
    @overload
    def __init__(self, other: QJsonValue) -> None: ...
    @overload
    def __init__(self, s: str) -> None: ...
    @overload
    def __init__(self, s: bytes) -> None: ...
    @overload
    def __init__(self, v: int) -> None: ...
    @classmethod
    def fromVariant(cls, variant: typing.Any) -> QJsonValue: ...
    def isArray(self) -> bool: ...
    def isBool(self) -> bool: ...
    def isDouble(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isObject(self) -> bool: ...
    def isString(self) -> bool: ...
    def isUndefined(self) -> bool: ...
    def swap(self, other: QJsonValue) -> None: ...
    @overload
    def toArray(self) -> QJsonArray: ...
    @overload
    def toArray(self, defaultValue: QJsonArray) -> QJsonArray: ...
    def toBool(self, defaultValue: bool = ...) -> bool: ...
    def toDouble(self, defaultValue: float = ...) -> float: ...
    def toInt(self, defaultValue: int = ...) -> int: ...
    @overload
    def toObject(self) -> typing.Dict[str,QJsonValue]: ...
    @overload
    def toObject(self, defaultValue: typing.Dict[str,QJsonValue]) -> typing.Dict[str,QJsonValue]: ...
    @overload
    def toString(self) -> str: ...
    @overload
    def toString(self, defaultValue: str) -> str: ...
    def toVariant(self) -> typing.Any: ...
    def type(self) -> QJsonValue.Type: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QLibraryInfo(shiboken2.Object):
    class LibraryLocation:
        ArchDataPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        BinariesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        DataPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        DocumentationPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        ExamplesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        HeadersPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        ImportsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        LibrariesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        LibraryExecutablesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        PluginsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        PrefixPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        Qml2ImportsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        SettingsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        TestsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        TranslationsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __and__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __rand__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __ror__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __sub__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
        def __xor__(self, other: typing.SupportsInt) -> QLibraryInfo.LibraryLocation: ...
    ArchDataPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    BinariesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    DataPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    DocumentationPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    ExamplesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    HeadersPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    ImportsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    LibrariesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    LibraryExecutablesPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    PluginsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    PrefixPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    Qml2ImportsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    SettingsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    TestsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    TranslationsPath: ClassVar[QLibraryInfo.LibraryLocation] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @classmethod
    def build(cls) -> bytes: ...
    @classmethod
    def buildDate(cls) -> QDate: ...
    @classmethod
    def isDebugBuild(cls) -> bool: ...
    @classmethod
    def licensedProducts(cls) -> str: ...
    @classmethod
    def licensee(cls) -> str: ...
    @classmethod
    def location(cls, arg__1: QLibraryInfo.LibraryLocation) -> str: ...
    @classmethod
    def platformPluginArguments(cls, platformName: str) -> typing.List[str]: ...
    @classmethod
    def version(cls) -> QVersionNumber: ...

class QLine(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QLine: QLine) -> None: ...
    @overload
    def __init__(self, pt1: QPoint, pt2: QPoint) -> None: ...
    @overload
    def __init__(self, x1: int, y1: int, x2: int, y2: int) -> None: ...
    def center(self) -> QPoint: ...
    def dx(self) -> int: ...
    def dy(self) -> int: ...
    def isNull(self) -> bool: ...
    def p1(self) -> QPoint: ...
    def p2(self) -> QPoint: ...
    def setLine(self, x1: int, y1: int, x2: int, y2: int) -> None: ...
    def setP1(self, p1: QPoint) -> None: ...
    def setP2(self, p2: QPoint) -> None: ...
    def setPoints(self, p1: QPoint, p2: QPoint) -> None: ...
    def toTuple(self) -> object: ...
    @overload
    def translate(self, dx: int, dy: int) -> None: ...
    @overload
    def translate(self, p: QPoint) -> None: ...
    @overload
    def translated(self, dx: int, dy: int) -> QLine: ...
    @overload
    def translated(self, p: QPoint) -> QLine: ...
    def x1(self) -> int: ...
    def x2(self) -> int: ...
    def y1(self) -> int: ...
    def y2(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QLineF(shiboken2.Object):
    class IntersectType:
        BoundedIntersection: ClassVar[QLineF.IntersectType] = ...
        NoIntersection: ClassVar[QLineF.IntersectType] = ...
        UnboundedIntersection: ClassVar[QLineF.IntersectType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __and__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __rand__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __ror__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __sub__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
        def __xor__(self, other: typing.SupportsInt) -> QLineF.IntersectType: ...
    BoundedIntersection: ClassVar[QLineF.IntersectType] = ...
    NoIntersection: ClassVar[QLineF.IntersectType] = ...
    UnboundedIntersection: ClassVar[QLineF.IntersectType] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QLineF: QLineF) -> None: ...
    @overload
    def __init__(self, line: QLine) -> None: ...
    @overload
    def __init__(self, pt1: QPointF, pt2: QPointF) -> None: ...
    @overload
    def __init__(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    @overload
    def angle(self) -> float: ...
    @overload
    def angle(self, l: QLineF) -> float: ...
    def angleTo(self, l: QLineF) -> float: ...
    def center(self) -> QPointF: ...
    def dx(self) -> float: ...
    def dy(self) -> float: ...
    @classmethod
    def fromPolar(cls, length: float, angle: float) -> QLineF: ...
    def intersect(self, l: QLineF, intersectionPoint: QPointF) -> QLineF.IntersectType: ...
    def intersects(self, l: QLineF, intersectionPoint: QPointF) -> QLineF.IntersectType: ...
    def isNull(self) -> bool: ...
    def length(self) -> float: ...
    def normalVector(self) -> QLineF: ...
    def p1(self) -> QPointF: ...
    def p2(self) -> QPointF: ...
    def pointAt(self, t: float) -> QPointF: ...
    def setAngle(self, angle: float) -> None: ...
    def setLength(self, len: float) -> None: ...
    def setLine(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    def setP1(self, p1: QPointF) -> None: ...
    def setP2(self, p2: QPointF) -> None: ...
    def setPoints(self, p1: QPointF, p2: QPointF) -> None: ...
    def toLine(self) -> QLine: ...
    def toTuple(self) -> object: ...
    @overload
    def translate(self, dx: float, dy: float) -> None: ...
    @overload
    def translate(self, p: QPointF) -> None: ...
    @overload
    def translated(self, dx: float, dy: float) -> QLineF: ...
    @overload
    def translated(self, p: QPointF) -> QLineF: ...
    def unitVector(self) -> QLineF: ...
    def x1(self) -> float: ...
    def x2(self) -> float: ...
    def y1(self) -> float: ...
    def y2(self) -> float: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QLocale(shiboken2.Object):
    class Country:
        Afghanistan: ClassVar[QLocale.Country] = ...
        AlandIslands: ClassVar[QLocale.Country] = ...
        Albania: ClassVar[QLocale.Country] = ...
        Algeria: ClassVar[QLocale.Country] = ...
        AmericanSamoa: ClassVar[QLocale.Country] = ...
        Andorra: ClassVar[QLocale.Country] = ...
        Angola: ClassVar[QLocale.Country] = ...
        Anguilla: ClassVar[QLocale.Country] = ...
        Antarctica: ClassVar[QLocale.Country] = ...
        AntiguaAndBarbuda: ClassVar[QLocale.Country] = ...
        AnyCountry: ClassVar[QLocale.Country] = ...
        Argentina: ClassVar[QLocale.Country] = ...
        Armenia: ClassVar[QLocale.Country] = ...
        Aruba: ClassVar[QLocale.Country] = ...
        AscensionIsland: ClassVar[QLocale.Country] = ...
        Australia: ClassVar[QLocale.Country] = ...
        Austria: ClassVar[QLocale.Country] = ...
        Azerbaijan: ClassVar[QLocale.Country] = ...
        Bahamas: ClassVar[QLocale.Country] = ...
        Bahrain: ClassVar[QLocale.Country] = ...
        Bangladesh: ClassVar[QLocale.Country] = ...
        Barbados: ClassVar[QLocale.Country] = ...
        Belarus: ClassVar[QLocale.Country] = ...
        Belgium: ClassVar[QLocale.Country] = ...
        Belize: ClassVar[QLocale.Country] = ...
        Benin: ClassVar[QLocale.Country] = ...
        Bermuda: ClassVar[QLocale.Country] = ...
        Bhutan: ClassVar[QLocale.Country] = ...
        Bolivia: ClassVar[QLocale.Country] = ...
        Bonaire: ClassVar[QLocale.Country] = ...
        BosniaAndHerzegowina: ClassVar[QLocale.Country] = ...
        Botswana: ClassVar[QLocale.Country] = ...
        BouvetIsland: ClassVar[QLocale.Country] = ...
        Brazil: ClassVar[QLocale.Country] = ...
        BritishIndianOceanTerritory: ClassVar[QLocale.Country] = ...
        BritishVirginIslands: ClassVar[QLocale.Country] = ...
        Brunei: ClassVar[QLocale.Country] = ...
        Bulgaria: ClassVar[QLocale.Country] = ...
        BurkinaFaso: ClassVar[QLocale.Country] = ...
        Burundi: ClassVar[QLocale.Country] = ...
        Cambodia: ClassVar[QLocale.Country] = ...
        Cameroon: ClassVar[QLocale.Country] = ...
        Canada: ClassVar[QLocale.Country] = ...
        CanaryIslands: ClassVar[QLocale.Country] = ...
        CapeVerde: ClassVar[QLocale.Country] = ...
        CaymanIslands: ClassVar[QLocale.Country] = ...
        CentralAfricanRepublic: ClassVar[QLocale.Country] = ...
        CeutaAndMelilla: ClassVar[QLocale.Country] = ...
        Chad: ClassVar[QLocale.Country] = ...
        Chile: ClassVar[QLocale.Country] = ...
        China: ClassVar[QLocale.Country] = ...
        ChristmasIsland: ClassVar[QLocale.Country] = ...
        ClippertonIsland: ClassVar[QLocale.Country] = ...
        CocosIslands: ClassVar[QLocale.Country] = ...
        Colombia: ClassVar[QLocale.Country] = ...
        Comoros: ClassVar[QLocale.Country] = ...
        CongoBrazzaville: ClassVar[QLocale.Country] = ...
        CongoKinshasa: ClassVar[QLocale.Country] = ...
        CookIslands: ClassVar[QLocale.Country] = ...
        CostaRica: ClassVar[QLocale.Country] = ...
        Croatia: ClassVar[QLocale.Country] = ...
        Cuba: ClassVar[QLocale.Country] = ...
        CuraSao: ClassVar[QLocale.Country] = ...
        Cyprus: ClassVar[QLocale.Country] = ...
        CzechRepublic: ClassVar[QLocale.Country] = ...
        DemocraticRepublicOfCongo: ClassVar[QLocale.Country] = ...
        DemocraticRepublicOfKorea: ClassVar[QLocale.Country] = ...
        Denmark: ClassVar[QLocale.Country] = ...
        DiegoGarcia: ClassVar[QLocale.Country] = ...
        Djibouti: ClassVar[QLocale.Country] = ...
        Dominica: ClassVar[QLocale.Country] = ...
        DominicanRepublic: ClassVar[QLocale.Country] = ...
        EastTimor: ClassVar[QLocale.Country] = ...
        Ecuador: ClassVar[QLocale.Country] = ...
        Egypt: ClassVar[QLocale.Country] = ...
        ElSalvador: ClassVar[QLocale.Country] = ...
        EquatorialGuinea: ClassVar[QLocale.Country] = ...
        Eritrea: ClassVar[QLocale.Country] = ...
        Estonia: ClassVar[QLocale.Country] = ...
        Ethiopia: ClassVar[QLocale.Country] = ...
        Europe: ClassVar[QLocale.Country] = ...
        EuropeanUnion: ClassVar[QLocale.Country] = ...
        FalklandIslands: ClassVar[QLocale.Country] = ...
        FaroeIslands: ClassVar[QLocale.Country] = ...
        Fiji: ClassVar[QLocale.Country] = ...
        Finland: ClassVar[QLocale.Country] = ...
        France: ClassVar[QLocale.Country] = ...
        FrenchGuiana: ClassVar[QLocale.Country] = ...
        FrenchPolynesia: ClassVar[QLocale.Country] = ...
        FrenchSouthernTerritories: ClassVar[QLocale.Country] = ...
        Gabon: ClassVar[QLocale.Country] = ...
        Gambia: ClassVar[QLocale.Country] = ...
        Georgia: ClassVar[QLocale.Country] = ...
        Germany: ClassVar[QLocale.Country] = ...
        Ghana: ClassVar[QLocale.Country] = ...
        Gibraltar: ClassVar[QLocale.Country] = ...
        Greece: ClassVar[QLocale.Country] = ...
        Greenland: ClassVar[QLocale.Country] = ...
        Grenada: ClassVar[QLocale.Country] = ...
        Guadeloupe: ClassVar[QLocale.Country] = ...
        Guam: ClassVar[QLocale.Country] = ...
        Guatemala: ClassVar[QLocale.Country] = ...
        Guernsey: ClassVar[QLocale.Country] = ...
        Guinea: ClassVar[QLocale.Country] = ...
        GuineaBissau: ClassVar[QLocale.Country] = ...
        Guyana: ClassVar[QLocale.Country] = ...
        Haiti: ClassVar[QLocale.Country] = ...
        HeardAndMcDonaldIslands: ClassVar[QLocale.Country] = ...
        Honduras: ClassVar[QLocale.Country] = ...
        HongKong: ClassVar[QLocale.Country] = ...
        Hungary: ClassVar[QLocale.Country] = ...
        Iceland: ClassVar[QLocale.Country] = ...
        India: ClassVar[QLocale.Country] = ...
        Indonesia: ClassVar[QLocale.Country] = ...
        Iran: ClassVar[QLocale.Country] = ...
        Iraq: ClassVar[QLocale.Country] = ...
        Ireland: ClassVar[QLocale.Country] = ...
        IsleOfMan: ClassVar[QLocale.Country] = ...
        Israel: ClassVar[QLocale.Country] = ...
        Italy: ClassVar[QLocale.Country] = ...
        IvoryCoast: ClassVar[QLocale.Country] = ...
        Jamaica: ClassVar[QLocale.Country] = ...
        Japan: ClassVar[QLocale.Country] = ...
        Jersey: ClassVar[QLocale.Country] = ...
        Jordan: ClassVar[QLocale.Country] = ...
        Kazakhstan: ClassVar[QLocale.Country] = ...
        Kenya: ClassVar[QLocale.Country] = ...
        Kiribati: ClassVar[QLocale.Country] = ...
        Kosovo: ClassVar[QLocale.Country] = ...
        Kuwait: ClassVar[QLocale.Country] = ...
        Kyrgyzstan: ClassVar[QLocale.Country] = ...
        Laos: ClassVar[QLocale.Country] = ...
        LastCountry: ClassVar[QLocale.Country] = ...
        LatinAmerica: ClassVar[QLocale.Country] = ...
        LatinAmericaAndTheCaribbean: ClassVar[QLocale.Country] = ...
        Latvia: ClassVar[QLocale.Country] = ...
        Lebanon: ClassVar[QLocale.Country] = ...
        Lesotho: ClassVar[QLocale.Country] = ...
        Liberia: ClassVar[QLocale.Country] = ...
        Libya: ClassVar[QLocale.Country] = ...
        Liechtenstein: ClassVar[QLocale.Country] = ...
        Lithuania: ClassVar[QLocale.Country] = ...
        Luxembourg: ClassVar[QLocale.Country] = ...
        Macau: ClassVar[QLocale.Country] = ...
        Macedonia: ClassVar[QLocale.Country] = ...
        Madagascar: ClassVar[QLocale.Country] = ...
        Malawi: ClassVar[QLocale.Country] = ...
        Malaysia: ClassVar[QLocale.Country] = ...
        Maldives: ClassVar[QLocale.Country] = ...
        Mali: ClassVar[QLocale.Country] = ...
        Malta: ClassVar[QLocale.Country] = ...
        MarshallIslands: ClassVar[QLocale.Country] = ...
        Martinique: ClassVar[QLocale.Country] = ...
        Mauritania: ClassVar[QLocale.Country] = ...
        Mauritius: ClassVar[QLocale.Country] = ...
        Mayotte: ClassVar[QLocale.Country] = ...
        Mexico: ClassVar[QLocale.Country] = ...
        Micronesia: ClassVar[QLocale.Country] = ...
        Moldova: ClassVar[QLocale.Country] = ...
        Monaco: ClassVar[QLocale.Country] = ...
        Mongolia: ClassVar[QLocale.Country] = ...
        Montenegro: ClassVar[QLocale.Country] = ...
        Montserrat: ClassVar[QLocale.Country] = ...
        Morocco: ClassVar[QLocale.Country] = ...
        Mozambique: ClassVar[QLocale.Country] = ...
        Myanmar: ClassVar[QLocale.Country] = ...
        Namibia: ClassVar[QLocale.Country] = ...
        NauruCountry: ClassVar[QLocale.Country] = ...
        Nepal: ClassVar[QLocale.Country] = ...
        Netherlands: ClassVar[QLocale.Country] = ...
        NewCaledonia: ClassVar[QLocale.Country] = ...
        NewZealand: ClassVar[QLocale.Country] = ...
        Nicaragua: ClassVar[QLocale.Country] = ...
        Niger: ClassVar[QLocale.Country] = ...
        Nigeria: ClassVar[QLocale.Country] = ...
        Niue: ClassVar[QLocale.Country] = ...
        NorfolkIsland: ClassVar[QLocale.Country] = ...
        NorthKorea: ClassVar[QLocale.Country] = ...
        NorthernMarianaIslands: ClassVar[QLocale.Country] = ...
        Norway: ClassVar[QLocale.Country] = ...
        Oman: ClassVar[QLocale.Country] = ...
        OutlyingOceania: ClassVar[QLocale.Country] = ...
        Pakistan: ClassVar[QLocale.Country] = ...
        Palau: ClassVar[QLocale.Country] = ...
        PalestinianTerritories: ClassVar[QLocale.Country] = ...
        Panama: ClassVar[QLocale.Country] = ...
        PapuaNewGuinea: ClassVar[QLocale.Country] = ...
        Paraguay: ClassVar[QLocale.Country] = ...
        PeoplesRepublicOfCongo: ClassVar[QLocale.Country] = ...
        Peru: ClassVar[QLocale.Country] = ...
        Philippines: ClassVar[QLocale.Country] = ...
        Pitcairn: ClassVar[QLocale.Country] = ...
        Poland: ClassVar[QLocale.Country] = ...
        Portugal: ClassVar[QLocale.Country] = ...
        PuertoRico: ClassVar[QLocale.Country] = ...
        Qatar: ClassVar[QLocale.Country] = ...
        RepublicOfKorea: ClassVar[QLocale.Country] = ...
        Reunion: ClassVar[QLocale.Country] = ...
        Romania: ClassVar[QLocale.Country] = ...
        Russia: ClassVar[QLocale.Country] = ...
        RussianFederation: ClassVar[QLocale.Country] = ...
        Rwanda: ClassVar[QLocale.Country] = ...
        SaintBarthelemy: ClassVar[QLocale.Country] = ...
        SaintHelena: ClassVar[QLocale.Country] = ...
        SaintKittsAndNevis: ClassVar[QLocale.Country] = ...
        SaintLucia: ClassVar[QLocale.Country] = ...
        SaintMartin: ClassVar[QLocale.Country] = ...
        SaintPierreAndMiquelon: ClassVar[QLocale.Country] = ...
        SaintVincentAndTheGrenadines: ClassVar[QLocale.Country] = ...
        Samoa: ClassVar[QLocale.Country] = ...
        SanMarino: ClassVar[QLocale.Country] = ...
        SaoTomeAndPrincipe: ClassVar[QLocale.Country] = ...
        SaudiArabia: ClassVar[QLocale.Country] = ...
        Senegal: ClassVar[QLocale.Country] = ...
        Serbia: ClassVar[QLocale.Country] = ...
        Seychelles: ClassVar[QLocale.Country] = ...
        SierraLeone: ClassVar[QLocale.Country] = ...
        Singapore: ClassVar[QLocale.Country] = ...
        SintMaarten: ClassVar[QLocale.Country] = ...
        Slovakia: ClassVar[QLocale.Country] = ...
        Slovenia: ClassVar[QLocale.Country] = ...
        SolomonIslands: ClassVar[QLocale.Country] = ...
        Somalia: ClassVar[QLocale.Country] = ...
        SouthAfrica: ClassVar[QLocale.Country] = ...
        SouthGeorgiaAndTheSouthSandwichIslands: ClassVar[QLocale.Country] = ...
        SouthKorea: ClassVar[QLocale.Country] = ...
        SouthSudan: ClassVar[QLocale.Country] = ...
        Spain: ClassVar[QLocale.Country] = ...
        SriLanka: ClassVar[QLocale.Country] = ...
        Sudan: ClassVar[QLocale.Country] = ...
        Suriname: ClassVar[QLocale.Country] = ...
        SvalbardAndJanMayenIslands: ClassVar[QLocale.Country] = ...
        Swaziland: ClassVar[QLocale.Country] = ...
        Sweden: ClassVar[QLocale.Country] = ...
        Switzerland: ClassVar[QLocale.Country] = ...
        Syria: ClassVar[QLocale.Country] = ...
        SyrianArabRepublic: ClassVar[QLocale.Country] = ...
        Taiwan: ClassVar[QLocale.Country] = ...
        Tajikistan: ClassVar[QLocale.Country] = ...
        Tanzania: ClassVar[QLocale.Country] = ...
        Thailand: ClassVar[QLocale.Country] = ...
        Togo: ClassVar[QLocale.Country] = ...
        Tokelau: ClassVar[QLocale.Country] = ...
        TokelauCountry: ClassVar[QLocale.Country] = ...
        Tonga: ClassVar[QLocale.Country] = ...
        TrinidadAndTobago: ClassVar[QLocale.Country] = ...
        TristanDaCunha: ClassVar[QLocale.Country] = ...
        Tunisia: ClassVar[QLocale.Country] = ...
        Turkey: ClassVar[QLocale.Country] = ...
        Turkmenistan: ClassVar[QLocale.Country] = ...
        TurksAndCaicosIslands: ClassVar[QLocale.Country] = ...
        Tuvalu: ClassVar[QLocale.Country] = ...
        TuvaluCountry: ClassVar[QLocale.Country] = ...
        Uganda: ClassVar[QLocale.Country] = ...
        Ukraine: ClassVar[QLocale.Country] = ...
        UnitedArabEmirates: ClassVar[QLocale.Country] = ...
        UnitedKingdom: ClassVar[QLocale.Country] = ...
        UnitedStates: ClassVar[QLocale.Country] = ...
        UnitedStatesMinorOutlyingIslands: ClassVar[QLocale.Country] = ...
        UnitedStatesVirginIslands: ClassVar[QLocale.Country] = ...
        Uruguay: ClassVar[QLocale.Country] = ...
        Uzbekistan: ClassVar[QLocale.Country] = ...
        Vanuatu: ClassVar[QLocale.Country] = ...
        VaticanCityState: ClassVar[QLocale.Country] = ...
        Venezuela: ClassVar[QLocale.Country] = ...
        Vietnam: ClassVar[QLocale.Country] = ...
        WallisAndFutunaIslands: ClassVar[QLocale.Country] = ...
        WesternSahara: ClassVar[QLocale.Country] = ...
        World: ClassVar[QLocale.Country] = ...
        Yemen: ClassVar[QLocale.Country] = ...
        Zambia: ClassVar[QLocale.Country] = ...
        Zimbabwe: ClassVar[QLocale.Country] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.Country: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.Country: ...

    class CurrencySymbolFormat:
        CurrencyDisplayName: ClassVar[QLocale.CurrencySymbolFormat] = ...
        CurrencyIsoCode: ClassVar[QLocale.CurrencySymbolFormat] = ...
        CurrencySymbol: ClassVar[QLocale.CurrencySymbolFormat] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.CurrencySymbolFormat: ...

    class DataSizeFormat:
        DataSizeBase1000: ClassVar[QLocale.DataSizeFormat] = ...
        DataSizeIecFormat: ClassVar[QLocale.DataSizeFormat] = ...
        DataSizeSIFormat: ClassVar[QLocale.DataSizeFormat] = ...
        DataSizeSIQuantifiers: ClassVar[QLocale.DataSizeFormat] = ...
        DataSizeTraditionalFormat: ClassVar[QLocale.DataSizeFormat] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QLocale.DataSizeFormat: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...

    class DataSizeFormats:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QLocale.DataSizeFormats: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.DataSizeFormats: ...

    class FloatingPointPrecisionOption:
        FloatingPointShortest: ClassVar[QLocale.FloatingPointPrecisionOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.FloatingPointPrecisionOption: ...

    class FormatType:
        LongFormat: ClassVar[QLocale.FormatType] = ...
        NarrowFormat: ClassVar[QLocale.FormatType] = ...
        ShortFormat: ClassVar[QLocale.FormatType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.FormatType: ...

    class Language:
        Abkhazian: ClassVar[QLocale.Language] = ...
        Afan: ClassVar[QLocale.Language] = ...
        Afar: ClassVar[QLocale.Language] = ...
        Afrikaans: ClassVar[QLocale.Language] = ...
        Aghem: ClassVar[QLocale.Language] = ...
        Ahom: ClassVar[QLocale.Language] = ...
        Akan: ClassVar[QLocale.Language] = ...
        Akkadian: ClassVar[QLocale.Language] = ...
        Akoose: ClassVar[QLocale.Language] = ...
        Albanian: ClassVar[QLocale.Language] = ...
        AmericanSignLanguage: ClassVar[QLocale.Language] = ...
        Amharic: ClassVar[QLocale.Language] = ...
        AncientEgyptian: ClassVar[QLocale.Language] = ...
        AncientGreek: ClassVar[QLocale.Language] = ...
        AncientNorthArabian: ClassVar[QLocale.Language] = ...
        AnyLanguage: ClassVar[QLocale.Language] = ...
        Arabic: ClassVar[QLocale.Language] = ...
        Aragonese: ClassVar[QLocale.Language] = ...
        Aramaic: ClassVar[QLocale.Language] = ...
        ArdhamagadhiPrakrit: ClassVar[QLocale.Language] = ...
        Armenian: ClassVar[QLocale.Language] = ...
        Assamese: ClassVar[QLocale.Language] = ...
        Asturian: ClassVar[QLocale.Language] = ...
        Asu: ClassVar[QLocale.Language] = ...
        Atsam: ClassVar[QLocale.Language] = ...
        Avaric: ClassVar[QLocale.Language] = ...
        Avestan: ClassVar[QLocale.Language] = ...
        Aymara: ClassVar[QLocale.Language] = ...
        Azerbaijani: ClassVar[QLocale.Language] = ...
        Bafia: ClassVar[QLocale.Language] = ...
        Balinese: ClassVar[QLocale.Language] = ...
        Bambara: ClassVar[QLocale.Language] = ...
        Bamun: ClassVar[QLocale.Language] = ...
        Basaa: ClassVar[QLocale.Language] = ...
        Bashkir: ClassVar[QLocale.Language] = ...
        Basque: ClassVar[QLocale.Language] = ...
        Bassa: ClassVar[QLocale.Language] = ...
        BatakToba: ClassVar[QLocale.Language] = ...
        Belarusian: ClassVar[QLocale.Language] = ...
        Bemba: ClassVar[QLocale.Language] = ...
        Bena: ClassVar[QLocale.Language] = ...
        Bengali: ClassVar[QLocale.Language] = ...
        Bhojpuri: ClassVar[QLocale.Language] = ...
        Bhutani: ClassVar[QLocale.Language] = ...
        Bihari: ClassVar[QLocale.Language] = ...
        Bislama: ClassVar[QLocale.Language] = ...
        Blin: ClassVar[QLocale.Language] = ...
        Bodo: ClassVar[QLocale.Language] = ...
        Bosnian: ClassVar[QLocale.Language] = ...
        Breton: ClassVar[QLocale.Language] = ...
        Buginese: ClassVar[QLocale.Language] = ...
        Buhid: ClassVar[QLocale.Language] = ...
        Bulgarian: ClassVar[QLocale.Language] = ...
        Burmese: ClassVar[QLocale.Language] = ...
        Byelorussian: ClassVar[QLocale.Language] = ...
        C: ClassVar[QLocale.Language] = ...
        Cambodian: ClassVar[QLocale.Language] = ...
        Cantonese: ClassVar[QLocale.Language] = ...
        Carian: ClassVar[QLocale.Language] = ...
        Catalan: ClassVar[QLocale.Language] = ...
        Cebuano: ClassVar[QLocale.Language] = ...
        CentralKurdish: ClassVar[QLocale.Language] = ...
        CentralMoroccoTamazight: ClassVar[QLocale.Language] = ...
        Chakma: ClassVar[QLocale.Language] = ...
        Chamorro: ClassVar[QLocale.Language] = ...
        Chechen: ClassVar[QLocale.Language] = ...
        Cherokee: ClassVar[QLocale.Language] = ...
        Chewa: ClassVar[QLocale.Language] = ...
        Chickasaw: ClassVar[QLocale.Language] = ...
        Chiga: ClassVar[QLocale.Language] = ...
        Chinese: ClassVar[QLocale.Language] = ...
        Church: ClassVar[QLocale.Language] = ...
        Chuvash: ClassVar[QLocale.Language] = ...
        ClassicalMandaic: ClassVar[QLocale.Language] = ...
        Colognian: ClassVar[QLocale.Language] = ...
        CongoSwahili: ClassVar[QLocale.Language] = ...
        Coptic: ClassVar[QLocale.Language] = ...
        Cornish: ClassVar[QLocale.Language] = ...
        Corsican: ClassVar[QLocale.Language] = ...
        Cree: ClassVar[QLocale.Language] = ...
        Croatian: ClassVar[QLocale.Language] = ...
        Czech: ClassVar[QLocale.Language] = ...
        Danish: ClassVar[QLocale.Language] = ...
        Divehi: ClassVar[QLocale.Language] = ...
        Dogri: ClassVar[QLocale.Language] = ...
        Duala: ClassVar[QLocale.Language] = ...
        Dutch: ClassVar[QLocale.Language] = ...
        Dzongkha: ClassVar[QLocale.Language] = ...
        EasternCham: ClassVar[QLocale.Language] = ...
        EasternKayah: ClassVar[QLocale.Language] = ...
        Embu: ClassVar[QLocale.Language] = ...
        English: ClassVar[QLocale.Language] = ...
        Erzya: ClassVar[QLocale.Language] = ...
        Esperanto: ClassVar[QLocale.Language] = ...
        Estonian: ClassVar[QLocale.Language] = ...
        Etruscan: ClassVar[QLocale.Language] = ...
        Ewe: ClassVar[QLocale.Language] = ...
        Ewondo: ClassVar[QLocale.Language] = ...
        Faroese: ClassVar[QLocale.Language] = ...
        Fijian: ClassVar[QLocale.Language] = ...
        Filipino: ClassVar[QLocale.Language] = ...
        Finnish: ClassVar[QLocale.Language] = ...
        French: ClassVar[QLocale.Language] = ...
        Frisian: ClassVar[QLocale.Language] = ...
        Friulian: ClassVar[QLocale.Language] = ...
        Fulah: ClassVar[QLocale.Language] = ...
        Ga: ClassVar[QLocale.Language] = ...
        Gaelic: ClassVar[QLocale.Language] = ...
        Galician: ClassVar[QLocale.Language] = ...
        Ganda: ClassVar[QLocale.Language] = ...
        Geez: ClassVar[QLocale.Language] = ...
        Georgian: ClassVar[QLocale.Language] = ...
        German: ClassVar[QLocale.Language] = ...
        Gothic: ClassVar[QLocale.Language] = ...
        Greek: ClassVar[QLocale.Language] = ...
        Greenlandic: ClassVar[QLocale.Language] = ...
        Guarani: ClassVar[QLocale.Language] = ...
        Gujarati: ClassVar[QLocale.Language] = ...
        Gusii: ClassVar[QLocale.Language] = ...
        Haitian: ClassVar[QLocale.Language] = ...
        Hanunoo: ClassVar[QLocale.Language] = ...
        Hausa: ClassVar[QLocale.Language] = ...
        Hawaiian: ClassVar[QLocale.Language] = ...
        Hebrew: ClassVar[QLocale.Language] = ...
        Herero: ClassVar[QLocale.Language] = ...
        HieroglyphicLuwian: ClassVar[QLocale.Language] = ...
        Hindi: ClassVar[QLocale.Language] = ...
        HiriMotu: ClassVar[QLocale.Language] = ...
        HmongNjua: ClassVar[QLocale.Language] = ...
        Ho: ClassVar[QLocale.Language] = ...
        Hungarian: ClassVar[QLocale.Language] = ...
        Icelandic: ClassVar[QLocale.Language] = ...
        Ido: ClassVar[QLocale.Language] = ...
        Igbo: ClassVar[QLocale.Language] = ...
        InariSami: ClassVar[QLocale.Language] = ...
        Indonesian: ClassVar[QLocale.Language] = ...
        Ingush: ClassVar[QLocale.Language] = ...
        Interlingua: ClassVar[QLocale.Language] = ...
        Interlingue: ClassVar[QLocale.Language] = ...
        Inuktitut: ClassVar[QLocale.Language] = ...
        Inupiak: ClassVar[QLocale.Language] = ...
        Irish: ClassVar[QLocale.Language] = ...
        Italian: ClassVar[QLocale.Language] = ...
        Japanese: ClassVar[QLocale.Language] = ...
        Javanese: ClassVar[QLocale.Language] = ...
        Jju: ClassVar[QLocale.Language] = ...
        JolaFonyi: ClassVar[QLocale.Language] = ...
        Kabuverdianu: ClassVar[QLocale.Language] = ...
        Kabyle: ClassVar[QLocale.Language] = ...
        Kako: ClassVar[QLocale.Language] = ...
        Kalenjin: ClassVar[QLocale.Language] = ...
        Kamba: ClassVar[QLocale.Language] = ...
        Kannada: ClassVar[QLocale.Language] = ...
        Kanuri: ClassVar[QLocale.Language] = ...
        Kashmiri: ClassVar[QLocale.Language] = ...
        Kazakh: ClassVar[QLocale.Language] = ...
        Kenyang: ClassVar[QLocale.Language] = ...
        Khmer: ClassVar[QLocale.Language] = ...
        Kiche: ClassVar[QLocale.Language] = ...
        Kikuyu: ClassVar[QLocale.Language] = ...
        Kinyarwanda: ClassVar[QLocale.Language] = ...
        Kirghiz: ClassVar[QLocale.Language] = ...
        Komi: ClassVar[QLocale.Language] = ...
        Kongo: ClassVar[QLocale.Language] = ...
        Konkani: ClassVar[QLocale.Language] = ...
        Korean: ClassVar[QLocale.Language] = ...
        Koro: ClassVar[QLocale.Language] = ...
        KoyraChiini: ClassVar[QLocale.Language] = ...
        KoyraboroSenni: ClassVar[QLocale.Language] = ...
        Kpelle: ClassVar[QLocale.Language] = ...
        Kurdish: ClassVar[QLocale.Language] = ...
        Kurundi: ClassVar[QLocale.Language] = ...
        Kwanyama: ClassVar[QLocale.Language] = ...
        Kwasio: ClassVar[QLocale.Language] = ...
        Lakota: ClassVar[QLocale.Language] = ...
        Langi: ClassVar[QLocale.Language] = ...
        Lao: ClassVar[QLocale.Language] = ...
        LargeFloweryMiao: ClassVar[QLocale.Language] = ...
        LastLanguage: ClassVar[QLocale.Language] = ...
        Latin: ClassVar[QLocale.Language] = ...
        Latvian: ClassVar[QLocale.Language] = ...
        Lepcha: ClassVar[QLocale.Language] = ...
        Lezghian: ClassVar[QLocale.Language] = ...
        Limbu: ClassVar[QLocale.Language] = ...
        Limburgish: ClassVar[QLocale.Language] = ...
        LinearA: ClassVar[QLocale.Language] = ...
        Lingala: ClassVar[QLocale.Language] = ...
        Lisu: ClassVar[QLocale.Language] = ...
        LiteraryChinese: ClassVar[QLocale.Language] = ...
        Lithuanian: ClassVar[QLocale.Language] = ...
        Lojban: ClassVar[QLocale.Language] = ...
        LowGerman: ClassVar[QLocale.Language] = ...
        LowerSorbian: ClassVar[QLocale.Language] = ...
        Lu: ClassVar[QLocale.Language] = ...
        LubaKatanga: ClassVar[QLocale.Language] = ...
        LuleSami: ClassVar[QLocale.Language] = ...
        Luo: ClassVar[QLocale.Language] = ...
        Luxembourgish: ClassVar[QLocale.Language] = ...
        Luyia: ClassVar[QLocale.Language] = ...
        Lycian: ClassVar[QLocale.Language] = ...
        Lydian: ClassVar[QLocale.Language] = ...
        Macedonian: ClassVar[QLocale.Language] = ...
        Machame: ClassVar[QLocale.Language] = ...
        Maithili: ClassVar[QLocale.Language] = ...
        MakhuwaMeetto: ClassVar[QLocale.Language] = ...
        Makonde: ClassVar[QLocale.Language] = ...
        Malagasy: ClassVar[QLocale.Language] = ...
        Malay: ClassVar[QLocale.Language] = ...
        Malayalam: ClassVar[QLocale.Language] = ...
        Maltese: ClassVar[QLocale.Language] = ...
        Mandingo: ClassVar[QLocale.Language] = ...
        ManichaeanMiddlePersian: ClassVar[QLocale.Language] = ...
        Manipuri: ClassVar[QLocale.Language] = ...
        Manx: ClassVar[QLocale.Language] = ...
        Maori: ClassVar[QLocale.Language] = ...
        Mapuche: ClassVar[QLocale.Language] = ...
        Marathi: ClassVar[QLocale.Language] = ...
        Marshallese: ClassVar[QLocale.Language] = ...
        Masai: ClassVar[QLocale.Language] = ...
        Mazanderani: ClassVar[QLocale.Language] = ...
        Mende: ClassVar[QLocale.Language] = ...
        Meroitic: ClassVar[QLocale.Language] = ...
        Meru: ClassVar[QLocale.Language] = ...
        Meta: ClassVar[QLocale.Language] = ...
        Mohawk: ClassVar[QLocale.Language] = ...
        Moldavian: ClassVar[QLocale.Language] = ...
        Mongolian: ClassVar[QLocale.Language] = ...
        Mono: ClassVar[QLocale.Language] = ...
        Morisyen: ClassVar[QLocale.Language] = ...
        Mru: ClassVar[QLocale.Language] = ...
        Mundang: ClassVar[QLocale.Language] = ...
        Muscogee: ClassVar[QLocale.Language] = ...
        Nama: ClassVar[QLocale.Language] = ...
        NauruLanguage: ClassVar[QLocale.Language] = ...
        Navaho: ClassVar[QLocale.Language] = ...
        Ndonga: ClassVar[QLocale.Language] = ...
        Nepali: ClassVar[QLocale.Language] = ...
        Newari: ClassVar[QLocale.Language] = ...
        Ngiemboon: ClassVar[QLocale.Language] = ...
        Ngomba: ClassVar[QLocale.Language] = ...
        NigerianPidgin: ClassVar[QLocale.Language] = ...
        Nko: ClassVar[QLocale.Language] = ...
        NorthNdebele: ClassVar[QLocale.Language] = ...
        NorthernLuri: ClassVar[QLocale.Language] = ...
        NorthernSami: ClassVar[QLocale.Language] = ...
        NorthernSotho: ClassVar[QLocale.Language] = ...
        NorthernThai: ClassVar[QLocale.Language] = ...
        Norwegian: ClassVar[QLocale.Language] = ...
        NorwegianBokmal: ClassVar[QLocale.Language] = ...
        NorwegianNynorsk: ClassVar[QLocale.Language] = ...
        Nuer: ClassVar[QLocale.Language] = ...
        Nyanja: ClassVar[QLocale.Language] = ...
        Nyankole: ClassVar[QLocale.Language] = ...
        Occitan: ClassVar[QLocale.Language] = ...
        Ojibwa: ClassVar[QLocale.Language] = ...
        OldIrish: ClassVar[QLocale.Language] = ...
        OldNorse: ClassVar[QLocale.Language] = ...
        OldPersian: ClassVar[QLocale.Language] = ...
        OldTurkish: ClassVar[QLocale.Language] = ...
        Oriya: ClassVar[QLocale.Language] = ...
        Oromo: ClassVar[QLocale.Language] = ...
        Osage: ClassVar[QLocale.Language] = ...
        Ossetic: ClassVar[QLocale.Language] = ...
        Pahlavi: ClassVar[QLocale.Language] = ...
        Palauan: ClassVar[QLocale.Language] = ...
        Pali: ClassVar[QLocale.Language] = ...
        Papiamento: ClassVar[QLocale.Language] = ...
        Parthian: ClassVar[QLocale.Language] = ...
        Pashto: ClassVar[QLocale.Language] = ...
        Persian: ClassVar[QLocale.Language] = ...
        Phoenician: ClassVar[QLocale.Language] = ...
        Polish: ClassVar[QLocale.Language] = ...
        Portuguese: ClassVar[QLocale.Language] = ...
        PrakritLanguage: ClassVar[QLocale.Language] = ...
        Prussian: ClassVar[QLocale.Language] = ...
        Punjabi: ClassVar[QLocale.Language] = ...
        Quechua: ClassVar[QLocale.Language] = ...
        Rejang: ClassVar[QLocale.Language] = ...
        RhaetoRomance: ClassVar[QLocale.Language] = ...
        Romanian: ClassVar[QLocale.Language] = ...
        Romansh: ClassVar[QLocale.Language] = ...
        Rombo: ClassVar[QLocale.Language] = ...
        Rundi: ClassVar[QLocale.Language] = ...
        Russian: ClassVar[QLocale.Language] = ...
        Rwa: ClassVar[QLocale.Language] = ...
        Sabaean: ClassVar[QLocale.Language] = ...
        Saho: ClassVar[QLocale.Language] = ...
        Sakha: ClassVar[QLocale.Language] = ...
        Samaritan: ClassVar[QLocale.Language] = ...
        Samburu: ClassVar[QLocale.Language] = ...
        Samoan: ClassVar[QLocale.Language] = ...
        Sango: ClassVar[QLocale.Language] = ...
        Sangu: ClassVar[QLocale.Language] = ...
        Sanskrit: ClassVar[QLocale.Language] = ...
        Santali: ClassVar[QLocale.Language] = ...
        Saraiki: ClassVar[QLocale.Language] = ...
        Sardinian: ClassVar[QLocale.Language] = ...
        Saurashtra: ClassVar[QLocale.Language] = ...
        Sena: ClassVar[QLocale.Language] = ...
        Serbian: ClassVar[QLocale.Language] = ...
        SerboCroatian: ClassVar[QLocale.Language] = ...
        Shambala: ClassVar[QLocale.Language] = ...
        Shona: ClassVar[QLocale.Language] = ...
        SichuanYi: ClassVar[QLocale.Language] = ...
        Sicilian: ClassVar[QLocale.Language] = ...
        Sidamo: ClassVar[QLocale.Language] = ...
        Silesian: ClassVar[QLocale.Language] = ...
        Sindhi: ClassVar[QLocale.Language] = ...
        Sinhala: ClassVar[QLocale.Language] = ...
        SkoltSami: ClassVar[QLocale.Language] = ...
        Slovak: ClassVar[QLocale.Language] = ...
        Slovenian: ClassVar[QLocale.Language] = ...
        Soga: ClassVar[QLocale.Language] = ...
        Somali: ClassVar[QLocale.Language] = ...
        Sora: ClassVar[QLocale.Language] = ...
        SouthNdebele: ClassVar[QLocale.Language] = ...
        SouthernKurdish: ClassVar[QLocale.Language] = ...
        SouthernSami: ClassVar[QLocale.Language] = ...
        SouthernSotho: ClassVar[QLocale.Language] = ...
        Spanish: ClassVar[QLocale.Language] = ...
        StandardMoroccanTamazight: ClassVar[QLocale.Language] = ...
        Sundanese: ClassVar[QLocale.Language] = ...
        Swahili: ClassVar[QLocale.Language] = ...
        Swati: ClassVar[QLocale.Language] = ...
        Swedish: ClassVar[QLocale.Language] = ...
        SwissGerman: ClassVar[QLocale.Language] = ...
        Sylheti: ClassVar[QLocale.Language] = ...
        Syriac: ClassVar[QLocale.Language] = ...
        Tachelhit: ClassVar[QLocale.Language] = ...
        Tagalog: ClassVar[QLocale.Language] = ...
        Tagbanwa: ClassVar[QLocale.Language] = ...
        Tahitian: ClassVar[QLocale.Language] = ...
        TaiDam: ClassVar[QLocale.Language] = ...
        TaiNua: ClassVar[QLocale.Language] = ...
        Taita: ClassVar[QLocale.Language] = ...
        Tajik: ClassVar[QLocale.Language] = ...
        Tamil: ClassVar[QLocale.Language] = ...
        Tangut: ClassVar[QLocale.Language] = ...
        Taroko: ClassVar[QLocale.Language] = ...
        Tasawaq: ClassVar[QLocale.Language] = ...
        Tatar: ClassVar[QLocale.Language] = ...
        TedimChin: ClassVar[QLocale.Language] = ...
        Telugu: ClassVar[QLocale.Language] = ...
        Teso: ClassVar[QLocale.Language] = ...
        Thai: ClassVar[QLocale.Language] = ...
        Tibetan: ClassVar[QLocale.Language] = ...
        Tigre: ClassVar[QLocale.Language] = ...
        Tigrinya: ClassVar[QLocale.Language] = ...
        TokPisin: ClassVar[QLocale.Language] = ...
        TokelauLanguage: ClassVar[QLocale.Language] = ...
        Tongan: ClassVar[QLocale.Language] = ...
        Tsonga: ClassVar[QLocale.Language] = ...
        Tswana: ClassVar[QLocale.Language] = ...
        Turkish: ClassVar[QLocale.Language] = ...
        Turkmen: ClassVar[QLocale.Language] = ...
        TuvaluLanguage: ClassVar[QLocale.Language] = ...
        Twi: ClassVar[QLocale.Language] = ...
        Tyap: ClassVar[QLocale.Language] = ...
        Ugaritic: ClassVar[QLocale.Language] = ...
        Uighur: ClassVar[QLocale.Language] = ...
        Uigur: ClassVar[QLocale.Language] = ...
        Ukrainian: ClassVar[QLocale.Language] = ...
        UncodedLanguages: ClassVar[QLocale.Language] = ...
        UpperSorbian: ClassVar[QLocale.Language] = ...
        Urdu: ClassVar[QLocale.Language] = ...
        Uzbek: ClassVar[QLocale.Language] = ...
        Vai: ClassVar[QLocale.Language] = ...
        Venda: ClassVar[QLocale.Language] = ...
        Vietnamese: ClassVar[QLocale.Language] = ...
        Volapuk: ClassVar[QLocale.Language] = ...
        Vunjo: ClassVar[QLocale.Language] = ...
        Walamo: ClassVar[QLocale.Language] = ...
        Walloon: ClassVar[QLocale.Language] = ...
        Walser: ClassVar[QLocale.Language] = ...
        Warlpiri: ClassVar[QLocale.Language] = ...
        Welsh: ClassVar[QLocale.Language] = ...
        WesternBalochi: ClassVar[QLocale.Language] = ...
        WesternFrisian: ClassVar[QLocale.Language] = ...
        Wolof: ClassVar[QLocale.Language] = ...
        Xhosa: ClassVar[QLocale.Language] = ...
        Yangben: ClassVar[QLocale.Language] = ...
        Yiddish: ClassVar[QLocale.Language] = ...
        Yoruba: ClassVar[QLocale.Language] = ...
        Zarma: ClassVar[QLocale.Language] = ...
        Zhuang: ClassVar[QLocale.Language] = ...
        Zulu: ClassVar[QLocale.Language] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.Language: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.Language: ...

    class MeasurementSystem:
        ImperialSystem: ClassVar[QLocale.MeasurementSystem] = ...
        ImperialUKSystem: ClassVar[QLocale.MeasurementSystem] = ...
        ImperialUSSystem: ClassVar[QLocale.MeasurementSystem] = ...
        MetricSystem: ClassVar[QLocale.MeasurementSystem] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.MeasurementSystem: ...

    class NumberOption:
        DefaultNumberOptions: ClassVar[QLocale.NumberOption] = ...
        IncludeTrailingZeroesAfterDot: ClassVar[QLocale.NumberOption] = ...
        OmitGroupSeparator: ClassVar[QLocale.NumberOption] = ...
        OmitLeadingZeroInExponent: ClassVar[QLocale.NumberOption] = ...
        RejectGroupSeparator: ClassVar[QLocale.NumberOption] = ...
        RejectLeadingZeroInExponent: ClassVar[QLocale.NumberOption] = ...
        RejectTrailingZeroesAfterDot: ClassVar[QLocale.NumberOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QLocale.NumberOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...

    class NumberOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QLocale.NumberOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.NumberOptions: ...

    class QuotationStyle:
        AlternateQuotation: ClassVar[QLocale.QuotationStyle] = ...
        StandardQuotation: ClassVar[QLocale.QuotationStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.QuotationStyle: ...

    class Script:
        AdlamScript: ClassVar[QLocale.Script] = ...
        AhomScript: ClassVar[QLocale.Script] = ...
        AnatolianHieroglyphsScript: ClassVar[QLocale.Script] = ...
        AnyScript: ClassVar[QLocale.Script] = ...
        ArabicScript: ClassVar[QLocale.Script] = ...
        ArmenianScript: ClassVar[QLocale.Script] = ...
        AvestanScript: ClassVar[QLocale.Script] = ...
        BalineseScript: ClassVar[QLocale.Script] = ...
        BamumScript: ClassVar[QLocale.Script] = ...
        BassaVahScript: ClassVar[QLocale.Script] = ...
        BatakScript: ClassVar[QLocale.Script] = ...
        BengaliScript: ClassVar[QLocale.Script] = ...
        BhaiksukiScript: ClassVar[QLocale.Script] = ...
        BopomofoScript: ClassVar[QLocale.Script] = ...
        BrahmiScript: ClassVar[QLocale.Script] = ...
        BrailleScript: ClassVar[QLocale.Script] = ...
        BugineseScript: ClassVar[QLocale.Script] = ...
        BuhidScript: ClassVar[QLocale.Script] = ...
        CanadianAboriginalScript: ClassVar[QLocale.Script] = ...
        CarianScript: ClassVar[QLocale.Script] = ...
        CaucasianAlbanianScript: ClassVar[QLocale.Script] = ...
        ChakmaScript: ClassVar[QLocale.Script] = ...
        ChamScript: ClassVar[QLocale.Script] = ...
        CherokeeScript: ClassVar[QLocale.Script] = ...
        CopticScript: ClassVar[QLocale.Script] = ...
        CuneiformScript: ClassVar[QLocale.Script] = ...
        CypriotScript: ClassVar[QLocale.Script] = ...
        CyrillicScript: ClassVar[QLocale.Script] = ...
        DeseretScript: ClassVar[QLocale.Script] = ...
        DevanagariScript: ClassVar[QLocale.Script] = ...
        DuployanScript: ClassVar[QLocale.Script] = ...
        EgyptianHieroglyphsScript: ClassVar[QLocale.Script] = ...
        ElbasanScript: ClassVar[QLocale.Script] = ...
        EthiopicScript: ClassVar[QLocale.Script] = ...
        FraserScript: ClassVar[QLocale.Script] = ...
        GeorgianScript: ClassVar[QLocale.Script] = ...
        GlagoliticScript: ClassVar[QLocale.Script] = ...
        GothicScript: ClassVar[QLocale.Script] = ...
        GranthaScript: ClassVar[QLocale.Script] = ...
        GreekScript: ClassVar[QLocale.Script] = ...
        GujaratiScript: ClassVar[QLocale.Script] = ...
        GurmukhiScript: ClassVar[QLocale.Script] = ...
        HanScript: ClassVar[QLocale.Script] = ...
        HanWithBopomofoScript: ClassVar[QLocale.Script] = ...
        HangulScript: ClassVar[QLocale.Script] = ...
        HanunooScript: ClassVar[QLocale.Script] = ...
        HatranScript: ClassVar[QLocale.Script] = ...
        HebrewScript: ClassVar[QLocale.Script] = ...
        HiraganaScript: ClassVar[QLocale.Script] = ...
        ImperialAramaicScript: ClassVar[QLocale.Script] = ...
        InscriptionalPahlaviScript: ClassVar[QLocale.Script] = ...
        InscriptionalParthianScript: ClassVar[QLocale.Script] = ...
        JamoScript: ClassVar[QLocale.Script] = ...
        JapaneseScript: ClassVar[QLocale.Script] = ...
        JavaneseScript: ClassVar[QLocale.Script] = ...
        KaithiScript: ClassVar[QLocale.Script] = ...
        KannadaScript: ClassVar[QLocale.Script] = ...
        KatakanaScript: ClassVar[QLocale.Script] = ...
        KayahLiScript: ClassVar[QLocale.Script] = ...
        KharoshthiScript: ClassVar[QLocale.Script] = ...
        KhmerScript: ClassVar[QLocale.Script] = ...
        KhojkiScript: ClassVar[QLocale.Script] = ...
        KhudawadiScript: ClassVar[QLocale.Script] = ...
        KoreanScript: ClassVar[QLocale.Script] = ...
        LannaScript: ClassVar[QLocale.Script] = ...
        LaoScript: ClassVar[QLocale.Script] = ...
        LastScript: ClassVar[QLocale.Script] = ...
        LatinScript: ClassVar[QLocale.Script] = ...
        LepchaScript: ClassVar[QLocale.Script] = ...
        LimbuScript: ClassVar[QLocale.Script] = ...
        LinearAScript: ClassVar[QLocale.Script] = ...
        LinearBScript: ClassVar[QLocale.Script] = ...
        LycianScript: ClassVar[QLocale.Script] = ...
        LydianScript: ClassVar[QLocale.Script] = ...
        MahajaniScript: ClassVar[QLocale.Script] = ...
        MalayalamScript: ClassVar[QLocale.Script] = ...
        MandaeanScript: ClassVar[QLocale.Script] = ...
        ManichaeanScript: ClassVar[QLocale.Script] = ...
        MarchenScript: ClassVar[QLocale.Script] = ...
        MeiteiMayekScript: ClassVar[QLocale.Script] = ...
        MendeKikakuiScript: ClassVar[QLocale.Script] = ...
        MeroiticCursiveScript: ClassVar[QLocale.Script] = ...
        MeroiticScript: ClassVar[QLocale.Script] = ...
        ModiScript: ClassVar[QLocale.Script] = ...
        MongolianScript: ClassVar[QLocale.Script] = ...
        MroScript: ClassVar[QLocale.Script] = ...
        MultaniScript: ClassVar[QLocale.Script] = ...
        MyanmarScript: ClassVar[QLocale.Script] = ...
        NabataeanScript: ClassVar[QLocale.Script] = ...
        NewTaiLueScript: ClassVar[QLocale.Script] = ...
        NewaScript: ClassVar[QLocale.Script] = ...
        NkoScript: ClassVar[QLocale.Script] = ...
        OghamScript: ClassVar[QLocale.Script] = ...
        OlChikiScript: ClassVar[QLocale.Script] = ...
        OldHungarianScript: ClassVar[QLocale.Script] = ...
        OldItalicScript: ClassVar[QLocale.Script] = ...
        OldNorthArabianScript: ClassVar[QLocale.Script] = ...
        OldPermicScript: ClassVar[QLocale.Script] = ...
        OldPersianScript: ClassVar[QLocale.Script] = ...
        OldSouthArabianScript: ClassVar[QLocale.Script] = ...
        OriyaScript: ClassVar[QLocale.Script] = ...
        OrkhonScript: ClassVar[QLocale.Script] = ...
        OsageScript: ClassVar[QLocale.Script] = ...
        OsmanyaScript: ClassVar[QLocale.Script] = ...
        PahawhHmongScript: ClassVar[QLocale.Script] = ...
        PalmyreneScript: ClassVar[QLocale.Script] = ...
        PauCinHauScript: ClassVar[QLocale.Script] = ...
        PhagsPaScript: ClassVar[QLocale.Script] = ...
        PhoenicianScript: ClassVar[QLocale.Script] = ...
        PollardPhoneticScript: ClassVar[QLocale.Script] = ...
        PsalterPahlaviScript: ClassVar[QLocale.Script] = ...
        RejangScript: ClassVar[QLocale.Script] = ...
        RunicScript: ClassVar[QLocale.Script] = ...
        SamaritanScript: ClassVar[QLocale.Script] = ...
        SaurashtraScript: ClassVar[QLocale.Script] = ...
        SharadaScript: ClassVar[QLocale.Script] = ...
        ShavianScript: ClassVar[QLocale.Script] = ...
        SiddhamScript: ClassVar[QLocale.Script] = ...
        SignWritingScript: ClassVar[QLocale.Script] = ...
        SimplifiedChineseScript: ClassVar[QLocale.Script] = ...
        SimplifiedHanScript: ClassVar[QLocale.Script] = ...
        SinhalaScript: ClassVar[QLocale.Script] = ...
        SoraSompengScript: ClassVar[QLocale.Script] = ...
        SundaneseScript: ClassVar[QLocale.Script] = ...
        SylotiNagriScript: ClassVar[QLocale.Script] = ...
        SyriacScript: ClassVar[QLocale.Script] = ...
        TagalogScript: ClassVar[QLocale.Script] = ...
        TagbanwaScript: ClassVar[QLocale.Script] = ...
        TaiLeScript: ClassVar[QLocale.Script] = ...
        TaiVietScript: ClassVar[QLocale.Script] = ...
        TakriScript: ClassVar[QLocale.Script] = ...
        TamilScript: ClassVar[QLocale.Script] = ...
        TangutScript: ClassVar[QLocale.Script] = ...
        TeluguScript: ClassVar[QLocale.Script] = ...
        ThaanaScript: ClassVar[QLocale.Script] = ...
        ThaiScript: ClassVar[QLocale.Script] = ...
        TibetanScript: ClassVar[QLocale.Script] = ...
        TifinaghScript: ClassVar[QLocale.Script] = ...
        TirhutaScript: ClassVar[QLocale.Script] = ...
        TraditionalChineseScript: ClassVar[QLocale.Script] = ...
        TraditionalHanScript: ClassVar[QLocale.Script] = ...
        UgariticScript: ClassVar[QLocale.Script] = ...
        VaiScript: ClassVar[QLocale.Script] = ...
        VarangKshitiScript: ClassVar[QLocale.Script] = ...
        YiScript: ClassVar[QLocale.Script] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __and__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __rand__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __ror__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __sub__(self, other: typing.SupportsInt) -> QLocale.Script: ...
        def __xor__(self, other: typing.SupportsInt) -> QLocale.Script: ...
    Abkhazian: ClassVar[QLocale.Language] = ...
    AdlamScript: ClassVar[QLocale.Script] = ...
    Afan: ClassVar[QLocale.Language] = ...
    Afar: ClassVar[QLocale.Language] = ...
    Afghanistan: ClassVar[QLocale.Country] = ...
    Afrikaans: ClassVar[QLocale.Language] = ...
    Aghem: ClassVar[QLocale.Language] = ...
    Ahom: ClassVar[QLocale.Language] = ...
    AhomScript: ClassVar[QLocale.Script] = ...
    Akan: ClassVar[QLocale.Language] = ...
    Akkadian: ClassVar[QLocale.Language] = ...
    Akoose: ClassVar[QLocale.Language] = ...
    AlandIslands: ClassVar[QLocale.Country] = ...
    Albania: ClassVar[QLocale.Country] = ...
    Albanian: ClassVar[QLocale.Language] = ...
    Algeria: ClassVar[QLocale.Country] = ...
    AlternateQuotation: ClassVar[QLocale.QuotationStyle] = ...
    AmericanSamoa: ClassVar[QLocale.Country] = ...
    AmericanSignLanguage: ClassVar[QLocale.Language] = ...
    Amharic: ClassVar[QLocale.Language] = ...
    AnatolianHieroglyphsScript: ClassVar[QLocale.Script] = ...
    AncientEgyptian: ClassVar[QLocale.Language] = ...
    AncientGreek: ClassVar[QLocale.Language] = ...
    AncientNorthArabian: ClassVar[QLocale.Language] = ...
    Andorra: ClassVar[QLocale.Country] = ...
    Angola: ClassVar[QLocale.Country] = ...
    Anguilla: ClassVar[QLocale.Country] = ...
    Antarctica: ClassVar[QLocale.Country] = ...
    AntiguaAndBarbuda: ClassVar[QLocale.Country] = ...
    AnyCountry: ClassVar[QLocale.Country] = ...
    AnyLanguage: ClassVar[QLocale.Language] = ...
    AnyScript: ClassVar[QLocale.Script] = ...
    Arabic: ClassVar[QLocale.Language] = ...
    ArabicScript: ClassVar[QLocale.Script] = ...
    Aragonese: ClassVar[QLocale.Language] = ...
    Aramaic: ClassVar[QLocale.Language] = ...
    ArdhamagadhiPrakrit: ClassVar[QLocale.Language] = ...
    Argentina: ClassVar[QLocale.Country] = ...
    Armenia: ClassVar[QLocale.Country] = ...
    Armenian: ClassVar[QLocale.Language] = ...
    ArmenianScript: ClassVar[QLocale.Script] = ...
    Aruba: ClassVar[QLocale.Country] = ...
    AscensionIsland: ClassVar[QLocale.Country] = ...
    Assamese: ClassVar[QLocale.Language] = ...
    Asturian: ClassVar[QLocale.Language] = ...
    Asu: ClassVar[QLocale.Language] = ...
    Atsam: ClassVar[QLocale.Language] = ...
    Australia: ClassVar[QLocale.Country] = ...
    Austria: ClassVar[QLocale.Country] = ...
    Avaric: ClassVar[QLocale.Language] = ...
    Avestan: ClassVar[QLocale.Language] = ...
    AvestanScript: ClassVar[QLocale.Script] = ...
    Aymara: ClassVar[QLocale.Language] = ...
    Azerbaijan: ClassVar[QLocale.Country] = ...
    Azerbaijani: ClassVar[QLocale.Language] = ...
    Bafia: ClassVar[QLocale.Language] = ...
    Bahamas: ClassVar[QLocale.Country] = ...
    Bahrain: ClassVar[QLocale.Country] = ...
    Balinese: ClassVar[QLocale.Language] = ...
    BalineseScript: ClassVar[QLocale.Script] = ...
    Bambara: ClassVar[QLocale.Language] = ...
    BamumScript: ClassVar[QLocale.Script] = ...
    Bamun: ClassVar[QLocale.Language] = ...
    Bangladesh: ClassVar[QLocale.Country] = ...
    Barbados: ClassVar[QLocale.Country] = ...
    Basaa: ClassVar[QLocale.Language] = ...
    Bashkir: ClassVar[QLocale.Language] = ...
    Basque: ClassVar[QLocale.Language] = ...
    Bassa: ClassVar[QLocale.Language] = ...
    BassaVahScript: ClassVar[QLocale.Script] = ...
    BatakScript: ClassVar[QLocale.Script] = ...
    BatakToba: ClassVar[QLocale.Language] = ...
    Belarus: ClassVar[QLocale.Country] = ...
    Belarusian: ClassVar[QLocale.Language] = ...
    Belgium: ClassVar[QLocale.Country] = ...
    Belize: ClassVar[QLocale.Country] = ...
    Bemba: ClassVar[QLocale.Language] = ...
    Bena: ClassVar[QLocale.Language] = ...
    Bengali: ClassVar[QLocale.Language] = ...
    BengaliScript: ClassVar[QLocale.Script] = ...
    Benin: ClassVar[QLocale.Country] = ...
    Bermuda: ClassVar[QLocale.Country] = ...
    BhaiksukiScript: ClassVar[QLocale.Script] = ...
    Bhojpuri: ClassVar[QLocale.Language] = ...
    Bhutan: ClassVar[QLocale.Country] = ...
    Bhutani: ClassVar[QLocale.Language] = ...
    Bihari: ClassVar[QLocale.Language] = ...
    Bislama: ClassVar[QLocale.Language] = ...
    Blin: ClassVar[QLocale.Language] = ...
    Bodo: ClassVar[QLocale.Language] = ...
    Bolivia: ClassVar[QLocale.Country] = ...
    Bonaire: ClassVar[QLocale.Country] = ...
    BopomofoScript: ClassVar[QLocale.Script] = ...
    BosniaAndHerzegowina: ClassVar[QLocale.Country] = ...
    Bosnian: ClassVar[QLocale.Language] = ...
    Botswana: ClassVar[QLocale.Country] = ...
    BouvetIsland: ClassVar[QLocale.Country] = ...
    BrahmiScript: ClassVar[QLocale.Script] = ...
    BrailleScript: ClassVar[QLocale.Script] = ...
    Brazil: ClassVar[QLocale.Country] = ...
    Breton: ClassVar[QLocale.Language] = ...
    BritishIndianOceanTerritory: ClassVar[QLocale.Country] = ...
    BritishVirginIslands: ClassVar[QLocale.Country] = ...
    Brunei: ClassVar[QLocale.Country] = ...
    Buginese: ClassVar[QLocale.Language] = ...
    BugineseScript: ClassVar[QLocale.Script] = ...
    Buhid: ClassVar[QLocale.Language] = ...
    BuhidScript: ClassVar[QLocale.Script] = ...
    Bulgaria: ClassVar[QLocale.Country] = ...
    Bulgarian: ClassVar[QLocale.Language] = ...
    BurkinaFaso: ClassVar[QLocale.Country] = ...
    Burmese: ClassVar[QLocale.Language] = ...
    Burundi: ClassVar[QLocale.Country] = ...
    Byelorussian: ClassVar[QLocale.Language] = ...
    C: ClassVar[QLocale.Language] = ...
    Cambodia: ClassVar[QLocale.Country] = ...
    Cambodian: ClassVar[QLocale.Language] = ...
    Cameroon: ClassVar[QLocale.Country] = ...
    Canada: ClassVar[QLocale.Country] = ...
    CanadianAboriginalScript: ClassVar[QLocale.Script] = ...
    CanaryIslands: ClassVar[QLocale.Country] = ...
    Cantonese: ClassVar[QLocale.Language] = ...
    CapeVerde: ClassVar[QLocale.Country] = ...
    Carian: ClassVar[QLocale.Language] = ...
    CarianScript: ClassVar[QLocale.Script] = ...
    Catalan: ClassVar[QLocale.Language] = ...
    CaucasianAlbanianScript: ClassVar[QLocale.Script] = ...
    CaymanIslands: ClassVar[QLocale.Country] = ...
    Cebuano: ClassVar[QLocale.Language] = ...
    CentralAfricanRepublic: ClassVar[QLocale.Country] = ...
    CentralKurdish: ClassVar[QLocale.Language] = ...
    CentralMoroccoTamazight: ClassVar[QLocale.Language] = ...
    CeutaAndMelilla: ClassVar[QLocale.Country] = ...
    Chad: ClassVar[QLocale.Country] = ...
    Chakma: ClassVar[QLocale.Language] = ...
    ChakmaScript: ClassVar[QLocale.Script] = ...
    ChamScript: ClassVar[QLocale.Script] = ...
    Chamorro: ClassVar[QLocale.Language] = ...
    Chechen: ClassVar[QLocale.Language] = ...
    Cherokee: ClassVar[QLocale.Language] = ...
    CherokeeScript: ClassVar[QLocale.Script] = ...
    Chewa: ClassVar[QLocale.Language] = ...
    Chickasaw: ClassVar[QLocale.Language] = ...
    Chiga: ClassVar[QLocale.Language] = ...
    Chile: ClassVar[QLocale.Country] = ...
    China: ClassVar[QLocale.Country] = ...
    Chinese: ClassVar[QLocale.Language] = ...
    ChristmasIsland: ClassVar[QLocale.Country] = ...
    Church: ClassVar[QLocale.Language] = ...
    Chuvash: ClassVar[QLocale.Language] = ...
    ClassicalMandaic: ClassVar[QLocale.Language] = ...
    ClippertonIsland: ClassVar[QLocale.Country] = ...
    CocosIslands: ClassVar[QLocale.Country] = ...
    Colognian: ClassVar[QLocale.Language] = ...
    Colombia: ClassVar[QLocale.Country] = ...
    Comoros: ClassVar[QLocale.Country] = ...
    CongoBrazzaville: ClassVar[QLocale.Country] = ...
    CongoKinshasa: ClassVar[QLocale.Country] = ...
    CongoSwahili: ClassVar[QLocale.Language] = ...
    CookIslands: ClassVar[QLocale.Country] = ...
    Coptic: ClassVar[QLocale.Language] = ...
    CopticScript: ClassVar[QLocale.Script] = ...
    Cornish: ClassVar[QLocale.Language] = ...
    Corsican: ClassVar[QLocale.Language] = ...
    CostaRica: ClassVar[QLocale.Country] = ...
    Cree: ClassVar[QLocale.Language] = ...
    Croatia: ClassVar[QLocale.Country] = ...
    Croatian: ClassVar[QLocale.Language] = ...
    Cuba: ClassVar[QLocale.Country] = ...
    CuneiformScript: ClassVar[QLocale.Script] = ...
    CuraSao: ClassVar[QLocale.Country] = ...
    CurrencyDisplayName: ClassVar[QLocale.CurrencySymbolFormat] = ...
    CurrencyIsoCode: ClassVar[QLocale.CurrencySymbolFormat] = ...
    CurrencySymbol: ClassVar[QLocale.CurrencySymbolFormat] = ...
    CypriotScript: ClassVar[QLocale.Script] = ...
    Cyprus: ClassVar[QLocale.Country] = ...
    CyrillicScript: ClassVar[QLocale.Script] = ...
    Czech: ClassVar[QLocale.Language] = ...
    CzechRepublic: ClassVar[QLocale.Country] = ...
    Danish: ClassVar[QLocale.Language] = ...
    DataSizeBase1000: ClassVar[QLocale.DataSizeFormat] = ...
    DataSizeIecFormat: ClassVar[QLocale.DataSizeFormat] = ...
    DataSizeSIFormat: ClassVar[QLocale.DataSizeFormat] = ...
    DataSizeSIQuantifiers: ClassVar[QLocale.DataSizeFormat] = ...
    DataSizeTraditionalFormat: ClassVar[QLocale.DataSizeFormat] = ...
    DefaultNumberOptions: ClassVar[QLocale.NumberOption] = ...
    DemocraticRepublicOfCongo: ClassVar[QLocale.Country] = ...
    DemocraticRepublicOfKorea: ClassVar[QLocale.Country] = ...
    Denmark: ClassVar[QLocale.Country] = ...
    DeseretScript: ClassVar[QLocale.Script] = ...
    DevanagariScript: ClassVar[QLocale.Script] = ...
    DiegoGarcia: ClassVar[QLocale.Country] = ...
    Divehi: ClassVar[QLocale.Language] = ...
    Djibouti: ClassVar[QLocale.Country] = ...
    Dogri: ClassVar[QLocale.Language] = ...
    Dominica: ClassVar[QLocale.Country] = ...
    DominicanRepublic: ClassVar[QLocale.Country] = ...
    Duala: ClassVar[QLocale.Language] = ...
    DuployanScript: ClassVar[QLocale.Script] = ...
    Dutch: ClassVar[QLocale.Language] = ...
    Dzongkha: ClassVar[QLocale.Language] = ...
    EastTimor: ClassVar[QLocale.Country] = ...
    EasternCham: ClassVar[QLocale.Language] = ...
    EasternKayah: ClassVar[QLocale.Language] = ...
    Ecuador: ClassVar[QLocale.Country] = ...
    Egypt: ClassVar[QLocale.Country] = ...
    EgyptianHieroglyphsScript: ClassVar[QLocale.Script] = ...
    ElSalvador: ClassVar[QLocale.Country] = ...
    ElbasanScript: ClassVar[QLocale.Script] = ...
    Embu: ClassVar[QLocale.Language] = ...
    English: ClassVar[QLocale.Language] = ...
    EquatorialGuinea: ClassVar[QLocale.Country] = ...
    Eritrea: ClassVar[QLocale.Country] = ...
    Erzya: ClassVar[QLocale.Language] = ...
    Esperanto: ClassVar[QLocale.Language] = ...
    Estonia: ClassVar[QLocale.Country] = ...
    Estonian: ClassVar[QLocale.Language] = ...
    Ethiopia: ClassVar[QLocale.Country] = ...
    EthiopicScript: ClassVar[QLocale.Script] = ...
    Etruscan: ClassVar[QLocale.Language] = ...
    Europe: ClassVar[QLocale.Country] = ...
    EuropeanUnion: ClassVar[QLocale.Country] = ...
    Ewe: ClassVar[QLocale.Language] = ...
    Ewondo: ClassVar[QLocale.Language] = ...
    FalklandIslands: ClassVar[QLocale.Country] = ...
    FaroeIslands: ClassVar[QLocale.Country] = ...
    Faroese: ClassVar[QLocale.Language] = ...
    Fiji: ClassVar[QLocale.Country] = ...
    Fijian: ClassVar[QLocale.Language] = ...
    Filipino: ClassVar[QLocale.Language] = ...
    Finland: ClassVar[QLocale.Country] = ...
    Finnish: ClassVar[QLocale.Language] = ...
    FloatingPointShortest: ClassVar[QLocale.FloatingPointPrecisionOption] = ...
    France: ClassVar[QLocale.Country] = ...
    FraserScript: ClassVar[QLocale.Script] = ...
    French: ClassVar[QLocale.Language] = ...
    FrenchGuiana: ClassVar[QLocale.Country] = ...
    FrenchPolynesia: ClassVar[QLocale.Country] = ...
    FrenchSouthernTerritories: ClassVar[QLocale.Country] = ...
    Frisian: ClassVar[QLocale.Language] = ...
    Friulian: ClassVar[QLocale.Language] = ...
    Fulah: ClassVar[QLocale.Language] = ...
    Ga: ClassVar[QLocale.Language] = ...
    Gabon: ClassVar[QLocale.Country] = ...
    Gaelic: ClassVar[QLocale.Language] = ...
    Galician: ClassVar[QLocale.Language] = ...
    Gambia: ClassVar[QLocale.Country] = ...
    Ganda: ClassVar[QLocale.Language] = ...
    Geez: ClassVar[QLocale.Language] = ...
    Georgia: ClassVar[QLocale.Country] = ...
    Georgian: ClassVar[QLocale.Language] = ...
    GeorgianScript: ClassVar[QLocale.Script] = ...
    German: ClassVar[QLocale.Language] = ...
    Germany: ClassVar[QLocale.Country] = ...
    Ghana: ClassVar[QLocale.Country] = ...
    Gibraltar: ClassVar[QLocale.Country] = ...
    GlagoliticScript: ClassVar[QLocale.Script] = ...
    Gothic: ClassVar[QLocale.Language] = ...
    GothicScript: ClassVar[QLocale.Script] = ...
    GranthaScript: ClassVar[QLocale.Script] = ...
    Greece: ClassVar[QLocale.Country] = ...
    Greek: ClassVar[QLocale.Language] = ...
    GreekScript: ClassVar[QLocale.Script] = ...
    Greenland: ClassVar[QLocale.Country] = ...
    Greenlandic: ClassVar[QLocale.Language] = ...
    Grenada: ClassVar[QLocale.Country] = ...
    Guadeloupe: ClassVar[QLocale.Country] = ...
    Guam: ClassVar[QLocale.Country] = ...
    Guarani: ClassVar[QLocale.Language] = ...
    Guatemala: ClassVar[QLocale.Country] = ...
    Guernsey: ClassVar[QLocale.Country] = ...
    Guinea: ClassVar[QLocale.Country] = ...
    GuineaBissau: ClassVar[QLocale.Country] = ...
    Gujarati: ClassVar[QLocale.Language] = ...
    GujaratiScript: ClassVar[QLocale.Script] = ...
    GurmukhiScript: ClassVar[QLocale.Script] = ...
    Gusii: ClassVar[QLocale.Language] = ...
    Guyana: ClassVar[QLocale.Country] = ...
    Haiti: ClassVar[QLocale.Country] = ...
    Haitian: ClassVar[QLocale.Language] = ...
    HanScript: ClassVar[QLocale.Script] = ...
    HanWithBopomofoScript: ClassVar[QLocale.Script] = ...
    HangulScript: ClassVar[QLocale.Script] = ...
    Hanunoo: ClassVar[QLocale.Language] = ...
    HanunooScript: ClassVar[QLocale.Script] = ...
    HatranScript: ClassVar[QLocale.Script] = ...
    Hausa: ClassVar[QLocale.Language] = ...
    Hawaiian: ClassVar[QLocale.Language] = ...
    HeardAndMcDonaldIslands: ClassVar[QLocale.Country] = ...
    Hebrew: ClassVar[QLocale.Language] = ...
    HebrewScript: ClassVar[QLocale.Script] = ...
    Herero: ClassVar[QLocale.Language] = ...
    HieroglyphicLuwian: ClassVar[QLocale.Language] = ...
    Hindi: ClassVar[QLocale.Language] = ...
    HiraganaScript: ClassVar[QLocale.Script] = ...
    HiriMotu: ClassVar[QLocale.Language] = ...
    HmongNjua: ClassVar[QLocale.Language] = ...
    Ho: ClassVar[QLocale.Language] = ...
    Honduras: ClassVar[QLocale.Country] = ...
    HongKong: ClassVar[QLocale.Country] = ...
    Hungarian: ClassVar[QLocale.Language] = ...
    Hungary: ClassVar[QLocale.Country] = ...
    Iceland: ClassVar[QLocale.Country] = ...
    Icelandic: ClassVar[QLocale.Language] = ...
    Ido: ClassVar[QLocale.Language] = ...
    Igbo: ClassVar[QLocale.Language] = ...
    ImperialAramaicScript: ClassVar[QLocale.Script] = ...
    ImperialSystem: ClassVar[QLocale.MeasurementSystem] = ...
    ImperialUKSystem: ClassVar[QLocale.MeasurementSystem] = ...
    ImperialUSSystem: ClassVar[QLocale.MeasurementSystem] = ...
    InariSami: ClassVar[QLocale.Language] = ...
    IncludeTrailingZeroesAfterDot: ClassVar[QLocale.NumberOption] = ...
    India: ClassVar[QLocale.Country] = ...
    Indonesia: ClassVar[QLocale.Country] = ...
    Indonesian: ClassVar[QLocale.Language] = ...
    Ingush: ClassVar[QLocale.Language] = ...
    InscriptionalPahlaviScript: ClassVar[QLocale.Script] = ...
    InscriptionalParthianScript: ClassVar[QLocale.Script] = ...
    Interlingua: ClassVar[QLocale.Language] = ...
    Interlingue: ClassVar[QLocale.Language] = ...
    Inuktitut: ClassVar[QLocale.Language] = ...
    Inupiak: ClassVar[QLocale.Language] = ...
    Iran: ClassVar[QLocale.Country] = ...
    Iraq: ClassVar[QLocale.Country] = ...
    Ireland: ClassVar[QLocale.Country] = ...
    Irish: ClassVar[QLocale.Language] = ...
    IsleOfMan: ClassVar[QLocale.Country] = ...
    Israel: ClassVar[QLocale.Country] = ...
    Italian: ClassVar[QLocale.Language] = ...
    Italy: ClassVar[QLocale.Country] = ...
    IvoryCoast: ClassVar[QLocale.Country] = ...
    Jamaica: ClassVar[QLocale.Country] = ...
    JamoScript: ClassVar[QLocale.Script] = ...
    Japan: ClassVar[QLocale.Country] = ...
    Japanese: ClassVar[QLocale.Language] = ...
    JapaneseScript: ClassVar[QLocale.Script] = ...
    Javanese: ClassVar[QLocale.Language] = ...
    JavaneseScript: ClassVar[QLocale.Script] = ...
    Jersey: ClassVar[QLocale.Country] = ...
    Jju: ClassVar[QLocale.Language] = ...
    JolaFonyi: ClassVar[QLocale.Language] = ...
    Jordan: ClassVar[QLocale.Country] = ...
    Kabuverdianu: ClassVar[QLocale.Language] = ...
    Kabyle: ClassVar[QLocale.Language] = ...
    KaithiScript: ClassVar[QLocale.Script] = ...
    Kako: ClassVar[QLocale.Language] = ...
    Kalenjin: ClassVar[QLocale.Language] = ...
    Kamba: ClassVar[QLocale.Language] = ...
    Kannada: ClassVar[QLocale.Language] = ...
    KannadaScript: ClassVar[QLocale.Script] = ...
    Kanuri: ClassVar[QLocale.Language] = ...
    Kashmiri: ClassVar[QLocale.Language] = ...
    KatakanaScript: ClassVar[QLocale.Script] = ...
    KayahLiScript: ClassVar[QLocale.Script] = ...
    Kazakh: ClassVar[QLocale.Language] = ...
    Kazakhstan: ClassVar[QLocale.Country] = ...
    Kenya: ClassVar[QLocale.Country] = ...
    Kenyang: ClassVar[QLocale.Language] = ...
    KharoshthiScript: ClassVar[QLocale.Script] = ...
    Khmer: ClassVar[QLocale.Language] = ...
    KhmerScript: ClassVar[QLocale.Script] = ...
    KhojkiScript: ClassVar[QLocale.Script] = ...
    KhudawadiScript: ClassVar[QLocale.Script] = ...
    Kiche: ClassVar[QLocale.Language] = ...
    Kikuyu: ClassVar[QLocale.Language] = ...
    Kinyarwanda: ClassVar[QLocale.Language] = ...
    Kirghiz: ClassVar[QLocale.Language] = ...
    Kiribati: ClassVar[QLocale.Country] = ...
    Komi: ClassVar[QLocale.Language] = ...
    Kongo: ClassVar[QLocale.Language] = ...
    Konkani: ClassVar[QLocale.Language] = ...
    Korean: ClassVar[QLocale.Language] = ...
    KoreanScript: ClassVar[QLocale.Script] = ...
    Koro: ClassVar[QLocale.Language] = ...
    Kosovo: ClassVar[QLocale.Country] = ...
    KoyraChiini: ClassVar[QLocale.Language] = ...
    KoyraboroSenni: ClassVar[QLocale.Language] = ...
    Kpelle: ClassVar[QLocale.Language] = ...
    Kurdish: ClassVar[QLocale.Language] = ...
    Kurundi: ClassVar[QLocale.Language] = ...
    Kuwait: ClassVar[QLocale.Country] = ...
    Kwanyama: ClassVar[QLocale.Language] = ...
    Kwasio: ClassVar[QLocale.Language] = ...
    Kyrgyzstan: ClassVar[QLocale.Country] = ...
    Lakota: ClassVar[QLocale.Language] = ...
    Langi: ClassVar[QLocale.Language] = ...
    LannaScript: ClassVar[QLocale.Script] = ...
    Lao: ClassVar[QLocale.Language] = ...
    LaoScript: ClassVar[QLocale.Script] = ...
    Laos: ClassVar[QLocale.Country] = ...
    LargeFloweryMiao: ClassVar[QLocale.Language] = ...
    LastCountry: ClassVar[QLocale.Country] = ...
    LastLanguage: ClassVar[QLocale.Language] = ...
    LastScript: ClassVar[QLocale.Script] = ...
    Latin: ClassVar[QLocale.Language] = ...
    LatinAmerica: ClassVar[QLocale.Country] = ...
    LatinAmericaAndTheCaribbean: ClassVar[QLocale.Country] = ...
    LatinScript: ClassVar[QLocale.Script] = ...
    Latvia: ClassVar[QLocale.Country] = ...
    Latvian: ClassVar[QLocale.Language] = ...
    Lebanon: ClassVar[QLocale.Country] = ...
    Lepcha: ClassVar[QLocale.Language] = ...
    LepchaScript: ClassVar[QLocale.Script] = ...
    Lesotho: ClassVar[QLocale.Country] = ...
    Lezghian: ClassVar[QLocale.Language] = ...
    Liberia: ClassVar[QLocale.Country] = ...
    Libya: ClassVar[QLocale.Country] = ...
    Liechtenstein: ClassVar[QLocale.Country] = ...
    Limbu: ClassVar[QLocale.Language] = ...
    LimbuScript: ClassVar[QLocale.Script] = ...
    Limburgish: ClassVar[QLocale.Language] = ...
    LinearA: ClassVar[QLocale.Language] = ...
    LinearAScript: ClassVar[QLocale.Script] = ...
    LinearBScript: ClassVar[QLocale.Script] = ...
    Lingala: ClassVar[QLocale.Language] = ...
    Lisu: ClassVar[QLocale.Language] = ...
    LiteraryChinese: ClassVar[QLocale.Language] = ...
    Lithuania: ClassVar[QLocale.Country] = ...
    Lithuanian: ClassVar[QLocale.Language] = ...
    Lojban: ClassVar[QLocale.Language] = ...
    LongFormat: ClassVar[QLocale.FormatType] = ...
    LowGerman: ClassVar[QLocale.Language] = ...
    LowerSorbian: ClassVar[QLocale.Language] = ...
    Lu: ClassVar[QLocale.Language] = ...
    LubaKatanga: ClassVar[QLocale.Language] = ...
    LuleSami: ClassVar[QLocale.Language] = ...
    Luo: ClassVar[QLocale.Language] = ...
    Luxembourg: ClassVar[QLocale.Country] = ...
    Luxembourgish: ClassVar[QLocale.Language] = ...
    Luyia: ClassVar[QLocale.Language] = ...
    Lycian: ClassVar[QLocale.Language] = ...
    LycianScript: ClassVar[QLocale.Script] = ...
    Lydian: ClassVar[QLocale.Language] = ...
    LydianScript: ClassVar[QLocale.Script] = ...
    Macau: ClassVar[QLocale.Country] = ...
    Macedonia: ClassVar[QLocale.Country] = ...
    Macedonian: ClassVar[QLocale.Language] = ...
    Machame: ClassVar[QLocale.Language] = ...
    Madagascar: ClassVar[QLocale.Country] = ...
    MahajaniScript: ClassVar[QLocale.Script] = ...
    Maithili: ClassVar[QLocale.Language] = ...
    MakhuwaMeetto: ClassVar[QLocale.Language] = ...
    Makonde: ClassVar[QLocale.Language] = ...
    Malagasy: ClassVar[QLocale.Language] = ...
    Malawi: ClassVar[QLocale.Country] = ...
    Malay: ClassVar[QLocale.Language] = ...
    Malayalam: ClassVar[QLocale.Language] = ...
    MalayalamScript: ClassVar[QLocale.Script] = ...
    Malaysia: ClassVar[QLocale.Country] = ...
    Maldives: ClassVar[QLocale.Country] = ...
    Mali: ClassVar[QLocale.Country] = ...
    Malta: ClassVar[QLocale.Country] = ...
    Maltese: ClassVar[QLocale.Language] = ...
    MandaeanScript: ClassVar[QLocale.Script] = ...
    Mandingo: ClassVar[QLocale.Language] = ...
    ManichaeanMiddlePersian: ClassVar[QLocale.Language] = ...
    ManichaeanScript: ClassVar[QLocale.Script] = ...
    Manipuri: ClassVar[QLocale.Language] = ...
    Manx: ClassVar[QLocale.Language] = ...
    Maori: ClassVar[QLocale.Language] = ...
    Mapuche: ClassVar[QLocale.Language] = ...
    Marathi: ClassVar[QLocale.Language] = ...
    MarchenScript: ClassVar[QLocale.Script] = ...
    MarshallIslands: ClassVar[QLocale.Country] = ...
    Marshallese: ClassVar[QLocale.Language] = ...
    Martinique: ClassVar[QLocale.Country] = ...
    Masai: ClassVar[QLocale.Language] = ...
    Mauritania: ClassVar[QLocale.Country] = ...
    Mauritius: ClassVar[QLocale.Country] = ...
    Mayotte: ClassVar[QLocale.Country] = ...
    Mazanderani: ClassVar[QLocale.Language] = ...
    MeiteiMayekScript: ClassVar[QLocale.Script] = ...
    Mende: ClassVar[QLocale.Language] = ...
    MendeKikakuiScript: ClassVar[QLocale.Script] = ...
    Meroitic: ClassVar[QLocale.Language] = ...
    MeroiticCursiveScript: ClassVar[QLocale.Script] = ...
    MeroiticScript: ClassVar[QLocale.Script] = ...
    Meru: ClassVar[QLocale.Language] = ...
    Meta: ClassVar[QLocale.Language] = ...
    MetricSystem: ClassVar[QLocale.MeasurementSystem] = ...
    Mexico: ClassVar[QLocale.Country] = ...
    Micronesia: ClassVar[QLocale.Country] = ...
    ModiScript: ClassVar[QLocale.Script] = ...
    Mohawk: ClassVar[QLocale.Language] = ...
    Moldavian: ClassVar[QLocale.Language] = ...
    Moldova: ClassVar[QLocale.Country] = ...
    Monaco: ClassVar[QLocale.Country] = ...
    Mongolia: ClassVar[QLocale.Country] = ...
    Mongolian: ClassVar[QLocale.Language] = ...
    MongolianScript: ClassVar[QLocale.Script] = ...
    Mono: ClassVar[QLocale.Language] = ...
    Montenegro: ClassVar[QLocale.Country] = ...
    Montserrat: ClassVar[QLocale.Country] = ...
    Morisyen: ClassVar[QLocale.Language] = ...
    Morocco: ClassVar[QLocale.Country] = ...
    Mozambique: ClassVar[QLocale.Country] = ...
    MroScript: ClassVar[QLocale.Script] = ...
    Mru: ClassVar[QLocale.Language] = ...
    MultaniScript: ClassVar[QLocale.Script] = ...
    Mundang: ClassVar[QLocale.Language] = ...
    Muscogee: ClassVar[QLocale.Language] = ...
    Myanmar: ClassVar[QLocale.Country] = ...
    MyanmarScript: ClassVar[QLocale.Script] = ...
    NabataeanScript: ClassVar[QLocale.Script] = ...
    Nama: ClassVar[QLocale.Language] = ...
    Namibia: ClassVar[QLocale.Country] = ...
    NarrowFormat: ClassVar[QLocale.FormatType] = ...
    NauruCountry: ClassVar[QLocale.Country] = ...
    NauruLanguage: ClassVar[QLocale.Language] = ...
    Navaho: ClassVar[QLocale.Language] = ...
    Ndonga: ClassVar[QLocale.Language] = ...
    Nepal: ClassVar[QLocale.Country] = ...
    Nepali: ClassVar[QLocale.Language] = ...
    Netherlands: ClassVar[QLocale.Country] = ...
    NewCaledonia: ClassVar[QLocale.Country] = ...
    NewTaiLueScript: ClassVar[QLocale.Script] = ...
    NewZealand: ClassVar[QLocale.Country] = ...
    NewaScript: ClassVar[QLocale.Script] = ...
    Newari: ClassVar[QLocale.Language] = ...
    Ngiemboon: ClassVar[QLocale.Language] = ...
    Ngomba: ClassVar[QLocale.Language] = ...
    Nicaragua: ClassVar[QLocale.Country] = ...
    Niger: ClassVar[QLocale.Country] = ...
    Nigeria: ClassVar[QLocale.Country] = ...
    NigerianPidgin: ClassVar[QLocale.Language] = ...
    Niue: ClassVar[QLocale.Country] = ...
    Nko: ClassVar[QLocale.Language] = ...
    NkoScript: ClassVar[QLocale.Script] = ...
    NorfolkIsland: ClassVar[QLocale.Country] = ...
    NorthKorea: ClassVar[QLocale.Country] = ...
    NorthNdebele: ClassVar[QLocale.Language] = ...
    NorthernLuri: ClassVar[QLocale.Language] = ...
    NorthernMarianaIslands: ClassVar[QLocale.Country] = ...
    NorthernSami: ClassVar[QLocale.Language] = ...
    NorthernSotho: ClassVar[QLocale.Language] = ...
    NorthernThai: ClassVar[QLocale.Language] = ...
    Norway: ClassVar[QLocale.Country] = ...
    Norwegian: ClassVar[QLocale.Language] = ...
    NorwegianBokmal: ClassVar[QLocale.Language] = ...
    NorwegianNynorsk: ClassVar[QLocale.Language] = ...
    Nuer: ClassVar[QLocale.Language] = ...
    Nyanja: ClassVar[QLocale.Language] = ...
    Nyankole: ClassVar[QLocale.Language] = ...
    Occitan: ClassVar[QLocale.Language] = ...
    OghamScript: ClassVar[QLocale.Script] = ...
    Ojibwa: ClassVar[QLocale.Language] = ...
    OlChikiScript: ClassVar[QLocale.Script] = ...
    OldHungarianScript: ClassVar[QLocale.Script] = ...
    OldIrish: ClassVar[QLocale.Language] = ...
    OldItalicScript: ClassVar[QLocale.Script] = ...
    OldNorse: ClassVar[QLocale.Language] = ...
    OldNorthArabianScript: ClassVar[QLocale.Script] = ...
    OldPermicScript: ClassVar[QLocale.Script] = ...
    OldPersian: ClassVar[QLocale.Language] = ...
    OldPersianScript: ClassVar[QLocale.Script] = ...
    OldSouthArabianScript: ClassVar[QLocale.Script] = ...
    OldTurkish: ClassVar[QLocale.Language] = ...
    Oman: ClassVar[QLocale.Country] = ...
    OmitGroupSeparator: ClassVar[QLocale.NumberOption] = ...
    OmitLeadingZeroInExponent: ClassVar[QLocale.NumberOption] = ...
    Oriya: ClassVar[QLocale.Language] = ...
    OriyaScript: ClassVar[QLocale.Script] = ...
    OrkhonScript: ClassVar[QLocale.Script] = ...
    Oromo: ClassVar[QLocale.Language] = ...
    Osage: ClassVar[QLocale.Language] = ...
    OsageScript: ClassVar[QLocale.Script] = ...
    OsmanyaScript: ClassVar[QLocale.Script] = ...
    Ossetic: ClassVar[QLocale.Language] = ...
    OutlyingOceania: ClassVar[QLocale.Country] = ...
    PahawhHmongScript: ClassVar[QLocale.Script] = ...
    Pahlavi: ClassVar[QLocale.Language] = ...
    Pakistan: ClassVar[QLocale.Country] = ...
    Palau: ClassVar[QLocale.Country] = ...
    Palauan: ClassVar[QLocale.Language] = ...
    PalestinianTerritories: ClassVar[QLocale.Country] = ...
    Pali: ClassVar[QLocale.Language] = ...
    PalmyreneScript: ClassVar[QLocale.Script] = ...
    Panama: ClassVar[QLocale.Country] = ...
    Papiamento: ClassVar[QLocale.Language] = ...
    PapuaNewGuinea: ClassVar[QLocale.Country] = ...
    Paraguay: ClassVar[QLocale.Country] = ...
    Parthian: ClassVar[QLocale.Language] = ...
    Pashto: ClassVar[QLocale.Language] = ...
    PauCinHauScript: ClassVar[QLocale.Script] = ...
    PeoplesRepublicOfCongo: ClassVar[QLocale.Country] = ...
    Persian: ClassVar[QLocale.Language] = ...
    Peru: ClassVar[QLocale.Country] = ...
    PhagsPaScript: ClassVar[QLocale.Script] = ...
    Philippines: ClassVar[QLocale.Country] = ...
    Phoenician: ClassVar[QLocale.Language] = ...
    PhoenicianScript: ClassVar[QLocale.Script] = ...
    Pitcairn: ClassVar[QLocale.Country] = ...
    Poland: ClassVar[QLocale.Country] = ...
    Polish: ClassVar[QLocale.Language] = ...
    PollardPhoneticScript: ClassVar[QLocale.Script] = ...
    Portugal: ClassVar[QLocale.Country] = ...
    Portuguese: ClassVar[QLocale.Language] = ...
    PrakritLanguage: ClassVar[QLocale.Language] = ...
    Prussian: ClassVar[QLocale.Language] = ...
    PsalterPahlaviScript: ClassVar[QLocale.Script] = ...
    PuertoRico: ClassVar[QLocale.Country] = ...
    Punjabi: ClassVar[QLocale.Language] = ...
    Qatar: ClassVar[QLocale.Country] = ...
    Quechua: ClassVar[QLocale.Language] = ...
    Rejang: ClassVar[QLocale.Language] = ...
    RejangScript: ClassVar[QLocale.Script] = ...
    RejectGroupSeparator: ClassVar[QLocale.NumberOption] = ...
    RejectLeadingZeroInExponent: ClassVar[QLocale.NumberOption] = ...
    RejectTrailingZeroesAfterDot: ClassVar[QLocale.NumberOption] = ...
    RepublicOfKorea: ClassVar[QLocale.Country] = ...
    Reunion: ClassVar[QLocale.Country] = ...
    RhaetoRomance: ClassVar[QLocale.Language] = ...
    Romania: ClassVar[QLocale.Country] = ...
    Romanian: ClassVar[QLocale.Language] = ...
    Romansh: ClassVar[QLocale.Language] = ...
    Rombo: ClassVar[QLocale.Language] = ...
    Rundi: ClassVar[QLocale.Language] = ...
    RunicScript: ClassVar[QLocale.Script] = ...
    Russia: ClassVar[QLocale.Country] = ...
    Russian: ClassVar[QLocale.Language] = ...
    RussianFederation: ClassVar[QLocale.Country] = ...
    Rwa: ClassVar[QLocale.Language] = ...
    Rwanda: ClassVar[QLocale.Country] = ...
    Sabaean: ClassVar[QLocale.Language] = ...
    Saho: ClassVar[QLocale.Language] = ...
    SaintBarthelemy: ClassVar[QLocale.Country] = ...
    SaintHelena: ClassVar[QLocale.Country] = ...
    SaintKittsAndNevis: ClassVar[QLocale.Country] = ...
    SaintLucia: ClassVar[QLocale.Country] = ...
    SaintMartin: ClassVar[QLocale.Country] = ...
    SaintPierreAndMiquelon: ClassVar[QLocale.Country] = ...
    SaintVincentAndTheGrenadines: ClassVar[QLocale.Country] = ...
    Sakha: ClassVar[QLocale.Language] = ...
    Samaritan: ClassVar[QLocale.Language] = ...
    SamaritanScript: ClassVar[QLocale.Script] = ...
    Samburu: ClassVar[QLocale.Language] = ...
    Samoa: ClassVar[QLocale.Country] = ...
    Samoan: ClassVar[QLocale.Language] = ...
    SanMarino: ClassVar[QLocale.Country] = ...
    Sango: ClassVar[QLocale.Language] = ...
    Sangu: ClassVar[QLocale.Language] = ...
    Sanskrit: ClassVar[QLocale.Language] = ...
    Santali: ClassVar[QLocale.Language] = ...
    SaoTomeAndPrincipe: ClassVar[QLocale.Country] = ...
    Saraiki: ClassVar[QLocale.Language] = ...
    Sardinian: ClassVar[QLocale.Language] = ...
    SaudiArabia: ClassVar[QLocale.Country] = ...
    Saurashtra: ClassVar[QLocale.Language] = ...
    SaurashtraScript: ClassVar[QLocale.Script] = ...
    Sena: ClassVar[QLocale.Language] = ...
    Senegal: ClassVar[QLocale.Country] = ...
    Serbia: ClassVar[QLocale.Country] = ...
    Serbian: ClassVar[QLocale.Language] = ...
    SerboCroatian: ClassVar[QLocale.Language] = ...
    Seychelles: ClassVar[QLocale.Country] = ...
    Shambala: ClassVar[QLocale.Language] = ...
    SharadaScript: ClassVar[QLocale.Script] = ...
    ShavianScript: ClassVar[QLocale.Script] = ...
    Shona: ClassVar[QLocale.Language] = ...
    ShortFormat: ClassVar[QLocale.FormatType] = ...
    SichuanYi: ClassVar[QLocale.Language] = ...
    Sicilian: ClassVar[QLocale.Language] = ...
    Sidamo: ClassVar[QLocale.Language] = ...
    SiddhamScript: ClassVar[QLocale.Script] = ...
    SierraLeone: ClassVar[QLocale.Country] = ...
    SignWritingScript: ClassVar[QLocale.Script] = ...
    Silesian: ClassVar[QLocale.Language] = ...
    SimplifiedChineseScript: ClassVar[QLocale.Script] = ...
    SimplifiedHanScript: ClassVar[QLocale.Script] = ...
    Sindhi: ClassVar[QLocale.Language] = ...
    Singapore: ClassVar[QLocale.Country] = ...
    Sinhala: ClassVar[QLocale.Language] = ...
    SinhalaScript: ClassVar[QLocale.Script] = ...
    SintMaarten: ClassVar[QLocale.Country] = ...
    SkoltSami: ClassVar[QLocale.Language] = ...
    Slovak: ClassVar[QLocale.Language] = ...
    Slovakia: ClassVar[QLocale.Country] = ...
    Slovenia: ClassVar[QLocale.Country] = ...
    Slovenian: ClassVar[QLocale.Language] = ...
    Soga: ClassVar[QLocale.Language] = ...
    SolomonIslands: ClassVar[QLocale.Country] = ...
    Somali: ClassVar[QLocale.Language] = ...
    Somalia: ClassVar[QLocale.Country] = ...
    Sora: ClassVar[QLocale.Language] = ...
    SoraSompengScript: ClassVar[QLocale.Script] = ...
    SouthAfrica: ClassVar[QLocale.Country] = ...
    SouthGeorgiaAndTheSouthSandwichIslands: ClassVar[QLocale.Country] = ...
    SouthKorea: ClassVar[QLocale.Country] = ...
    SouthNdebele: ClassVar[QLocale.Language] = ...
    SouthSudan: ClassVar[QLocale.Country] = ...
    SouthernKurdish: ClassVar[QLocale.Language] = ...
    SouthernSami: ClassVar[QLocale.Language] = ...
    SouthernSotho: ClassVar[QLocale.Language] = ...
    Spain: ClassVar[QLocale.Country] = ...
    Spanish: ClassVar[QLocale.Language] = ...
    SriLanka: ClassVar[QLocale.Country] = ...
    StandardMoroccanTamazight: ClassVar[QLocale.Language] = ...
    StandardQuotation: ClassVar[QLocale.QuotationStyle] = ...
    Sudan: ClassVar[QLocale.Country] = ...
    Sundanese: ClassVar[QLocale.Language] = ...
    SundaneseScript: ClassVar[QLocale.Script] = ...
    Suriname: ClassVar[QLocale.Country] = ...
    SvalbardAndJanMayenIslands: ClassVar[QLocale.Country] = ...
    Swahili: ClassVar[QLocale.Language] = ...
    Swati: ClassVar[QLocale.Language] = ...
    Swaziland: ClassVar[QLocale.Country] = ...
    Sweden: ClassVar[QLocale.Country] = ...
    Swedish: ClassVar[QLocale.Language] = ...
    SwissGerman: ClassVar[QLocale.Language] = ...
    Switzerland: ClassVar[QLocale.Country] = ...
    Sylheti: ClassVar[QLocale.Language] = ...
    SylotiNagriScript: ClassVar[QLocale.Script] = ...
    Syria: ClassVar[QLocale.Country] = ...
    Syriac: ClassVar[QLocale.Language] = ...
    SyriacScript: ClassVar[QLocale.Script] = ...
    SyrianArabRepublic: ClassVar[QLocale.Country] = ...
    Tachelhit: ClassVar[QLocale.Language] = ...
    Tagalog: ClassVar[QLocale.Language] = ...
    TagalogScript: ClassVar[QLocale.Script] = ...
    Tagbanwa: ClassVar[QLocale.Language] = ...
    TagbanwaScript: ClassVar[QLocale.Script] = ...
    Tahitian: ClassVar[QLocale.Language] = ...
    TaiDam: ClassVar[QLocale.Language] = ...
    TaiLeScript: ClassVar[QLocale.Script] = ...
    TaiNua: ClassVar[QLocale.Language] = ...
    TaiVietScript: ClassVar[QLocale.Script] = ...
    Taita: ClassVar[QLocale.Language] = ...
    Taiwan: ClassVar[QLocale.Country] = ...
    Tajik: ClassVar[QLocale.Language] = ...
    Tajikistan: ClassVar[QLocale.Country] = ...
    TakriScript: ClassVar[QLocale.Script] = ...
    Tamil: ClassVar[QLocale.Language] = ...
    TamilScript: ClassVar[QLocale.Script] = ...
    Tangut: ClassVar[QLocale.Language] = ...
    TangutScript: ClassVar[QLocale.Script] = ...
    Tanzania: ClassVar[QLocale.Country] = ...
    Taroko: ClassVar[QLocale.Language] = ...
    Tasawaq: ClassVar[QLocale.Language] = ...
    Tatar: ClassVar[QLocale.Language] = ...
    TedimChin: ClassVar[QLocale.Language] = ...
    Telugu: ClassVar[QLocale.Language] = ...
    TeluguScript: ClassVar[QLocale.Script] = ...
    Teso: ClassVar[QLocale.Language] = ...
    ThaanaScript: ClassVar[QLocale.Script] = ...
    Thai: ClassVar[QLocale.Language] = ...
    ThaiScript: ClassVar[QLocale.Script] = ...
    Thailand: ClassVar[QLocale.Country] = ...
    Tibetan: ClassVar[QLocale.Language] = ...
    TibetanScript: ClassVar[QLocale.Script] = ...
    TifinaghScript: ClassVar[QLocale.Script] = ...
    Tigre: ClassVar[QLocale.Language] = ...
    Tigrinya: ClassVar[QLocale.Language] = ...
    TirhutaScript: ClassVar[QLocale.Script] = ...
    Togo: ClassVar[QLocale.Country] = ...
    TokPisin: ClassVar[QLocale.Language] = ...
    Tokelau: ClassVar[QLocale.Country] = ...
    TokelauCountry: ClassVar[QLocale.Country] = ...
    TokelauLanguage: ClassVar[QLocale.Language] = ...
    Tonga: ClassVar[QLocale.Country] = ...
    Tongan: ClassVar[QLocale.Language] = ...
    TraditionalChineseScript: ClassVar[QLocale.Script] = ...
    TraditionalHanScript: ClassVar[QLocale.Script] = ...
    TrinidadAndTobago: ClassVar[QLocale.Country] = ...
    TristanDaCunha: ClassVar[QLocale.Country] = ...
    Tsonga: ClassVar[QLocale.Language] = ...
    Tswana: ClassVar[QLocale.Language] = ...
    Tunisia: ClassVar[QLocale.Country] = ...
    Turkey: ClassVar[QLocale.Country] = ...
    Turkish: ClassVar[QLocale.Language] = ...
    Turkmen: ClassVar[QLocale.Language] = ...
    Turkmenistan: ClassVar[QLocale.Country] = ...
    TurksAndCaicosIslands: ClassVar[QLocale.Country] = ...
    Tuvalu: ClassVar[QLocale.Country] = ...
    TuvaluCountry: ClassVar[QLocale.Country] = ...
    TuvaluLanguage: ClassVar[QLocale.Language] = ...
    Twi: ClassVar[QLocale.Language] = ...
    Tyap: ClassVar[QLocale.Language] = ...
    Uganda: ClassVar[QLocale.Country] = ...
    Ugaritic: ClassVar[QLocale.Language] = ...
    UgariticScript: ClassVar[QLocale.Script] = ...
    Uighur: ClassVar[QLocale.Language] = ...
    Uigur: ClassVar[QLocale.Language] = ...
    Ukraine: ClassVar[QLocale.Country] = ...
    Ukrainian: ClassVar[QLocale.Language] = ...
    UncodedLanguages: ClassVar[QLocale.Language] = ...
    UnitedArabEmirates: ClassVar[QLocale.Country] = ...
    UnitedKingdom: ClassVar[QLocale.Country] = ...
    UnitedStates: ClassVar[QLocale.Country] = ...
    UnitedStatesMinorOutlyingIslands: ClassVar[QLocale.Country] = ...
    UnitedStatesVirginIslands: ClassVar[QLocale.Country] = ...
    UpperSorbian: ClassVar[QLocale.Language] = ...
    Urdu: ClassVar[QLocale.Language] = ...
    Uruguay: ClassVar[QLocale.Country] = ...
    Uzbek: ClassVar[QLocale.Language] = ...
    Uzbekistan: ClassVar[QLocale.Country] = ...
    Vai: ClassVar[QLocale.Language] = ...
    VaiScript: ClassVar[QLocale.Script] = ...
    Vanuatu: ClassVar[QLocale.Country] = ...
    VarangKshitiScript: ClassVar[QLocale.Script] = ...
    VaticanCityState: ClassVar[QLocale.Country] = ...
    Venda: ClassVar[QLocale.Language] = ...
    Venezuela: ClassVar[QLocale.Country] = ...
    Vietnam: ClassVar[QLocale.Country] = ...
    Vietnamese: ClassVar[QLocale.Language] = ...
    Volapuk: ClassVar[QLocale.Language] = ...
    Vunjo: ClassVar[QLocale.Language] = ...
    Walamo: ClassVar[QLocale.Language] = ...
    WallisAndFutunaIslands: ClassVar[QLocale.Country] = ...
    Walloon: ClassVar[QLocale.Language] = ...
    Walser: ClassVar[QLocale.Language] = ...
    Warlpiri: ClassVar[QLocale.Language] = ...
    Welsh: ClassVar[QLocale.Language] = ...
    WesternBalochi: ClassVar[QLocale.Language] = ...
    WesternFrisian: ClassVar[QLocale.Language] = ...
    WesternSahara: ClassVar[QLocale.Country] = ...
    Wolof: ClassVar[QLocale.Language] = ...
    World: ClassVar[QLocale.Country] = ...
    Xhosa: ClassVar[QLocale.Language] = ...
    Yangben: ClassVar[QLocale.Language] = ...
    Yemen: ClassVar[QLocale.Country] = ...
    YiScript: ClassVar[QLocale.Script] = ...
    Yiddish: ClassVar[QLocale.Language] = ...
    Yoruba: ClassVar[QLocale.Language] = ...
    Zambia: ClassVar[QLocale.Country] = ...
    Zarma: ClassVar[QLocale.Language] = ...
    Zhuang: ClassVar[QLocale.Language] = ...
    Zimbabwe: ClassVar[QLocale.Country] = ...
    Zulu: ClassVar[QLocale.Language] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, language: QLocale.Language, country: QLocale.Country = ...) -> None: ...
    @overload
    def __init__(self, language: QLocale.Language, script: QLocale.Script, country: QLocale.Country) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, other: QLocale) -> None: ...
    def amText(self) -> str: ...
    def bcp47Name(self) -> str: ...
    @classmethod
    def c(cls) -> QLocale: ...
    def collation(self) -> QLocale: ...
    @classmethod
    def countriesForLanguage(cls, lang: QLocale.Language) -> typing.List[QLocale.Country]: ...
    def country(self) -> QLocale.Country: ...
    @classmethod
    def countryToString(cls, country: QLocale.Country) -> str: ...
    def createSeparatedList(self, strl: typing.Sequence[str]) -> str: ...
    def currencySymbol(self, arg__1: QLocale.CurrencySymbolFormat = ...) -> str: ...
    def dateFormat(self, format: QLocale.FormatType = ...) -> str: ...
    def dateTimeFormat(self, format: QLocale.FormatType = ...) -> str: ...
    def dayName(self, arg__1: int, format: QLocale.FormatType = ...) -> str: ...
    def decimalPoint(self) -> str: ...
    def exponential(self) -> str: ...
    def firstDayOfWeek(self) -> Qt.DayOfWeek: ...
    def formattedDataSize(self, bytes: int, precision: int = ..., format: typing.Union[QLocale.DataSizeFormats,QLocale.DataSizeFormat] = ...) -> str: ...
    def groupSeparator(self) -> str: ...
    def language(self) -> QLocale.Language: ...
    @classmethod
    def languageToString(cls, language: QLocale.Language) -> str: ...
    @classmethod
    def matchingLocales(cls, language: QLocale.Language, script: QLocale.Script, country: QLocale.Country) -> typing.List[QLocale]: ...
    def measurementSystem(self) -> QLocale.MeasurementSystem: ...
    def monthName(self, arg__1: int, format: QLocale.FormatType = ...) -> str: ...
    def name(self) -> str: ...
    def nativeCountryName(self) -> str: ...
    def nativeLanguageName(self) -> str: ...
    def negativeSign(self) -> str: ...
    def numberOptions(self) -> typing.Union[QLocale.NumberOptions,QLocale.NumberOption]: ...
    def percent(self) -> str: ...
    def pmText(self) -> str: ...
    def positiveSign(self) -> str: ...
    def quoteString(self, str: str, style: QLocale.QuotationStyle = ...) -> str: ...
    def script(self) -> QLocale.Script: ...
    @classmethod
    def scriptToString(cls, script: QLocale.Script) -> str: ...
    @classmethod
    def setDefault(cls, locale: QLocale) -> None: ...
    def setNumberOptions(self, options: typing.Union[QLocale.NumberOptions,QLocale.NumberOption]) -> None: ...
    def standaloneDayName(self, arg__1: int, format: QLocale.FormatType = ...) -> str: ...
    def standaloneMonthName(self, arg__1: int, format: QLocale.FormatType = ...) -> str: ...
    def swap(self, other: QLocale) -> None: ...
    @classmethod
    def system(cls) -> QLocale: ...
    def textDirection(self) -> Qt.LayoutDirection: ...
    def timeFormat(self, format: QLocale.FormatType = ...) -> str: ...
    @overload
    def toCurrencyString(self, arg__1: float, symbol: str, precision: int) -> str: ...
    @overload
    def toCurrencyString(self, arg__1: float, symbol: str = ...) -> str: ...
    @overload
    def toCurrencyString(self, arg__1: int, symbol: str = ...) -> str: ...
    @overload
    def toCurrencyString(self, i: float, symbol: str, precision: int) -> str: ...
    @overload
    def toCurrencyString(self, i: float, symbol: str = ...) -> str: ...
    @overload
    def toDate(self, string: str, format: QLocale.FormatType, cal: QCalendar) -> QDate: ...
    @overload
    def toDate(self, string: str, format: QLocale.FormatType = ...) -> QDate: ...
    @overload
    def toDate(self, string: str, format: str) -> QDate: ...
    @overload
    def toDate(self, string: str, format: str, cal: QCalendar) -> QDate: ...
    @overload
    def toDateTime(self, string: str, format: QLocale.FormatType, cal: QCalendar) -> QDateTime: ...
    @overload
    def toDateTime(self, string: str, format: QLocale.FormatType = ...) -> QDateTime: ...
    @overload
    def toDateTime(self, string: str, format: str) -> QDateTime: ...
    @overload
    def toDateTime(self, string: str, format: str, cal: QCalendar) -> QDateTime: ...
    def toDouble(self, s: str) -> typing.Tuple[float,bool]: ...
    def toFloat(self, s: str) -> typing.Tuple[float,bool]: ...
    def toInt(self, s: str) -> typing.Tuple[int,bool]: ...
    def toLong(self, s: str) -> typing.Tuple[int,bool]: ...
    def toLongLong(self, s: str) -> typing.Tuple[int,bool]: ...
    def toLower(self, str: str) -> str: ...
    def toShort(self, s: str) -> typing.Tuple[int,bool]: ...
    @overload
    def toString(self, date: QDate, format: QLocale.FormatType, cal: QCalendar) -> str: ...
    @overload
    def toString(self, date: QDate, format: QLocale.FormatType = ...) -> str: ...
    @overload
    def toString(self, date: QDate, formatStr: str) -> str: ...
    @overload
    def toString(self, dateTime: QDateTime, format: QLocale.FormatType, cal: QCalendar) -> str: ...
    @overload
    def toString(self, dateTime: QDateTime, format: QLocale.FormatType = ...) -> str: ...
    @overload
    def toString(self, dateTime: QDateTime, format: str) -> str: ...
    @overload
    def toString(self, i: float, f: int = ..., prec: int = ...) -> str: ...
    @overload
    def toString(self, i: int) -> str: ...
    @overload
    def toString(self, time: QTime, format: QLocale.FormatType = ...) -> str: ...
    @overload
    def toString(self, time: QTime, formatStr: str) -> str: ...
    @overload
    def toTime(self, string: str, format: QLocale.FormatType, cal: QCalendar) -> QTime: ...
    @overload
    def toTime(self, string: str, format: QLocale.FormatType = ...) -> QTime: ...
    @overload
    def toTime(self, string: str, format: str) -> QTime: ...
    @overload
    def toTime(self, string: str, format: str, cal: QCalendar) -> QTime: ...
    def toUInt(self, s: str) -> typing.Tuple[int,bool]: ...
    def toULong(self, s: str) -> typing.Tuple[int,bool]: ...
    def toULongLong(self, s: str) -> typing.Tuple[int,bool]: ...
    def toUShort(self, s: str) -> typing.Tuple[int,bool]: ...
    def toUpper(self, str: str) -> str: ...
    def uiLanguages(self) -> typing.List[str]: ...
    def weekdays(self) -> typing.List[Qt.DayOfWeek]: ...
    def zeroDigit(self) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QLockFile(shiboken2.Object):
    class LockError:
        LockFailedError: ClassVar[QLockFile.LockError] = ...
        NoError: ClassVar[QLockFile.LockError] = ...
        PermissionError: ClassVar[QLockFile.LockError] = ...
        UnknownError: ClassVar[QLockFile.LockError] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __and__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __rand__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __rmul__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __ror__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __rsub__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __rxor__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __sub__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
        def __xor__(self, other: typing.SupportsInt) -> QLockFile.LockError: ...
    LockFailedError: ClassVar[QLockFile.LockError] = ...
    NoError: ClassVar[QLockFile.LockError] = ...
    PermissionError: ClassVar[QLockFile.LockError] = ...
    UnknownError: ClassVar[QLockFile.LockError] = ...
    def __init__(self, fileName: str) -> None: ...
    def error(self) -> QLockFile.LockError: ...
    def getLockInfo(self) -> typing.Tuple[bool,int,str,str]: ...
    def isLocked(self) -> bool: ...
    def lock(self) -> bool: ...
    def removeStaleLockFile(self) -> bool: ...
    def setStaleLockTime(self, arg__1: int) -> None: ...
    def staleLockTime(self) -> int: ...
    def tryLock(self, timeout: int = ...) -> bool: ...
    def unlock(self) -> None: ...

class QMargins(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QMargins: QMargins) -> None: ...
    @overload
    def __init__(self, left: int, top: int, right: int, bottom: int) -> None: ...
    def bottom(self) -> int: ...
    def isNull(self) -> bool: ...
    def left(self) -> int: ...
    def right(self) -> int: ...
    def setBottom(self, bottom: int) -> None: ...
    def setLeft(self, left: int) -> None: ...
    def setRight(self, right: int) -> None: ...
    def setTop(self, top: int) -> None: ...
    def top(self) -> int: ...
    @overload
    def __add__(self, lhs: int) -> QMargins: ...
    @overload
    def __add__(self, m2: QMargins) -> QMargins: ...
    @overload
    def __add__(self, rhs: int) -> QMargins: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    @overload
    def __iadd__(self, arg__1: int) -> QMargins: ...
    @overload
    def __iadd__(self, margins: QMargins) -> QMargins: ...
    @overload
    def __imul__(self, arg__1: int) -> QMargins: ...
    @overload
    def __imul__(self, arg__1: float) -> QMargins: ...
    @overload
    def __isub__(self, arg__1: int) -> QMargins: ...
    @overload
    def __isub__(self, margins: QMargins) -> QMargins: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    @overload
    def __mul__(self, factor: int) -> QMargins: ...
    @overload
    def __mul__(self, factor: float) -> QMargins: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> QMargins: ...
    def __pos__(self) -> QMargins: ...
    def __radd__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    @overload
    def __sub__(self, m2: QMargins) -> QMargins: ...
    @overload
    def __sub__(self, rhs: int) -> QMargins: ...
    def __truediv__(self, other) -> Any: ...

class QMarginsF(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QMarginsF: QMarginsF) -> None: ...
    @overload
    def __init__(self, left: float, top: float, right: float, bottom: float) -> None: ...
    @overload
    def __init__(self, margins: QMargins) -> None: ...
    def bottom(self) -> float: ...
    def isNull(self) -> bool: ...
    def left(self) -> float: ...
    def right(self) -> float: ...
    def setBottom(self, bottom: float) -> None: ...
    def setLeft(self, left: float) -> None: ...
    def setRight(self, right: float) -> None: ...
    def setTop(self, top: float) -> None: ...
    def toMargins(self) -> QMargins: ...
    def top(self) -> float: ...
    @overload
    def __add__(self, lhs: float) -> QMarginsF: ...
    @overload
    def __add__(self, rhs: QMarginsF) -> QMarginsF: ...
    @overload
    def __add__(self, rhs: float) -> QMarginsF: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    @overload
    def __iadd__(self, addend: float) -> QMarginsF: ...
    @overload
    def __iadd__(self, margins: QMarginsF) -> QMarginsF: ...
    def __imul__(self, factor: float) -> QMarginsF: ...
    @overload
    def __isub__(self, margins: QMarginsF) -> QMarginsF: ...
    @overload
    def __isub__(self, subtrahend: float) -> QMarginsF: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    @overload
    def __mul__(self, lhs: float) -> QMarginsF: ...
    @overload
    def __mul__(self, rhs: float) -> QMarginsF: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> QMarginsF: ...
    def __pos__(self) -> QMarginsF: ...
    def __radd__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    @overload
    def __sub__(self, rhs: QMarginsF) -> QMarginsF: ...
    @overload
    def __sub__(self, rhs: float) -> QMarginsF: ...
    def __truediv__(self, other) -> Any: ...

class QMessageAuthenticationCode(shiboken2.Object):
    def __init__(self, method: QCryptographicHash.Algorithm, key: typing.Union[QByteArray,bytes] = ...) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def addData(self, data: bytes, length: int) -> None: ...
    @overload
    def addData(self, device: QIODevice) -> bool: ...
    @classmethod
    def hash(cls, message: typing.Union[QByteArray,bytes], key: typing.Union[QByteArray,bytes], method: QCryptographicHash.Algorithm) -> QByteArray: ...
    def reset(self) -> None: ...
    def result(self) -> QByteArray: ...
    def setKey(self, key: typing.Union[QByteArray,bytes]) -> None: ...

class QMessageLogContext(shiboken2.Object):
    category: Any
    file: Any
    function: Any
    line: Any
    version: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fileName: bytes, lineNumber: int, functionName: bytes, categoryName: bytes) -> None: ...

class QMetaClassInfo(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QMetaClassInfo: QMetaClassInfo) -> None: ...
    def name(self) -> bytes: ...
    def value(self) -> bytes: ...
    def __copy__(self) -> None: ...

class QMetaEnum(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QMetaEnum: QMetaEnum) -> None: ...
    def enumName(self) -> bytes: ...
    def isFlag(self) -> bool: ...
    def isScoped(self) -> bool: ...
    def isValid(self) -> bool: ...
    def key(self, index: int) -> bytes: ...
    def keyCount(self) -> int: ...
    def keyToValue(self, key: bytes) -> typing.Tuple[int,bool]: ...
    def keysToValue(self, keys: bytes) -> typing.Tuple[int,bool]: ...
    def name(self) -> bytes: ...
    def scope(self) -> bytes: ...
    def value(self, index: int) -> int: ...
    def valueToKey(self, value: int) -> bytes: ...
    def valueToKeys(self, value: int) -> QByteArray: ...
    def __copy__(self) -> None: ...

class QMetaMethod(shiboken2.Object):
    class Access:
        Private: ClassVar[QMetaMethod.Access] = ...
        Protected: ClassVar[QMetaMethod.Access] = ...
        Public: ClassVar[QMetaMethod.Access] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __and__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __rand__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __rmul__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __ror__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __rsub__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __rxor__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __sub__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...
        def __xor__(self, other: typing.SupportsInt) -> QMetaMethod.Access: ...

    class MethodType:
        Constructor: ClassVar[QMetaMethod.MethodType] = ...
        Method: ClassVar[QMetaMethod.MethodType] = ...
        Signal: ClassVar[QMetaMethod.MethodType] = ...
        Slot: ClassVar[QMetaMethod.MethodType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __and__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __rand__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __ror__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __sub__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
        def __xor__(self, other: typing.SupportsInt) -> QMetaMethod.MethodType: ...
    Constructor: ClassVar[QMetaMethod.MethodType] = ...
    Method: ClassVar[QMetaMethod.MethodType] = ...
    Private: ClassVar[QMetaMethod.Access] = ...
    Protected: ClassVar[QMetaMethod.Access] = ...
    Public: ClassVar[QMetaMethod.Access] = ...
    Signal: ClassVar[QMetaMethod.MethodType] = ...
    Slot: ClassVar[QMetaMethod.MethodType] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QMetaMethod: QMetaMethod) -> None: ...
    def access(self) -> QMetaMethod.Access: ...
    def enclosingMetaObject(self) -> QMetaObject: ...
    @overload
    def invoke(self, object: QObject, connectionType: Qt.ConnectionType, returnValue: QGenericReturnArgument, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @overload
    def invoke(self, object: QObject, connectionType: Qt.ConnectionType, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @overload
    def invoke(self, object: QObject, returnValue: QGenericReturnArgument, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @overload
    def invoke(self, object: QObject, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @overload
    def invokeOnGadget(self, gadget: int, returnValue: QGenericReturnArgument, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @overload
    def invokeOnGadget(self, gadget: int, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    def isValid(self) -> bool: ...
    def methodIndex(self) -> int: ...
    def methodSignature(self) -> QByteArray: ...
    def methodType(self) -> QMetaMethod.MethodType: ...
    def name(self) -> QByteArray: ...
    def parameterCount(self) -> int: ...
    def parameterNames(self) -> typing.List[QByteArray]: ...
    def parameterType(self, index: int) -> int: ...
    def parameterTypes(self) -> typing.List[QByteArray]: ...
    def returnType(self) -> int: ...
    def revision(self) -> int: ...
    def tag(self) -> bytes: ...
    def typeName(self) -> bytes: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QMetaObject(shiboken2.Object):
    class Call:
        CreateInstance: ClassVar[QMetaObject.Call] = ...
        IndexOfMethod: ClassVar[QMetaObject.Call] = ...
        InvokeMetaMethod: ClassVar[QMetaObject.Call] = ...
        QueryPropertyDesignable: ClassVar[QMetaObject.Call] = ...
        QueryPropertyEditable: ClassVar[QMetaObject.Call] = ...
        QueryPropertyScriptable: ClassVar[QMetaObject.Call] = ...
        QueryPropertyStored: ClassVar[QMetaObject.Call] = ...
        QueryPropertyUser: ClassVar[QMetaObject.Call] = ...
        ReadProperty: ClassVar[QMetaObject.Call] = ...
        RegisterMethodArgumentMetaType: ClassVar[QMetaObject.Call] = ...
        RegisterPropertyMetaType: ClassVar[QMetaObject.Call] = ...
        ResetProperty: ClassVar[QMetaObject.Call] = ...
        WriteProperty: ClassVar[QMetaObject.Call] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __and__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __rand__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __rmul__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __ror__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __rsub__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __rxor__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __sub__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...
        def __xor__(self, other: typing.SupportsInt) -> QMetaObject.Call: ...

    class Connection(shiboken2.Object):
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, other: QMetaObject.Connection) -> None: ...
    CreateInstance: ClassVar[QMetaObject.Call] = ...
    IndexOfMethod: ClassVar[QMetaObject.Call] = ...
    InvokeMetaMethod: ClassVar[QMetaObject.Call] = ...
    QueryPropertyDesignable: ClassVar[QMetaObject.Call] = ...
    QueryPropertyEditable: ClassVar[QMetaObject.Call] = ...
    QueryPropertyScriptable: ClassVar[QMetaObject.Call] = ...
    QueryPropertyStored: ClassVar[QMetaObject.Call] = ...
    QueryPropertyUser: ClassVar[QMetaObject.Call] = ...
    ReadProperty: ClassVar[QMetaObject.Call] = ...
    RegisterMethodArgumentMetaType: ClassVar[QMetaObject.Call] = ...
    RegisterPropertyMetaType: ClassVar[QMetaObject.Call] = ...
    ResetProperty: ClassVar[QMetaObject.Call] = ...
    WriteProperty: ClassVar[QMetaObject.Call] = ...
    def __init__(self) -> None: ...
    def cast(self, obj: QObject) -> QObject: ...
    @classmethod
    @overload
    def checkConnectArgs(cls, signal: QMetaMethod, method: QMetaMethod) -> bool: ...
    @classmethod
    @overload
    def checkConnectArgs(cls, signal: bytes, method: bytes) -> bool: ...
    def classInfo(self, index: int) -> QMetaClassInfo: ...
    def classInfoCount(self) -> int: ...
    def classInfoOffset(self) -> int: ...
    def className(self) -> bytes: ...
    @classmethod
    def connectSlotsByName(cls, o: QObject) -> None: ...
    def constructor(self, index: int) -> QMetaMethod: ...
    def constructorCount(self) -> int: ...
    @classmethod
    def disconnect(cls, sender: QObject, signal_index: int, receiver: QObject, method_index: int) -> bool: ...
    @classmethod
    def disconnectOne(cls, sender: QObject, signal_index: int, receiver: QObject, method_index: int) -> bool: ...
    def enumerator(self, index: int) -> QMetaEnum: ...
    def enumeratorCount(self) -> int: ...
    def enumeratorOffset(self) -> int: ...
    def indexOfClassInfo(self, name: bytes) -> int: ...
    def indexOfConstructor(self, constructor: bytes) -> int: ...
    def indexOfEnumerator(self, name: bytes) -> int: ...
    def indexOfMethod(self, method: bytes) -> int: ...
    def indexOfProperty(self, name: bytes) -> int: ...
    def indexOfSignal(self, signal: bytes) -> int: ...
    def indexOfSlot(self, slot: bytes) -> int: ...
    def inherits(self, metaObject: QMetaObject) -> bool: ...
    @classmethod
    @overload
    def invokeMethod(cls, obj: QObject, member: bytes, arg__3: Qt.ConnectionType, ret: QGenericReturnArgument, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @classmethod
    @overload
    def invokeMethod(cls, obj: QObject, member: bytes, ret: QGenericReturnArgument, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @classmethod
    @overload
    def invokeMethod(cls, obj: QObject, member: bytes, type: Qt.ConnectionType, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    @classmethod
    @overload
    def invokeMethod(cls, obj: QObject, member: bytes, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> bool: ...
    def method(self, index: int) -> QMetaMethod: ...
    def methodCount(self) -> int: ...
    def methodOffset(self) -> int: ...
    def newInstance(self, val0: QGenericArgument = ..., val1: QGenericArgument = ..., val2: QGenericArgument = ..., val3: QGenericArgument = ..., val4: QGenericArgument = ..., val5: QGenericArgument = ..., val6: QGenericArgument = ..., val7: QGenericArgument = ..., val8: QGenericArgument = ..., val9: QGenericArgument = ...) -> QObject: ...
    @classmethod
    def normalizedSignature(cls, method: bytes) -> QByteArray: ...
    @classmethod
    def normalizedType(cls, type: bytes) -> QByteArray: ...
    def property(self, index: int) -> QMetaProperty: ...
    def propertyCount(self) -> int: ...
    def propertyOffset(self) -> int: ...
    def superClass(self) -> QMetaObject: ...
    def userProperty(self) -> QMetaProperty: ...

class QMetaProperty(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QMetaProperty: QMetaProperty) -> None: ...
    def enumerator(self) -> QMetaEnum: ...
    def hasNotifySignal(self) -> bool: ...
    def hasStdCppSet(self) -> bool: ...
    def isConstant(self) -> bool: ...
    def isDesignable(self, obj: typing.Union[QObject,None] = ...) -> bool: ...
    def isEditable(self, obj: typing.Union[QObject,None] = ...) -> bool: ...
    def isEnumType(self) -> bool: ...
    def isFinal(self) -> bool: ...
    def isFlagType(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isRequired(self) -> bool: ...
    def isResettable(self) -> bool: ...
    def isScriptable(self, obj: typing.Union[QObject,None] = ...) -> bool: ...
    def isStored(self, obj: typing.Union[QObject,None] = ...) -> bool: ...
    def isUser(self, obj: typing.Union[QObject,None] = ...) -> bool: ...
    def isValid(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def name(self) -> bytes: ...
    def notifySignal(self) -> QMetaMethod: ...
    def notifySignalIndex(self) -> int: ...
    def propertyIndex(self) -> int: ...
    def read(self, obj: QObject) -> typing.Any: ...
    def readOnGadget(self, gadget: int) -> typing.Any: ...
    def relativePropertyIndex(self) -> int: ...
    def reset(self, obj: QObject) -> bool: ...
    def resetOnGadget(self, gadget: int) -> bool: ...
    def revision(self) -> int: ...
    def type(self) -> type: ...
    def typeName(self) -> bytes: ...
    def userType(self) -> int: ...
    def write(self, obj: QObject, value: typing.Any) -> bool: ...
    def writeOnGadget(self, gadget: int, value: typing.Any) -> bool: ...
    def __copy__(self) -> None: ...

class QMimeData(QObject):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def clear(self) -> None: ...
    def colorData(self) -> typing.Any: ...
    def data(self, mimetype: str) -> QByteArray: ...
    def formats(self) -> typing.List[str]: ...
    def hasColor(self) -> bool: ...
    def hasFormat(self, mimetype: str) -> bool: ...
    def hasHtml(self) -> bool: ...
    def hasImage(self) -> bool: ...
    def hasText(self) -> bool: ...
    def hasUrls(self) -> bool: ...
    def html(self) -> str: ...
    def imageData(self) -> typing.Any: ...
    def removeFormat(self, mimetype: str) -> None: ...
    def retrieveData(self, mimetype: str, preferredType: type) -> typing.Any: ...
    def setColorData(self, color: typing.Any) -> None: ...
    def setData(self, mimetype: str, data: typing.Union[QByteArray,bytes]) -> None: ...
    def setHtml(self, html: str) -> None: ...
    def setImageData(self, image: typing.Any) -> None: ...
    def setText(self, text: str) -> None: ...
    def setUrls(self, urls: typing.Sequence[QUrl]) -> None: ...
    def text(self) -> str: ...
    def urls(self) -> typing.List[QUrl]: ...

class QMimeDatabase(shiboken2.Object):
    class MatchMode:
        MatchContent: ClassVar[QMimeDatabase.MatchMode] = ...
        MatchDefault: ClassVar[QMimeDatabase.MatchMode] = ...
        MatchExtension: ClassVar[QMimeDatabase.MatchMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __and__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QMimeDatabase.MatchMode: ...
    MatchContent: ClassVar[QMimeDatabase.MatchMode] = ...
    MatchDefault: ClassVar[QMimeDatabase.MatchMode] = ...
    MatchExtension: ClassVar[QMimeDatabase.MatchMode] = ...
    def __init__(self) -> None: ...
    def allMimeTypes(self) -> typing.List[QMimeType]: ...
    @overload
    def mimeTypeForData(self, data: typing.Union[QByteArray,bytes]) -> QMimeType: ...
    @overload
    def mimeTypeForData(self, device: QIODevice) -> QMimeType: ...
    @overload
    def mimeTypeForFile(self, fileInfo: QFileInfo, mode: QMimeDatabase.MatchMode = ...) -> QMimeType: ...
    @overload
    def mimeTypeForFile(self, fileName: str, mode: QMimeDatabase.MatchMode = ...) -> QMimeType: ...
    @overload
    def mimeTypeForFileNameAndData(self, fileName: str, data: typing.Union[QByteArray,bytes]) -> QMimeType: ...
    @overload
    def mimeTypeForFileNameAndData(self, fileName: str, device: QIODevice) -> QMimeType: ...
    def mimeTypeForName(self, nameOrAlias: str) -> QMimeType: ...
    def mimeTypeForUrl(self, url: QUrl) -> QMimeType: ...
    def mimeTypesForFileName(self, fileName: str) -> typing.List[QMimeType]: ...
    def suffixForFileName(self, fileName: str) -> str: ...

class QMimeType(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QMimeType) -> None: ...
    def aliases(self) -> typing.List[str]: ...
    def allAncestors(self) -> typing.List[str]: ...
    def comment(self) -> str: ...
    def filterString(self) -> str: ...
    def genericIconName(self) -> str: ...
    def globPatterns(self) -> typing.List[str]: ...
    def iconName(self) -> str: ...
    def inherits(self, mimeTypeName: str) -> bool: ...
    def isDefault(self) -> bool: ...
    def isValid(self) -> bool: ...
    def name(self) -> str: ...
    def parentMimeTypes(self) -> typing.List[str]: ...
    def preferredSuffix(self) -> str: ...
    def suffixes(self) -> typing.List[str]: ...
    def swap(self, other: QMimeType) -> None: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QModelIndex(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QModelIndex: QModelIndex) -> None: ...
    def child(self, row: int, column: int) -> QModelIndex: ...
    def column(self) -> int: ...
    def data(self, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def flags(self) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def internalId(self) -> int: ...
    def internalPointer(self) -> typing.Any: ...
    def isValid(self) -> bool: ...
    def model(self) -> QAbstractItemModel: ...
    def parent(self) -> QModelIndex: ...
    def row(self) -> int: ...
    def sibling(self, row: int, column: int) -> QModelIndex: ...
    def siblingAtColumn(self, column: int) -> QModelIndex: ...
    def siblingAtRow(self, row: int) -> QModelIndex: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QMutex(QBasicMutex):
    class RecursionMode:
        NonRecursive: ClassVar[QMutex.RecursionMode] = ...
        Recursive: ClassVar[QMutex.RecursionMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __and__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QMutex.RecursionMode: ...
    NonRecursive: ClassVar[QMutex.RecursionMode] = ...
    Recursive: ClassVar[QMutex.RecursionMode] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mode: QMutex.RecursionMode) -> None: ...
    def isRecursive(self) -> bool: ...
    def lock(self) -> None: ...
    def tryLock(self, timeout: int = ...) -> bool: ...
    def try_lock(self) -> bool: ...
    def unlock(self) -> None: ...

class QMutexLocker(shiboken2.Object):
    @overload
    def __init__(self, m: QBasicMutex) -> None: ...
    @overload
    def __init__(self, m: QRecursiveMutex) -> None: ...
    def mutex(self) -> QMutex: ...
    def relock(self) -> None: ...
    def unlock(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, arg__1: object, arg__2: object, arg__3: object) -> None: ...

class QObject(shiboken2.Object):
    destroyed: ClassVar[Signal] = ...
    objectNameChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def blockSignals(self, b: bool) -> bool: ...
    def childEvent(self, event: QChildEvent) -> None: ...
    def children(self) -> typing.List[QObject]: ...
    @classmethod
    @overload
    def connect(cls, arg__1: QObject, arg__2: bytes, arg__3: typing.Callable, type: Qt.ConnectionType = ...) -> bool: ...
    @classmethod
    @overload
    def connect(cls, self, arg__1: bytes, arg__2: typing.Callable, type: Qt.ConnectionType = ...) -> bool: ...
    @classmethod
    @overload
    def connect(cls, self, arg__1: bytes, arg__2: QObject, arg__3: bytes, type: Qt.ConnectionType = ...) -> bool: ...
    @classmethod
    @overload
    def connect(cls, self, sender: QObject, signal: bytes, member: bytes, type: Qt.ConnectionType = ...) -> QMetaObject.Connection: ...
    @classmethod
    @overload
    def connect(cls, sender: QObject, signal: QMetaMethod, receiver: QObject, method: QMetaMethod, type: Qt.ConnectionType = ...) -> QMetaObject.Connection: ...
    @classmethod
    @overload
    def connect(cls, sender: QObject, signal: bytes, receiver: QObject, member: bytes, type: Qt.ConnectionType = ...) -> QMetaObject.Connection: ...
    def connectNotify(self, signal: QMetaMethod) -> None: ...
    def customEvent(self, event: QEvent) -> None: ...
    def deleteLater(self) -> None: ...
    @classmethod
    @overload
    def disconnect(cls, arg__1: QMetaObject.Connection) -> bool: ...
    @classmethod
    @overload
    def disconnect(cls, arg__1: QObject, arg__2: bytes, arg__3: typing.Callable) -> bool: ...
    @classmethod
    @overload
    def disconnect(cls, self, arg__1: bytes, arg__2: typing.Callable) -> bool: ...
    @classmethod
    @overload
    def disconnect(cls, self, receiver: QObject, member: typing.Union[bytes,None] = ...) -> bool: ...
    @classmethod
    @overload
    def disconnect(cls, self, signal: bytes, receiver: QObject, member: bytes) -> bool: ...
    @classmethod
    @overload
    def disconnect(cls, sender: QObject, signal: QMetaMethod, receiver: QObject, member: QMetaMethod) -> bool: ...
    @classmethod
    @overload
    def disconnect(cls, sender: QObject, signal: bytes, receiver: QObject, member: bytes) -> bool: ...
    def disconnectNotify(self, signal: QMetaMethod) -> None: ...
    def dumpObjectInfo(self) -> None: ...
    def dumpObjectTree(self) -> None: ...
    def dynamicPropertyNames(self) -> typing.List[QByteArray]: ...
    def emit(self, arg__1: bytes, *args: None) -> bool: ...
    def event(self, event: QEvent) -> bool: ...
    def eventFilter(self, watched: QObject, event: QEvent) -> bool: ...
    def findChild(self, arg__1: typing.Type[T], arg__2: str = ...) -> T: ...
    def findChildren(self, arg__1: typing.Type[T], arg__2: QRegExp) -> typing.Iterable[T]: ...
    def inherits(self, classname: bytes) -> bool: ...
    def installEventFilter(self, filterObj: QObject) -> None: ...
    def isSignalConnected(self, signal: QMetaMethod) -> bool: ...
    def isWidgetType(self) -> bool: ...
    def isWindowType(self) -> bool: ...
    def killTimer(self, id: int) -> None: ...
    def metaObject(self) -> QMetaObject: ...
    def moveToThread(self, thread: QThread) -> None: ...
    def objectName(self) -> str: ...
    def parent(self) -> QObject: ...
    def property(self, name: str) -> typing.Any: ...
    def receivers(self, signal: bytes) -> int: ...
    @classmethod
    def registerUserData(cls) -> int: ...
    def removeEventFilter(self, obj: QObject) -> None: ...
    def sender(self) -> QObject: ...
    def senderSignalIndex(self) -> int: ...
    def setObjectName(self, name: str) -> None: ...
    def setParent(self, parent: typing.Optional[QObject]) -> None: ...
    def setProperty(self, name: str, value: typing.Any) -> bool: ...
    def signalsBlocked(self) -> bool: ...
    def startTimer(self, interval: int, timerType: Qt.TimerType = ...) -> int: ...
    def thread(self) -> QThread: ...
    def timerEvent(self, event: QTimerEvent) -> None: ...
    def tr(self, arg__1: bytes, arg__2: bytes = ..., arg__3: int = ...) -> str: ...

class QOperatingSystemVersion(shiboken2.Object):
    class OSType:
        Android: ClassVar[QOperatingSystemVersion.OSType] = ...
        IOS: ClassVar[QOperatingSystemVersion.OSType] = ...
        MacOS: ClassVar[QOperatingSystemVersion.OSType] = ...
        TvOS: ClassVar[QOperatingSystemVersion.OSType] = ...
        Unknown: ClassVar[QOperatingSystemVersion.OSType] = ...
        WatchOS: ClassVar[QOperatingSystemVersion.OSType] = ...
        Windows: ClassVar[QOperatingSystemVersion.OSType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __and__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __rand__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __ror__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __sub__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
        def __xor__(self, other: typing.SupportsInt) -> QOperatingSystemVersion.OSType: ...
    Android: ClassVar[QOperatingSystemVersion.OSType] = ...
    AndroidJellyBean: ClassVar[QOperatingSystemVersion] = ...
    AndroidJellyBean_MR1: ClassVar[QOperatingSystemVersion] = ...
    AndroidJellyBean_MR2: ClassVar[QOperatingSystemVersion] = ...
    AndroidKitKat: ClassVar[QOperatingSystemVersion] = ...
    AndroidLollipop: ClassVar[QOperatingSystemVersion] = ...
    AndroidLollipop_MR1: ClassVar[QOperatingSystemVersion] = ...
    AndroidMarshmallow: ClassVar[QOperatingSystemVersion] = ...
    AndroidNougat: ClassVar[QOperatingSystemVersion] = ...
    AndroidNougat_MR1: ClassVar[QOperatingSystemVersion] = ...
    AndroidOreo: ClassVar[QOperatingSystemVersion] = ...
    IOS: ClassVar[QOperatingSystemVersion.OSType] = ...
    MacOS: ClassVar[QOperatingSystemVersion.OSType] = ...
    MacOSBigSur: ClassVar[QOperatingSystemVersion] = ...
    MacOSCatalina: ClassVar[QOperatingSystemVersion] = ...
    MacOSHighSierra: ClassVar[QOperatingSystemVersion] = ...
    MacOSMojave: ClassVar[QOperatingSystemVersion] = ...
    MacOSSierra: ClassVar[QOperatingSystemVersion] = ...
    OSXElCapitan: ClassVar[QOperatingSystemVersion] = ...
    OSXMavericks: ClassVar[QOperatingSystemVersion] = ...
    OSXYosemite: ClassVar[QOperatingSystemVersion] = ...
    TvOS: ClassVar[QOperatingSystemVersion.OSType] = ...
    Unknown: ClassVar[QOperatingSystemVersion.OSType] = ...
    WatchOS: ClassVar[QOperatingSystemVersion.OSType] = ...
    Windows: ClassVar[QOperatingSystemVersion.OSType] = ...
    Windows10: ClassVar[QOperatingSystemVersion] = ...
    Windows7: ClassVar[QOperatingSystemVersion] = ...
    Windows8: ClassVar[QOperatingSystemVersion] = ...
    Windows8_1: ClassVar[QOperatingSystemVersion] = ...
    @overload
    def __init__(self, QOperatingSystemVersion: QOperatingSystemVersion) -> None: ...
    @overload
    def __init__(self, osType: QOperatingSystemVersion.OSType, vmajor: int, vminor: int = ..., vmicro: int = ...) -> None: ...
    @classmethod
    def current(cls) -> QOperatingSystemVersion: ...
    @classmethod
    def currentType(cls) -> QOperatingSystemVersion.OSType: ...
    def majorVersion(self) -> int: ...
    def microVersion(self) -> int: ...
    def minorVersion(self) -> int: ...
    def name(self) -> str: ...
    def segmentCount(self) -> int: ...
    def type(self) -> QOperatingSystemVersion.OSType: ...
    def __copy__(self) -> None: ...

class QParallelAnimationGroup(QAnimationGroup):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., destroyed: typing.Callable = ..., direction: QParallelAnimationGroup.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., state: QParallelAnimationGroup.State = ..., stateChanged: typing.Callable = ...) -> None: ...
    def duration(self) -> int: ...
    def event(self, event: QEvent) -> bool: ...
    def updateCurrentTime(self, currentTime: int) -> None: ...
    def updateDirection(self, direction: QAbstractAnimation.Direction) -> None: ...
    def updateState(self, newState: QAbstractAnimation.State, oldState: QAbstractAnimation.State) -> None: ...

class QPauseAnimation(QAbstractAnimation):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, msecs: int, parent: typing.Union[QObject,None] = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., destroyed: typing.Callable = ..., direction: QPauseAnimation.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., state: QPauseAnimation.State = ..., stateChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., destroyed: typing.Callable = ..., direction: QPauseAnimation.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., state: QPauseAnimation.State = ..., stateChanged: typing.Callable = ...) -> None: ...
    def duration(self) -> int: ...
    def event(self, e: QEvent) -> bool: ...
    def setDuration(self, msecs: int) -> None: ...
    def updateCurrentTime(self, arg__1: int) -> None: ...

class QPersistentModelIndex(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, index: QModelIndex) -> None: ...
    @overload
    def __init__(self, other: QPersistentModelIndex) -> None: ...
    def child(self, row: int, column: int) -> QModelIndex: ...
    def column(self) -> int: ...
    def data(self, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def flags(self) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def internalId(self) -> int: ...
    def internalPointer(self) -> typing.Any: ...
    def isValid(self) -> bool: ...
    def model(self) -> QAbstractItemModel: ...
    def parent(self) -> QModelIndex: ...
    def row(self) -> int: ...
    def sibling(self, row: int, column: int) -> QModelIndex: ...
    def swap(self, other: QPersistentModelIndex) -> None: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QPluginLoader(QObject):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, fileName: str, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., loadHints: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., fileName: str = ..., loadHints: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def errorString(self) -> str: ...
    def fileName(self) -> str: ...
    def instance(self) -> QObject: ...
    def isLoaded(self) -> bool: ...
    def load(self) -> bool: ...
    def metaData(self) -> typing.Dict[str,QJsonValue]: ...
    def setFileName(self, fileName: str) -> None: ...
    @classmethod
    def staticInstances(cls) -> typing.List[QObject]: ...
    def unload(self) -> bool: ...

class QPoint(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QPoint: QPoint) -> None: ...
    @overload
    def __init__(self, xpos: int, ypos: int) -> None: ...
    @classmethod
    def dotProduct(cls, p1: QPoint, p2: QPoint) -> int: ...
    def isNull(self) -> bool: ...
    def manhattanLength(self) -> int: ...
    def setX(self, x: int) -> None: ...
    def setY(self, y: int) -> None: ...
    def toTuple(self) -> object: ...
    def transposed(self) -> QPoint: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def __add__(self, p2: QPoint) -> QPoint: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, p: QPoint) -> QPoint: ...
    @overload
    def __imul__(self, factor: float) -> QPoint: ...
    @overload
    def __imul__(self, factor: int) -> QPoint: ...
    def __isub__(self, p: QPoint) -> QPoint: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    @overload
    def __mul__(self, factor: float) -> QPoint: ...
    @overload
    def __mul__(self, factor: int) -> QPoint: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> QPoint: ...
    def __pos__(self) -> QPoint: ...
    def __radd__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __sub__(self, p2: QPoint) -> QPoint: ...
    def __truediv__(self, other) -> Any: ...

class QPointF(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QPointF: QPointF) -> None: ...
    @overload
    def __init__(self, p: QPoint) -> None: ...
    @overload
    def __init__(self, xpos: float, ypos: float) -> None: ...
    @classmethod
    def dotProduct(cls, p1: QPointF, p2: QPointF) -> float: ...
    def isNull(self) -> bool: ...
    def manhattanLength(self) -> float: ...
    def setX(self, x: float) -> None: ...
    def setY(self, y: float) -> None: ...
    def toPoint(self) -> QPoint: ...
    def toTuple(self) -> object: ...
    def transposed(self) -> QPointF: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def __add__(self, p2: QPointF) -> QPointF: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, p: QPointF) -> QPointF: ...
    def __imul__(self, c: float) -> QPointF: ...
    def __isub__(self, p: QPointF) -> QPointF: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, c: float) -> QPointF: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> QPointF: ...
    def __pos__(self) -> QPointF: ...
    def __radd__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __sub__(self, p2: QPointF) -> QPointF: ...
    def __truediv__(self, other) -> Any: ...

class QProcess(QIODevice):
    class ExitStatus:
        CrashExit: ClassVar[QProcess.ExitStatus] = ...
        NormalExit: ClassVar[QProcess.ExitStatus] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __and__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __rand__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __rmul__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __ror__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __rsub__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __rxor__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __sub__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...
        def __xor__(self, other: typing.SupportsInt) -> QProcess.ExitStatus: ...

    class InputChannelMode:
        ForwardedInputChannel: ClassVar[QProcess.InputChannelMode] = ...
        ManagedInputChannel: ClassVar[QProcess.InputChannelMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __and__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QProcess.InputChannelMode: ...

    class ProcessChannel:
        StandardError: ClassVar[QProcess.ProcessChannel] = ...
        StandardOutput: ClassVar[QProcess.ProcessChannel] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __and__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __rand__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __rmul__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __ror__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __rsub__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __rxor__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __sub__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...
        def __xor__(self, other: typing.SupportsInt) -> QProcess.ProcessChannel: ...

    class ProcessChannelMode:
        ForwardedChannels: ClassVar[QProcess.ProcessChannelMode] = ...
        ForwardedErrorChannel: ClassVar[QProcess.ProcessChannelMode] = ...
        ForwardedOutputChannel: ClassVar[QProcess.ProcessChannelMode] = ...
        MergedChannels: ClassVar[QProcess.ProcessChannelMode] = ...
        SeparateChannels: ClassVar[QProcess.ProcessChannelMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __and__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QProcess.ProcessChannelMode: ...

    class ProcessError:
        Crashed: ClassVar[QProcess.ProcessError] = ...
        FailedToStart: ClassVar[QProcess.ProcessError] = ...
        ReadError: ClassVar[QProcess.ProcessError] = ...
        Timedout: ClassVar[QProcess.ProcessError] = ...
        UnknownError: ClassVar[QProcess.ProcessError] = ...
        WriteError: ClassVar[QProcess.ProcessError] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __and__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __rand__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __rmul__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __ror__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __rsub__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __rxor__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __sub__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...
        def __xor__(self, other: typing.SupportsInt) -> QProcess.ProcessError: ...

    class ProcessState:
        NotRunning: ClassVar[QProcess.ProcessState] = ...
        Running: ClassVar[QProcess.ProcessState] = ...
        Starting: ClassVar[QProcess.ProcessState] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __and__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __rand__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __rmul__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __ror__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __rsub__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __rxor__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __sub__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
        def __xor__(self, other: typing.SupportsInt) -> QProcess.ProcessState: ...
    CrashExit: ClassVar[QProcess.ExitStatus] = ...
    Crashed: ClassVar[QProcess.ProcessError] = ...
    FailedToStart: ClassVar[QProcess.ProcessError] = ...
    ForwardedChannels: ClassVar[QProcess.ProcessChannelMode] = ...
    ForwardedErrorChannel: ClassVar[QProcess.ProcessChannelMode] = ...
    ForwardedInputChannel: ClassVar[QProcess.InputChannelMode] = ...
    ForwardedOutputChannel: ClassVar[QProcess.ProcessChannelMode] = ...
    ManagedInputChannel: ClassVar[QProcess.InputChannelMode] = ...
    MergedChannels: ClassVar[QProcess.ProcessChannelMode] = ...
    NormalExit: ClassVar[QProcess.ExitStatus] = ...
    NotRunning: ClassVar[QProcess.ProcessState] = ...
    ReadError: ClassVar[QProcess.ProcessError] = ...
    Running: ClassVar[QProcess.ProcessState] = ...
    SeparateChannels: ClassVar[QProcess.ProcessChannelMode] = ...
    StandardError: ClassVar[QProcess.ProcessChannel] = ...
    StandardOutput: ClassVar[QProcess.ProcessChannel] = ...
    Starting: ClassVar[QProcess.ProcessState] = ...
    Timedout: ClassVar[QProcess.ProcessError] = ...
    UnknownError: ClassVar[QProcess.ProcessError] = ...
    WriteError: ClassVar[QProcess.ProcessError] = ...
    error: ClassVar[Signal] = ...
    errorOccurred: ClassVar[Signal] = ...
    finished: ClassVar[Signal] = ...
    readyReadStandardError: ClassVar[Signal] = ...
    readyReadStandardOutput: ClassVar[Signal] = ...
    started: ClassVar[Signal] = ...
    stateChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., error: typing.Callable = ..., errorOccurred: typing.Callable = ..., finished: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ..., readyReadStandardError: typing.Callable = ..., readyReadStandardOutput: typing.Callable = ..., started: typing.Callable = ..., stateChanged: typing.Callable = ...) -> None: ...
    def arguments(self) -> typing.List[str]: ...
    def atEnd(self) -> bool: ...
    def bytesAvailable(self) -> int: ...
    def bytesToWrite(self) -> int: ...
    def canReadLine(self) -> bool: ...
    def close(self) -> None: ...
    def closeReadChannel(self, channel: QProcess.ProcessChannel) -> None: ...
    def closeWriteChannel(self) -> None: ...
    def environment(self) -> typing.List[str]: ...
    @classmethod
    @overload
    def execute(cls, command: str) -> int: ...
    @classmethod
    @overload
    def execute(cls, program: str, arguments: typing.Sequence[str]) -> int: ...
    def exitCode(self) -> int: ...
    def exitStatus(self) -> QProcess.ExitStatus: ...
    def inputChannelMode(self) -> QProcess.InputChannelMode: ...
    def isSequential(self) -> bool: ...
    def kill(self) -> None: ...
    @classmethod
    def nullDevice(cls) -> str: ...
    def open(self, mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> bool: ...
    def pid(self) -> int: ...
    def processChannelMode(self) -> QProcess.ProcessChannelMode: ...
    def processEnvironment(self) -> QProcessEnvironment: ...
    def processId(self) -> int: ...
    def program(self) -> str: ...
    def readAllStandardError(self) -> QByteArray: ...
    def readAllStandardOutput(self) -> QByteArray: ...
    def readChannel(self) -> QProcess.ProcessChannel: ...
    def readData(self, data: bytes, maxlen: int) -> int: ...
    def setArguments(self, arguments: typing.Sequence[str]) -> None: ...
    def setEnvironment(self, environment: typing.Sequence[str]) -> None: ...
    def setInputChannelMode(self, mode: QProcess.InputChannelMode) -> None: ...
    def setProcessChannelMode(self, mode: QProcess.ProcessChannelMode) -> None: ...
    def setProcessEnvironment(self, environment: QProcessEnvironment) -> None: ...
    def setProcessState(self, state: QProcess.ProcessState) -> None: ...
    def setProgram(self, program: str) -> None: ...
    def setReadChannel(self, channel: QProcess.ProcessChannel) -> None: ...
    def setStandardErrorFile(self, fileName: str, mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> None: ...
    def setStandardInputFile(self, fileName: str) -> None: ...
    def setStandardOutputFile(self, fileName: str, mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> None: ...
    def setStandardOutputProcess(self, destination: QProcess) -> None: ...
    def setWorkingDirectory(self, dir: str) -> None: ...
    def setupChildProcess(self) -> None: ...
    @overload
    def start(self, command: str, mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> None: ...
    @overload
    def start(self, mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> None: ...
    @overload
    def start(self, program: str, arguments: typing.Sequence[str], mode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> None: ...
    @classmethod
    @overload
    def startDetached(cls, command: str) -> bool: ...
    @classmethod
    @overload
    def startDetached(cls, program: str, arguments: typing.Sequence[str]) -> bool: ...
    @classmethod
    @overload
    def startDetached(cls, program: str, arguments: typing.Sequence[str], workingDirectory: str) -> typing.Tuple[bool,int]: ...
    @classmethod
    @overload
    def startDetached(cls, self) -> typing.Tuple[bool,int]: ...
    def state(self) -> QProcess.ProcessState: ...
    @classmethod
    def systemEnvironment(cls) -> typing.List[str]: ...
    def terminate(self) -> None: ...
    def waitForBytesWritten(self, msecs: int = ...) -> bool: ...
    def waitForFinished(self, msecs: int = ...) -> bool: ...
    def waitForReadyRead(self, msecs: int = ...) -> bool: ...
    def waitForStarted(self, msecs: int = ...) -> bool: ...
    def workingDirectory(self) -> str: ...
    def writeData(self, data: bytes, len: int) -> int: ...

class QProcessEnvironment(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QProcessEnvironment) -> None: ...
    def clear(self) -> None: ...
    def contains(self, name: str) -> bool: ...
    @overload
    def insert(self, e: QProcessEnvironment) -> None: ...
    @overload
    def insert(self, name: str, value: str) -> None: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> typing.List[str]: ...
    def remove(self, name: str) -> None: ...
    def swap(self, other: QProcessEnvironment) -> None: ...
    @classmethod
    def systemEnvironment(cls) -> QProcessEnvironment: ...
    def toStringList(self) -> typing.List[str]: ...
    def value(self, name: str, defaultValue: str = ...) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QPropertyAnimation(QVariantAnimation):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., currentValue: object = ..., destroyed: typing.Callable = ..., direction: QPropertyAnimation.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., easingCurve: QEasingCurve = ..., endValue: object = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., propertyName: str = ..., startValue: object = ..., state: QPropertyAnimation.State = ..., stateChanged: typing.Callable = ..., targetObject: QObject = ..., valueChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, target: QObject, propertyName: str, parent: typing.Union[QObject,None] = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., currentValue: object = ..., destroyed: typing.Callable = ..., direction: QPropertyAnimation.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., easingCurve: QEasingCurve = ..., endValue: object = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., startValue: object = ..., state: QPropertyAnimation.State = ..., stateChanged: typing.Callable = ..., targetObject: QObject = ..., valueChanged: typing.Callable = ...) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def propertyName(self) -> str: ...
    def setPropertyName(self, propertyName: str) -> None: ...
    def setTargetObject(self, target: QObject) -> None: ...
    def targetObject(self) -> QObject: ...
    def updateCurrentValue(self, value: typing.Any) -> None: ...
    def updateState(self, newState: QAbstractAnimation.State, oldState: QAbstractAnimation.State) -> None: ...

class QRandomGenerator(shiboken2.Object):
    @overload
    def __init__(self, begin: int, end: int) -> None: ...
    @overload
    def __init__(self, other: QRandomGenerator) -> None: ...
    @overload
    def __init__(self, seedBuffer: int, len: int) -> None: ...
    @overload
    def __init__(self, seedValue: int = ...) -> None: ...
    @overload
    def bounded(self, highest: float) -> float: ...
    @overload
    def bounded(self, highest: int) -> int: ...
    @overload
    def bounded(self, lowest: int, highest: int) -> int: ...
    def discard(self, z: int) -> None: ...
    def generate(self) -> int: ...
    def generate64(self) -> int: ...
    def generateDouble(self) -> float: ...
    @classmethod
    def global_(cls) -> QRandomGenerator: ...
    @classmethod
    def max(cls) -> int: ...
    @classmethod
    def min(cls) -> int: ...
    @classmethod
    def securelySeeded(cls) -> QRandomGenerator: ...
    def seed(self, s: int = ...) -> None: ...
    @classmethod
    def system(cls) -> QRandomGenerator: ...

class QRandomGenerator64(QRandomGenerator):
    @overload
    def __init__(self, begin: int, end: int) -> None: ...
    @overload
    def __init__(self, other: QRandomGenerator) -> None: ...
    @overload
    def __init__(self, seedBuffer: int, len: int) -> None: ...
    @overload
    def __init__(self, seedValue: int = ...) -> None: ...
    def discard(self, z: int) -> None: ...
    def generate(self) -> int: ...
    @classmethod
    def global_(cls) -> QRandomGenerator64: ...
    @classmethod
    def max(cls) -> int: ...
    @classmethod
    def min(cls) -> int: ...
    @classmethod
    def securelySeeded(cls) -> QRandomGenerator64: ...
    @classmethod
    def system(cls) -> QRandomGenerator64: ...

class QReadLocker(shiboken2.Object):
    def __init__(self, readWriteLock: QReadWriteLock) -> None: ...
    def readWriteLock(self) -> QReadWriteLock: ...
    def relock(self) -> None: ...
    def unlock(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, arg__1: object, arg__2: object, arg__3: object) -> None: ...

class QReadWriteLock(shiboken2.Object):
    class RecursionMode:
        NonRecursive: ClassVar[QReadWriteLock.RecursionMode] = ...
        Recursive: ClassVar[QReadWriteLock.RecursionMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __and__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QReadWriteLock.RecursionMode: ...
    NonRecursive: ClassVar[QReadWriteLock.RecursionMode] = ...
    Recursive: ClassVar[QReadWriteLock.RecursionMode] = ...
    def __init__(self, recursionMode: QReadWriteLock.RecursionMode = ...) -> None: ...
    def lockForRead(self) -> None: ...
    def lockForWrite(self) -> None: ...
    @overload
    def tryLockForRead(self) -> bool: ...
    @overload
    def tryLockForRead(self, timeout: int) -> bool: ...
    @overload
    def tryLockForWrite(self) -> bool: ...
    @overload
    def tryLockForWrite(self, timeout: int) -> bool: ...
    def unlock(self) -> None: ...

class QRect(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QRect: QRect) -> None: ...
    @overload
    def __init__(self, left: int, top: int, width: int, height: int) -> None: ...
    @overload
    def __init__(self, topleft: QPoint, bottomright: QPoint) -> None: ...
    @overload
    def __init__(self, topleft: QPoint, size: QSize) -> None: ...
    def adjust(self, x1: int, y1: int, x2: int, y2: int) -> None: ...
    def adjusted(self, x1: int, y1: int, x2: int, y2: int) -> QRect: ...
    def bottom(self) -> int: ...
    def bottomLeft(self) -> QPoint: ...
    def bottomRight(self) -> QPoint: ...
    def center(self) -> QPoint: ...
    @overload
    def contains(self, p: QPoint, proper: bool = ...) -> bool: ...
    @overload
    def contains(self, r: QRect, proper: bool = ...) -> bool: ...
    @overload
    def contains(self, x: int, y: int) -> bool: ...
    @overload
    def contains(self, x: int, y: int, proper: bool) -> bool: ...
    def getCoords(self) -> typing.Tuple[int,int,int,int]: ...
    def getRect(self) -> typing.Tuple[int,int,int,int]: ...
    def height(self) -> int: ...
    def intersected(self, other: QRect) -> QRect: ...
    def intersects(self, r: QRect) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isValid(self) -> bool: ...
    def left(self) -> int: ...
    def marginsAdded(self, margins: QMargins) -> QRect: ...
    def marginsRemoved(self, margins: QMargins) -> QRect: ...
    def moveBottom(self, pos: int) -> None: ...
    def moveBottomLeft(self, p: QPoint) -> None: ...
    def moveBottomRight(self, p: QPoint) -> None: ...
    def moveCenter(self, p: QPoint) -> None: ...
    def moveLeft(self, pos: int) -> None: ...
    def moveRight(self, pos: int) -> None: ...
    @overload
    def moveTo(self, p: QPoint) -> None: ...
    @overload
    def moveTo(self, x: int, t: int) -> None: ...
    def moveTop(self, pos: int) -> None: ...
    def moveTopLeft(self, p: QPoint) -> None: ...
    def moveTopRight(self, p: QPoint) -> None: ...
    def normalized(self) -> QRect: ...
    def right(self) -> int: ...
    def setBottom(self, pos: int) -> None: ...
    def setBottomLeft(self, p: QPoint) -> None: ...
    def setBottomRight(self, p: QPoint) -> None: ...
    def setCoords(self, x1: int, y1: int, x2: int, y2: int) -> None: ...
    def setHeight(self, h: int) -> None: ...
    def setLeft(self, pos: int) -> None: ...
    def setRect(self, x: int, y: int, w: int, h: int) -> None: ...
    def setRight(self, pos: int) -> None: ...
    def setSize(self, s: QSize) -> None: ...
    def setTop(self, pos: int) -> None: ...
    def setTopLeft(self, p: QPoint) -> None: ...
    def setTopRight(self, p: QPoint) -> None: ...
    def setWidth(self, w: int) -> None: ...
    def setX(self, x: int) -> None: ...
    def setY(self, y: int) -> None: ...
    def size(self) -> QSize: ...
    def top(self) -> int: ...
    def topLeft(self) -> QPoint: ...
    def topRight(self) -> QPoint: ...
    @overload
    def translate(self, dx: int, dy: int) -> None: ...
    @overload
    def translate(self, p: QPoint) -> None: ...
    @overload
    def translated(self, dx: int, dy: int) -> QRect: ...
    @overload
    def translated(self, p: QPoint) -> QRect: ...
    def transposed(self) -> QRect: ...
    def united(self, other: QRect) -> QRect: ...
    def width(self) -> int: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def __add__(self, margins: QMargins) -> QRect: ...
    def __and__(self, r: QRect) -> QRect: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, margins: QMargins) -> QRect: ...
    def __iand__(self, r: QRect) -> QRect: ...
    def __ior__(self, r: QRect) -> QRect: ...
    def __isub__(self, margins: QMargins) -> QRect: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, r: QRect) -> QRect: ...
    def __radd__(self, other) -> Any: ...
    def __rand__(self, other) -> Any: ...
    def __ror__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __sub__(self, rhs: QMargins) -> QRect: ...

class QRectF(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QRectF: QRectF) -> None: ...
    @overload
    def __init__(self, left: float, top: float, width: float, height: float) -> None: ...
    @overload
    def __init__(self, rect: QRect) -> None: ...
    @overload
    def __init__(self, topleft: QPointF, bottomRight: QPointF) -> None: ...
    @overload
    def __init__(self, topleft: QPointF, size: QSizeF) -> None: ...
    def adjust(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    def adjusted(self, x1: float, y1: float, x2: float, y2: float) -> QRectF: ...
    def bottom(self) -> float: ...
    def bottomLeft(self) -> QPointF: ...
    def bottomRight(self) -> QPointF: ...
    def center(self) -> QPointF: ...
    @overload
    def contains(self, p: QPointF) -> bool: ...
    @overload
    def contains(self, r: QRectF) -> bool: ...
    @overload
    def contains(self, x: float, y: float) -> bool: ...
    def getCoords(self) -> typing.Tuple[float,float,float,float]: ...
    def getRect(self) -> typing.Tuple[float,float,float,float]: ...
    def height(self) -> float: ...
    def intersected(self, other: QRectF) -> QRectF: ...
    def intersects(self, r: QRectF) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isValid(self) -> bool: ...
    def left(self) -> float: ...
    def marginsAdded(self, margins: QMarginsF) -> QRectF: ...
    def marginsRemoved(self, margins: QMarginsF) -> QRectF: ...
    def moveBottom(self, pos: float) -> None: ...
    def moveBottomLeft(self, p: QPointF) -> None: ...
    def moveBottomRight(self, p: QPointF) -> None: ...
    def moveCenter(self, p: QPointF) -> None: ...
    def moveLeft(self, pos: float) -> None: ...
    def moveRight(self, pos: float) -> None: ...
    @overload
    def moveTo(self, p: QPointF) -> None: ...
    @overload
    def moveTo(self, x: float, y: float) -> None: ...
    def moveTop(self, pos: float) -> None: ...
    def moveTopLeft(self, p: QPointF) -> None: ...
    def moveTopRight(self, p: QPointF) -> None: ...
    def normalized(self) -> QRectF: ...
    def right(self) -> float: ...
    def setBottom(self, pos: float) -> None: ...
    def setBottomLeft(self, p: QPointF) -> None: ...
    def setBottomRight(self, p: QPointF) -> None: ...
    def setCoords(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    def setHeight(self, h: float) -> None: ...
    def setLeft(self, pos: float) -> None: ...
    def setRect(self, x: float, y: float, w: float, h: float) -> None: ...
    def setRight(self, pos: float) -> None: ...
    def setSize(self, s: QSizeF) -> None: ...
    def setTop(self, pos: float) -> None: ...
    def setTopLeft(self, p: QPointF) -> None: ...
    def setTopRight(self, p: QPointF) -> None: ...
    def setWidth(self, w: float) -> None: ...
    def setX(self, pos: float) -> None: ...
    def setY(self, pos: float) -> None: ...
    def size(self) -> QSizeF: ...
    def toAlignedRect(self) -> QRect: ...
    def toRect(self) -> QRect: ...
    def top(self) -> float: ...
    def topLeft(self) -> QPointF: ...
    def topRight(self) -> QPointF: ...
    @overload
    def translate(self, dx: float, dy: float) -> None: ...
    @overload
    def translate(self, p: QPointF) -> None: ...
    @overload
    def translated(self, dx: float, dy: float) -> QRectF: ...
    @overload
    def translated(self, p: QPointF) -> QRectF: ...
    def transposed(self) -> QRectF: ...
    def united(self, other: QRectF) -> QRectF: ...
    def width(self) -> float: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    @overload
    def __add__(self, lhs: QMarginsF) -> QRectF: ...
    @overload
    def __add__(self, rhs: QMarginsF) -> QRectF: ...
    def __and__(self, r: QRectF) -> QRectF: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, margins: QMarginsF) -> QRectF: ...
    def __iand__(self, r: QRectF) -> QRectF: ...
    def __ior__(self, r: QRectF) -> QRectF: ...
    def __isub__(self, margins: QMarginsF) -> QRectF: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, r: QRectF) -> QRectF: ...
    def __radd__(self, other) -> Any: ...
    def __rand__(self, other) -> Any: ...
    def __ror__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __sub__(self, rhs: QMarginsF) -> QRectF: ...

class QRecursiveMutex(shiboken2.Object):
    def __init__(self) -> None: ...

class QRegExp(shiboken2.Object):
    class CaretMode:
        CaretAtOffset: ClassVar[QRegExp.CaretMode] = ...
        CaretAtZero: ClassVar[QRegExp.CaretMode] = ...
        CaretWontMatch: ClassVar[QRegExp.CaretMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __and__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegExp.CaretMode: ...

    class PatternSyntax:
        FixedString: ClassVar[QRegExp.PatternSyntax] = ...
        RegExp: ClassVar[QRegExp.PatternSyntax] = ...
        RegExp2: ClassVar[QRegExp.PatternSyntax] = ...
        W3CXmlSchema11: ClassVar[QRegExp.PatternSyntax] = ...
        Wildcard: ClassVar[QRegExp.PatternSyntax] = ...
        WildcardUnix: ClassVar[QRegExp.PatternSyntax] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __and__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __rmul__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __rsub__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __sub__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegExp.PatternSyntax: ...
    CaretAtOffset: ClassVar[QRegExp.CaretMode] = ...
    CaretAtZero: ClassVar[QRegExp.CaretMode] = ...
    CaretWontMatch: ClassVar[QRegExp.CaretMode] = ...
    FixedString: ClassVar[QRegExp.PatternSyntax] = ...
    RegExp: ClassVar[QRegExp.PatternSyntax] = ...
    RegExp2: ClassVar[QRegExp.PatternSyntax] = ...
    W3CXmlSchema11: ClassVar[QRegExp.PatternSyntax] = ...
    Wildcard: ClassVar[QRegExp.PatternSyntax] = ...
    WildcardUnix: ClassVar[QRegExp.PatternSyntax] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pattern: str, cs: Qt.CaseSensitivity = ..., syntax: QRegExp.PatternSyntax = ...) -> None: ...
    @overload
    def __init__(self, rx: QRegExp) -> None: ...
    def cap(self, nth: int = ...) -> str: ...
    def captureCount(self) -> int: ...
    def capturedTexts(self) -> typing.List[str]: ...
    def caseSensitivity(self) -> Qt.CaseSensitivity: ...
    def errorString(self) -> str: ...
    @classmethod
    def escape(cls, str: str) -> str: ...
    def exactMatch(self, str: str) -> bool: ...
    def indexIn(self, str: str, offset: int = ..., caretMode: QRegExp.CaretMode = ...) -> int: ...
    def isEmpty(self) -> bool: ...
    def isMinimal(self) -> bool: ...
    def isValid(self) -> bool: ...
    def lastIndexIn(self, str: str, offset: int = ..., caretMode: QRegExp.CaretMode = ...) -> int: ...
    def matchedLength(self) -> int: ...
    def pattern(self) -> str: ...
    def patternSyntax(self) -> QRegExp.PatternSyntax: ...
    def pos(self, nth: int = ...) -> int: ...
    def replace(self, sourceString: str, after: str) -> str: ...
    def setCaseSensitivity(self, cs: Qt.CaseSensitivity) -> None: ...
    def setMinimal(self, minimal: bool) -> None: ...
    def setPattern(self, pattern: str) -> None: ...
    def setPatternSyntax(self, syntax: QRegExp.PatternSyntax) -> None: ...
    def swap(self, other: QRegExp) -> None: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QRegularExpression(shiboken2.Object):
    class MatchOption:
        AnchoredMatchOption: ClassVar[QRegularExpression.MatchOption] = ...
        DontCheckSubjectStringMatchOption: ClassVar[QRegularExpression.MatchOption] = ...
        NoMatchOption: ClassVar[QRegularExpression.MatchOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QRegularExpression.MatchOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...

    class MatchOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QRegularExpression.MatchOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegularExpression.MatchOptions: ...

    class MatchType:
        NoMatch: ClassVar[QRegularExpression.MatchType] = ...
        NormalMatch: ClassVar[QRegularExpression.MatchType] = ...
        PartialPreferCompleteMatch: ClassVar[QRegularExpression.MatchType] = ...
        PartialPreferFirstMatch: ClassVar[QRegularExpression.MatchType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __and__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __sub__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegularExpression.MatchType: ...

    class PatternOption:
        CaseInsensitiveOption: ClassVar[QRegularExpression.PatternOption] = ...
        DontAutomaticallyOptimizeOption: ClassVar[QRegularExpression.PatternOption] = ...
        DontCaptureOption: ClassVar[QRegularExpression.PatternOption] = ...
        DotMatchesEverythingOption: ClassVar[QRegularExpression.PatternOption] = ...
        ExtendedPatternSyntaxOption: ClassVar[QRegularExpression.PatternOption] = ...
        InvertedGreedinessOption: ClassVar[QRegularExpression.PatternOption] = ...
        MultilineOption: ClassVar[QRegularExpression.PatternOption] = ...
        NoPatternOption: ClassVar[QRegularExpression.PatternOption] = ...
        OptimizeOnFirstUsageOption: ClassVar[QRegularExpression.PatternOption] = ...
        UseUnicodePropertiesOption: ClassVar[QRegularExpression.PatternOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QRegularExpression.PatternOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...

    class PatternOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QRegularExpression.PatternOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QRegularExpression.PatternOptions: ...
    AnchoredMatchOption: ClassVar[QRegularExpression.MatchOption] = ...
    CaseInsensitiveOption: ClassVar[QRegularExpression.PatternOption] = ...
    DontAutomaticallyOptimizeOption: ClassVar[QRegularExpression.PatternOption] = ...
    DontCaptureOption: ClassVar[QRegularExpression.PatternOption] = ...
    DontCheckSubjectStringMatchOption: ClassVar[QRegularExpression.MatchOption] = ...
    DotMatchesEverythingOption: ClassVar[QRegularExpression.PatternOption] = ...
    ExtendedPatternSyntaxOption: ClassVar[QRegularExpression.PatternOption] = ...
    InvertedGreedinessOption: ClassVar[QRegularExpression.PatternOption] = ...
    MultilineOption: ClassVar[QRegularExpression.PatternOption] = ...
    NoMatch: ClassVar[QRegularExpression.MatchType] = ...
    NoMatchOption: ClassVar[QRegularExpression.MatchOption] = ...
    NoPatternOption: ClassVar[QRegularExpression.PatternOption] = ...
    NormalMatch: ClassVar[QRegularExpression.MatchType] = ...
    OptimizeOnFirstUsageOption: ClassVar[QRegularExpression.PatternOption] = ...
    PartialPreferCompleteMatch: ClassVar[QRegularExpression.MatchType] = ...
    PartialPreferFirstMatch: ClassVar[QRegularExpression.MatchType] = ...
    UseUnicodePropertiesOption: ClassVar[QRegularExpression.PatternOption] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pattern: str, options: typing.Union[QRegularExpression.PatternOptions,QRegularExpression.PatternOption] = ...) -> None: ...
    @overload
    def __init__(self, re: QRegularExpression) -> None: ...
    @classmethod
    def anchoredPattern(cls, expression: str) -> str: ...
    def captureCount(self) -> int: ...
    def errorString(self) -> str: ...
    @classmethod
    def escape(cls, str: str) -> str: ...
    @overload
    def globalMatch(self, subject: str, offset: int = ..., matchType: QRegularExpression.MatchType = ..., matchOptions: typing.Union[QRegularExpression.MatchOptions,QRegularExpression.MatchOption] = ...) -> QRegularExpressionMatchIterator: ...
    @overload
    def globalMatch(self, subjectRef: str, offset: int = ..., matchType: QRegularExpression.MatchType = ..., matchOptions: typing.Union[QRegularExpression.MatchOptions,QRegularExpression.MatchOption] = ...) -> QRegularExpressionMatchIterator: ...
    def isValid(self) -> bool: ...
    @overload
    def match(self, subject: str, offset: int = ..., matchType: QRegularExpression.MatchType = ..., matchOptions: typing.Union[QRegularExpression.MatchOptions,QRegularExpression.MatchOption] = ...) -> QRegularExpressionMatch: ...
    @overload
    def match(self, subjectRef: str, offset: int = ..., matchType: QRegularExpression.MatchType = ..., matchOptions: typing.Union[QRegularExpression.MatchOptions,QRegularExpression.MatchOption] = ...) -> QRegularExpressionMatch: ...
    def namedCaptureGroups(self) -> typing.List[str]: ...
    def optimize(self) -> None: ...
    def pattern(self) -> str: ...
    def patternErrorOffset(self) -> int: ...
    def patternOptions(self) -> typing.Union[QRegularExpression.PatternOptions,QRegularExpression.PatternOption]: ...
    def setPattern(self, pattern: str) -> None: ...
    def setPatternOptions(self, options: typing.Union[QRegularExpression.PatternOptions,QRegularExpression.PatternOption]) -> None: ...
    def swap(self, other: QRegularExpression) -> None: ...
    @classmethod
    def wildcardToRegularExpression(cls, str: str) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QRegularExpressionMatch(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, match: QRegularExpressionMatch) -> None: ...
    @overload
    def captured(self, name: str) -> str: ...
    @overload
    def captured(self, nth: int = ...) -> str: ...
    @overload
    def capturedEnd(self, name: str) -> int: ...
    @overload
    def capturedEnd(self, nth: int = ...) -> int: ...
    @overload
    def capturedLength(self, name: str) -> int: ...
    @overload
    def capturedLength(self, nth: int = ...) -> int: ...
    @overload
    def capturedRef(self, name: str) -> str: ...
    @overload
    def capturedRef(self, nth: int = ...) -> str: ...
    @overload
    def capturedStart(self, name: str) -> int: ...
    @overload
    def capturedStart(self, nth: int = ...) -> int: ...
    def capturedTexts(self) -> typing.List[str]: ...
    def hasMatch(self) -> bool: ...
    def hasPartialMatch(self) -> bool: ...
    def isValid(self) -> bool: ...
    def lastCapturedIndex(self) -> int: ...
    def matchOptions(self) -> typing.Union[QRegularExpression.MatchOptions,QRegularExpression.MatchOption]: ...
    def matchType(self) -> QRegularExpression.MatchType: ...
    def regularExpression(self) -> QRegularExpression: ...
    def swap(self, other: QRegularExpressionMatch) -> None: ...
    def __copy__(self) -> None: ...

class QRegularExpressionMatchIterator(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterator: QRegularExpressionMatchIterator) -> None: ...
    def hasNext(self) -> bool: ...
    def isValid(self) -> bool: ...
    def matchOptions(self) -> typing.Union[QRegularExpression.MatchOptions,QRegularExpression.MatchOption]: ...
    def matchType(self) -> QRegularExpression.MatchType: ...
    def next(self) -> QRegularExpressionMatch: ...
    def peekNext(self) -> QRegularExpressionMatch: ...
    def regularExpression(self) -> QRegularExpression: ...
    def swap(self, other: QRegularExpressionMatchIterator) -> None: ...
    def __copy__(self) -> None: ...

class QResource(shiboken2.Object):
    class Compression:
        NoCompression: ClassVar[QResource.Compression] = ...
        ZlibCompression: ClassVar[QResource.Compression] = ...
        ZstdCompression: ClassVar[QResource.Compression] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __and__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __rand__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __rmul__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __ror__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __rsub__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __rxor__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __sub__(self, other: typing.SupportsInt) -> QResource.Compression: ...
        def __xor__(self, other: typing.SupportsInt) -> QResource.Compression: ...
    NoCompression: ClassVar[QResource.Compression] = ...
    ZlibCompression: ClassVar[QResource.Compression] = ...
    ZstdCompression: ClassVar[QResource.Compression] = ...
    def __init__(self, file: str = ..., locale: QLocale = ...) -> None: ...
    def absoluteFilePath(self) -> str: ...
    @classmethod
    def addSearchPath(cls, path: str) -> None: ...
    def children(self) -> typing.List[str]: ...
    def compressionAlgorithm(self) -> QResource.Compression: ...
    def data(self) -> bytes: ...
    def fileName(self) -> str: ...
    def isCompressed(self) -> bool: ...
    def isDir(self) -> bool: ...
    def isFile(self) -> bool: ...
    def isValid(self) -> bool: ...
    def lastModified(self) -> QDateTime: ...
    def locale(self) -> QLocale: ...
    @classmethod
    def registerResource(cls, rccFilename: str, resourceRoot: str = ...) -> bool: ...
    @classmethod
    def registerResourceData(cls, rccData: bytes, resourceRoot: str = ...) -> bool: ...
    @classmethod
    def searchPaths(cls) -> typing.List[str]: ...
    def setFileName(self, file: str) -> None: ...
    def setLocale(self, locale: QLocale) -> None: ...
    def size(self) -> int: ...
    def uncompressedData(self) -> QByteArray: ...
    def uncompressedSize(self) -> int: ...
    @classmethod
    def unregisterResource(cls, rccFilename: str, resourceRoot: str = ...) -> bool: ...
    @classmethod
    def unregisterResourceData(cls, rccData: bytes, resourceRoot: str = ...) -> bool: ...

class QRunnable(shiboken2.Object):
    def __init__(self) -> None: ...
    def autoDelete(self) -> bool: ...
    def run(self) -> None: ...
    def setAutoDelete(self, _autoDelete: bool) -> None: ...

class QSaveFile(QFileDevice):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, name: str, aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, name: str, parent: typing.Optional[QObject], aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    def cancelWriting(self) -> None: ...
    def close(self) -> None: ...
    def commit(self) -> bool: ...
    def directWriteFallback(self) -> bool: ...
    def fileName(self) -> str: ...
    def open(self, flags: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> bool: ...
    def setDirectWriteFallback(self, enabled: bool) -> None: ...
    def setFileName(self, name: str) -> None: ...
    def writeData(self, data: bytes, len: int) -> int: ...

class QSemaphore(shiboken2.Object):
    def __init__(self, n: int = ...) -> None: ...
    def acquire(self, n: int = ...) -> None: ...
    def available(self) -> int: ...
    def release(self, n: int = ...) -> None: ...
    @overload
    def tryAcquire(self, n: int, timeout: int) -> bool: ...
    @overload
    def tryAcquire(self, n: int = ...) -> bool: ...

class QSemaphoreReleaser(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sem: QSemaphore, n: int = ...) -> None: ...
    def cancel(self) -> QSemaphore: ...
    def semaphore(self) -> QSemaphore: ...
    def swap(self, other: QSemaphoreReleaser) -> None: ...

class QSequentialAnimationGroup(QAnimationGroup):
    currentAnimationChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., currentAnimation: QAbstractAnimation = ..., currentAnimationChanged: typing.Callable = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., destroyed: typing.Callable = ..., direction: QSequentialAnimationGroup.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., state: QSequentialAnimationGroup.State = ..., stateChanged: typing.Callable = ...) -> None: ...
    def addPause(self, msecs: int) -> QPauseAnimation: ...
    def currentAnimation(self) -> QAbstractAnimation: ...
    def duration(self) -> int: ...
    def event(self, event: QEvent) -> bool: ...
    def insertPause(self, index: int, msecs: int) -> QPauseAnimation: ...
    def updateCurrentTime(self, arg__1: int) -> None: ...
    def updateDirection(self, direction: QAbstractAnimation.Direction) -> None: ...
    def updateState(self, newState: QAbstractAnimation.State, oldState: QAbstractAnimation.State) -> None: ...

class QSettings(QObject):
    class Format:
        CustomFormat1: ClassVar[QSettings.Format] = ...
        CustomFormat10: ClassVar[QSettings.Format] = ...
        CustomFormat11: ClassVar[QSettings.Format] = ...
        CustomFormat12: ClassVar[QSettings.Format] = ...
        CustomFormat13: ClassVar[QSettings.Format] = ...
        CustomFormat14: ClassVar[QSettings.Format] = ...
        CustomFormat15: ClassVar[QSettings.Format] = ...
        CustomFormat16: ClassVar[QSettings.Format] = ...
        CustomFormat2: ClassVar[QSettings.Format] = ...
        CustomFormat3: ClassVar[QSettings.Format] = ...
        CustomFormat4: ClassVar[QSettings.Format] = ...
        CustomFormat5: ClassVar[QSettings.Format] = ...
        CustomFormat6: ClassVar[QSettings.Format] = ...
        CustomFormat7: ClassVar[QSettings.Format] = ...
        CustomFormat8: ClassVar[QSettings.Format] = ...
        CustomFormat9: ClassVar[QSettings.Format] = ...
        IniFormat: ClassVar[QSettings.Format] = ...
        InvalidFormat: ClassVar[QSettings.Format] = ...
        NativeFormat: ClassVar[QSettings.Format] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __and__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __rand__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __ror__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __sub__(self, other: typing.SupportsInt) -> QSettings.Format: ...
        def __xor__(self, other: typing.SupportsInt) -> QSettings.Format: ...

    class Scope:
        SystemScope: ClassVar[QSettings.Scope] = ...
        UserScope: ClassVar[QSettings.Scope] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __and__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __rand__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __ror__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __sub__(self, other: typing.SupportsInt) -> QSettings.Scope: ...
        def __xor__(self, other: typing.SupportsInt) -> QSettings.Scope: ...

    class Status:
        AccessError: ClassVar[QSettings.Status] = ...
        FormatError: ClassVar[QSettings.Status] = ...
        NoError: ClassVar[QSettings.Status] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __and__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __rand__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __ror__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __sub__(self, other: typing.SupportsInt) -> QSettings.Status: ...
        def __xor__(self, other: typing.SupportsInt) -> QSettings.Status: ...
    AccessError: ClassVar[QSettings.Status] = ...
    CustomFormat1: ClassVar[QSettings.Format] = ...
    CustomFormat10: ClassVar[QSettings.Format] = ...
    CustomFormat11: ClassVar[QSettings.Format] = ...
    CustomFormat12: ClassVar[QSettings.Format] = ...
    CustomFormat13: ClassVar[QSettings.Format] = ...
    CustomFormat14: ClassVar[QSettings.Format] = ...
    CustomFormat15: ClassVar[QSettings.Format] = ...
    CustomFormat16: ClassVar[QSettings.Format] = ...
    CustomFormat2: ClassVar[QSettings.Format] = ...
    CustomFormat3: ClassVar[QSettings.Format] = ...
    CustomFormat4: ClassVar[QSettings.Format] = ...
    CustomFormat5: ClassVar[QSettings.Format] = ...
    CustomFormat6: ClassVar[QSettings.Format] = ...
    CustomFormat7: ClassVar[QSettings.Format] = ...
    CustomFormat8: ClassVar[QSettings.Format] = ...
    CustomFormat9: ClassVar[QSettings.Format] = ...
    FormatError: ClassVar[QSettings.Status] = ...
    IniFormat: ClassVar[QSettings.Format] = ...
    InvalidFormat: ClassVar[QSettings.Format] = ...
    NativeFormat: ClassVar[QSettings.Format] = ...
    NoError: ClassVar[QSettings.Status] = ...
    SystemScope: ClassVar[QSettings.Scope] = ...
    UserScope: ClassVar[QSettings.Scope] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, fileName: str, format: QSettings.Format, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, format: QSettings.Format, scope: QSettings.Scope, organization: str, application: str = ..., parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, organization: str, application: str = ..., parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, scope: QSettings.Scope, organization: str, application: str = ..., parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, scope: QSettings.Scope, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def allKeys(self) -> typing.List[str]: ...
    def applicationName(self) -> str: ...
    def beginGroup(self, prefix: str) -> None: ...
    def beginReadArray(self, prefix: str) -> int: ...
    def beginWriteArray(self, prefix: str, size: int = ...) -> None: ...
    def childGroups(self) -> typing.List[str]: ...
    def childKeys(self) -> typing.List[str]: ...
    def clear(self) -> None: ...
    def contains(self, key: str) -> bool: ...
    @classmethod
    def defaultFormat(cls) -> QSettings.Format: ...
    def endArray(self) -> None: ...
    def endGroup(self) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def fallbacksEnabled(self) -> bool: ...
    def fileName(self) -> str: ...
    def format(self) -> QSettings.Format: ...
    def group(self) -> str: ...
    def iniCodec(self) -> QTextCodec: ...
    def isAtomicSyncRequired(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def organizationName(self) -> str: ...
    def remove(self, key: str) -> None: ...
    def scope(self) -> QSettings.Scope: ...
    def setArrayIndex(self, i: int) -> None: ...
    def setAtomicSyncRequired(self, enable: bool) -> None: ...
    @classmethod
    def setDefaultFormat(cls, format: QSettings.Format) -> None: ...
    def setFallbacksEnabled(self, b: bool) -> None: ...
    @overload
    def setIniCodec(self, codec: QTextCodec) -> None: ...
    @overload
    def setIniCodec(self, codecName: bytes) -> None: ...
    @classmethod
    def setPath(cls, format: QSettings.Format, scope: QSettings.Scope, path: str) -> None: ...
    def setValue(self, key: str, value: typing.Any) -> None: ...
    def status(self) -> QSettings.Status: ...
    def sync(self) -> None: ...
    def value(self, arg__1: str, defaultValue: typing.Union[typing.Any,None] = ..., type: typing.Union[typing.Any,None] = ...) -> typing.Any: ...

class QSignalBlocker(shiboken2.Object):
    def __init__(self, o: QObject) -> None: ...
    def reblock(self) -> None: ...
    def unblock(self) -> None: ...

class QSignalMapper(QObject):
    mapped: ClassVar[Signal] = ...
    mappedInt: ClassVar[Signal] = ...
    mappedObject: ClassVar[Signal] = ...
    mappedString: ClassVar[Signal] = ...
    mappedWidget: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., mapped: typing.Callable = ..., mappedInt: typing.Callable = ..., mappedObject: typing.Callable = ..., mappedString: typing.Callable = ..., mappedWidget: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def map(self) -> None: ...
    @overload
    def map(self, sender: QObject) -> None: ...
    @overload
    def mapping(self, id: int) -> QObject: ...
    @overload
    def mapping(self, object: QObject) -> QObject: ...
    @overload
    def mapping(self, text: str) -> QObject: ...
    def removeMappings(self, sender: QObject) -> None: ...
    @overload
    def setMapping(self, sender: QObject, id: int) -> None: ...
    @overload
    def setMapping(self, sender: QObject, object: QObject) -> None: ...
    @overload
    def setMapping(self, sender: QObject, text: str) -> None: ...

class QSignalTransition(QAbstractTransition):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, arg__1: object, arg__2: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., senderObject: QObject = ..., senderObjectChanged: typing.Callable = ..., signal: typing.Union[QByteArray,bytes] = ..., signalChanged: typing.Callable = ..., sourceState: typing.Any = ..., targetState: typing.Any = ..., targetStateChanged: typing.Callable = ..., targetStates: typing.Any = ..., targetStatesChanged: typing.Callable = ..., transitionType: QSignalTransition.TransitionType = ..., triggered: typing.Callable = ...) -> QSignalTransition: ...
    @overload
    def __init__(self, sender: QObject, signal: bytes, sourceState: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., senderObject: QObject = ..., senderObjectChanged: typing.Callable = ..., signalChanged: typing.Callable = ..., targetState: typing.Any = ..., targetStateChanged: typing.Callable = ..., targetStates: typing.Any = ..., targetStatesChanged: typing.Callable = ..., transitionType: QSignalTransition.TransitionType = ..., triggered: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, sourceState: typing.Union[QState,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., senderObject: QObject = ..., senderObjectChanged: typing.Callable = ..., signal: typing.Union[QByteArray,bytes] = ..., signalChanged: typing.Callable = ..., targetState: typing.Any = ..., targetStateChanged: typing.Callable = ..., targetStates: typing.Any = ..., targetStatesChanged: typing.Callable = ..., transitionType: QSignalTransition.TransitionType = ..., triggered: typing.Callable = ...) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def eventTest(self, event: QEvent) -> bool: ...
    def onTransition(self, event: QEvent) -> None: ...
    def senderObject(self) -> QObject: ...
    def setSenderObject(self, sender: QObject) -> None: ...
    def setSignal(self, signal: typing.Union[QByteArray,bytes]) -> None: ...
    def signal(self) -> QByteArray: ...

class QSize(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QSize: QSize) -> None: ...
    @overload
    def __init__(self, w: int, h: int) -> None: ...
    def boundedTo(self, arg__1: QSize) -> QSize: ...
    def expandedTo(self, arg__1: QSize) -> QSize: ...
    def grownBy(self, m: QMargins) -> QSize: ...
    def height(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isValid(self) -> bool: ...
    @overload
    def scale(self, s: QSize, mode: Qt.AspectRatioMode) -> None: ...
    @overload
    def scale(self, w: int, h: int, mode: Qt.AspectRatioMode) -> None: ...
    @overload
    def scaled(self, s: QSize, mode: Qt.AspectRatioMode) -> QSize: ...
    @overload
    def scaled(self, w: int, h: int, mode: Qt.AspectRatioMode) -> QSize: ...
    def setHeight(self, h: int) -> None: ...
    def setWidth(self, w: int) -> None: ...
    def shrunkBy(self, m: QMargins) -> QSize: ...
    def toTuple(self) -> object: ...
    def transpose(self) -> None: ...
    def transposed(self) -> QSize: ...
    def width(self) -> int: ...
    def __add__(self, s2: QSize) -> QSize: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg__1: QSize) -> QSize: ...
    def __imul__(self, c: float) -> QSize: ...
    def __isub__(self, arg__1: QSize) -> QSize: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, c: float) -> QSize: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __sub__(self, s2: QSize) -> QSize: ...
    def __truediv__(self, other) -> Any: ...

class QSizeF(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QSizeF: QSizeF) -> None: ...
    @overload
    def __init__(self, sz: QSize) -> None: ...
    @overload
    def __init__(self, w: float, h: float) -> None: ...
    def boundedTo(self, arg__1: QSizeF) -> QSizeF: ...
    def expandedTo(self, arg__1: QSizeF) -> QSizeF: ...
    def grownBy(self, m: QMarginsF) -> QSizeF: ...
    def height(self) -> float: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isValid(self) -> bool: ...
    @overload
    def scale(self, s: QSizeF, mode: Qt.AspectRatioMode) -> None: ...
    @overload
    def scale(self, w: float, h: float, mode: Qt.AspectRatioMode) -> None: ...
    @overload
    def scaled(self, s: QSizeF, mode: Qt.AspectRatioMode) -> QSizeF: ...
    @overload
    def scaled(self, w: float, h: float, mode: Qt.AspectRatioMode) -> QSizeF: ...
    def setHeight(self, h: float) -> None: ...
    def setWidth(self, w: float) -> None: ...
    def shrunkBy(self, m: QMarginsF) -> QSizeF: ...
    def toSize(self) -> QSize: ...
    def toTuple(self) -> object: ...
    def transpose(self) -> None: ...
    def transposed(self) -> QSizeF: ...
    def width(self) -> float: ...
    def __add__(self, s2: QSizeF) -> QSizeF: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, arg__1: QSizeF) -> QSizeF: ...
    def __imul__(self, c: float) -> QSizeF: ...
    def __isub__(self, arg__1: QSizeF) -> QSizeF: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, c: float) -> QSizeF: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __sub__(self, s2: QSizeF) -> QSizeF: ...
    def __truediv__(self, other) -> Any: ...

class QSocketDescriptor(shiboken2.Object):
    @overload
    def __init__(self, QSocketDescriptor: QSocketDescriptor) -> None: ...
    @overload
    def __init__(self, descriptor: int = ...) -> None: ...
    def isValid(self) -> bool: ...
    def __copy__(self) -> None: ...

class QSocketNotifier(QObject):
    class Type:
        Exception: ClassVar[QSocketNotifier.Type] = ...
        Read: ClassVar[QSocketNotifier.Type] = ...
        Write: ClassVar[QSocketNotifier.Type] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __and__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __rand__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __ror__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __sub__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
        def __xor__(self, other: typing.SupportsInt) -> QSocketNotifier.Type: ...
    Exception: ClassVar[QSocketNotifier.Type] = ...
    Read: ClassVar[QSocketNotifier.Type] = ...
    Write: ClassVar[QSocketNotifier.Type] = ...
    activated: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, arg__1: object, arg__2: QSocketNotifier.Type, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, socket: int, arg__2: QSocketNotifier.Type, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def event(self, arg__1: QEvent) -> bool: ...
    def isEnabled(self) -> bool: ...
    def setEnabled(self, arg__1: bool) -> None: ...
    def socket(self) -> int: ...
    def type(self) -> QSocketNotifier.Type: ...

class QSortFilterProxyModel(QAbstractProxyModel):
    dynamicSortFilterChanged: ClassVar[Signal] = ...
    filterCaseSensitivityChanged: ClassVar[Signal] = ...
    filterRoleChanged: ClassVar[Signal] = ...
    recursiveFilteringEnabledChanged: ClassVar[Signal] = ...
    sortCaseSensitivityChanged: ClassVar[Signal] = ...
    sortLocaleAwareChanged: ClassVar[Signal] = ...
    sortRoleChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., columnsAboutToBeInserted: typing.Callable = ..., columnsAboutToBeMoved: typing.Callable = ..., columnsAboutToBeRemoved: typing.Callable = ..., columnsInserted: typing.Callable = ..., columnsMoved: typing.Callable = ..., columnsRemoved: typing.Callable = ..., dataChanged: typing.Callable = ..., destroyed: typing.Callable = ..., dynamicSortFilter: bool = ..., dynamicSortFilterChanged: typing.Callable = ..., filterCaseSensitivity: Qt.CaseSensitivity = ..., filterCaseSensitivityChanged: typing.Callable = ..., filterKeyColumn: int = ..., filterRegExp: QRegExp = ..., filterRegularExpression: QRegularExpression = ..., filterRole: int = ..., filterRoleChanged: typing.Callable = ..., headerDataChanged: typing.Callable = ..., isSortLocaleAware: bool = ..., layoutAboutToBeChanged: typing.Callable = ..., layoutChanged: typing.Callable = ..., modelAboutToBeReset: typing.Callable = ..., modelReset: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., recursiveFilteringEnabled: bool = ..., recursiveFilteringEnabledChanged: typing.Callable = ..., rowsAboutToBeInserted: typing.Callable = ..., rowsAboutToBeMoved: typing.Callable = ..., rowsAboutToBeRemoved: typing.Callable = ..., rowsInserted: typing.Callable = ..., rowsMoved: typing.Callable = ..., rowsRemoved: typing.Callable = ..., sortCaseSensitivity: Qt.CaseSensitivity = ..., sortCaseSensitivityChanged: typing.Callable = ..., sortLocaleAwareChanged: typing.Callable = ..., sortRole: int = ..., sortRoleChanged: typing.Callable = ..., sourceModel: typing.Any = ..., sourceModelChanged: typing.Callable = ...) -> None: ...
    def buddy(self, index: QModelIndex) -> QModelIndex: ...
    def canFetchMore(self, parent: QModelIndex) -> bool: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    def data(self, index: QModelIndex, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def dropMimeData(self, data: QMimeData, action: Qt.DropAction, row: int, column: int, parent: QModelIndex) -> bool: ...
    def dynamicSortFilter(self) -> bool: ...
    def fetchMore(self, parent: QModelIndex) -> None: ...
    def filterAcceptsColumn(self, source_column: int, source_parent: QModelIndex) -> bool: ...
    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool: ...
    def filterCaseSensitivity(self) -> Qt.CaseSensitivity: ...
    def filterKeyColumn(self) -> int: ...
    def filterRegExp(self) -> QRegExp: ...
    def filterRegularExpression(self) -> QRegularExpression: ...
    def filterRole(self) -> Qt.ItemDataRole: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def hasChildren(self, parent: QModelIndex = ...) -> bool: ...
    def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def invalidate(self) -> None: ...
    def invalidateFilter(self) -> None: ...
    def isRecursiveFilteringEnabled(self) -> bool: ...
    def isSortLocaleAware(self) -> bool: ...
    def lessThan(self, source_left: QModelIndex, source_right: QModelIndex) -> bool: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapSelectionFromSource(self, sourceSelection: QItemSelection) -> QItemSelection: ...
    def mapSelectionToSource(self, proxySelection: QItemSelection) -> QItemSelection: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def match(self, start: QModelIndex, role: Qt.ItemDataRole, value: typing.Any, hits: int = ..., flags: typing.Union[Qt.MatchFlags,Qt.MatchFlag] = ...) -> typing.List[int]: ...
    def mimeData(self, indexes: typing.List[int]) -> QMimeData: ...
    def mimeTypes(self) -> typing.List[str]: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setDynamicSortFilter(self, enable: bool) -> None: ...
    def setFilterCaseSensitivity(self, cs: Qt.CaseSensitivity) -> None: ...
    def setFilterFixedString(self, pattern: str) -> None: ...
    def setFilterKeyColumn(self, column: int) -> None: ...
    @overload
    def setFilterRegExp(self, pattern: str) -> None: ...
    @overload
    def setFilterRegExp(self, regExp: QRegExp) -> None: ...
    @overload
    def setFilterRegularExpression(self, pattern: str) -> None: ...
    @overload
    def setFilterRegularExpression(self, regularExpression: QRegularExpression) -> None: ...
    def setFilterRole(self, role: Qt.ItemDataRole) -> None: ...
    def setFilterWildcard(self, pattern: str) -> None: ...
    def setHeaderData(self, section: int, orientation: Qt.Orientation, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setRecursiveFilteringEnabled(self, recursive: bool) -> None: ...
    def setSortCaseSensitivity(self, cs: Qt.CaseSensitivity) -> None: ...
    def setSortLocaleAware(self, on: bool) -> None: ...
    def setSortRole(self, role: Qt.ItemDataRole) -> None: ...
    def setSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def sort(self, column: int, order: Qt.SortOrder = ...) -> None: ...
    def sortCaseSensitivity(self) -> Qt.CaseSensitivity: ...
    def sortColumn(self) -> int: ...
    def sortOrder(self) -> Qt.SortOrder: ...
    def sortRole(self) -> int: ...
    def span(self, index: QModelIndex) -> QSize: ...
    def supportedDropActions(self) -> typing.Union[Qt.DropActions,Qt.DropAction]: ...

class QStandardPaths(shiboken2.Object):
    class LocateOption:
        LocateDirectory: ClassVar[QStandardPaths.LocateOption] = ...
        LocateFile: ClassVar[QStandardPaths.LocateOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QStandardPaths.LocateOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...

    class LocateOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QStandardPaths.LocateOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QStandardPaths.LocateOptions: ...

    class StandardLocation:
        AppConfigLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        AppDataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        AppLocalDataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        ApplicationsLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        CacheLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        ConfigLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        DataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        DesktopLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        DocumentsLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        DownloadLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        FontsLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        GenericCacheLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        GenericConfigLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        GenericDataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        HomeLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        MoviesLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        MusicLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        PicturesLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        RuntimeLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        TempLocation: ClassVar[QStandardPaths.StandardLocation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __and__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __rand__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __rmul__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __ror__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __rsub__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __rxor__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __sub__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
        def __xor__(self, other: typing.SupportsInt) -> QStandardPaths.StandardLocation: ...
    AppConfigLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    AppDataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    AppLocalDataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    ApplicationsLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    CacheLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    ConfigLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    DataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    DesktopLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    DocumentsLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    DownloadLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    FontsLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    GenericCacheLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    GenericConfigLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    GenericDataLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    HomeLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    LocateDirectory: ClassVar[QStandardPaths.LocateOption] = ...
    LocateFile: ClassVar[QStandardPaths.LocateOption] = ...
    MoviesLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    MusicLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    PicturesLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    RuntimeLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    TempLocation: ClassVar[QStandardPaths.StandardLocation] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @classmethod
    def displayName(cls, type: QStandardPaths.StandardLocation) -> str: ...
    @classmethod
    def enableTestMode(cls, testMode: bool) -> None: ...
    @classmethod
    def findExecutable(cls, executableName: str, paths: typing.Sequence[str] = ...) -> str: ...
    @classmethod
    def isTestModeEnabled(cls) -> bool: ...
    @classmethod
    def locate(cls, type: QStandardPaths.StandardLocation, fileName: str, options: typing.Union[QStandardPaths.LocateOptions,QStandardPaths.LocateOption] = ...) -> str: ...
    @classmethod
    def locateAll(cls, type: QStandardPaths.StandardLocation, fileName: str, options: typing.Union[QStandardPaths.LocateOptions,QStandardPaths.LocateOption] = ...) -> typing.List[str]: ...
    @classmethod
    def setTestModeEnabled(cls, testMode: bool) -> None: ...
    @classmethod
    def standardLocations(cls, type: QStandardPaths.StandardLocation) -> typing.List[str]: ...
    @classmethod
    def writableLocation(cls, type: QStandardPaths.StandardLocation) -> str: ...

class QState(QAbstractState):
    class ChildMode:
        ExclusiveStates: ClassVar[QState.ChildMode] = ...
        ParallelStates: ClassVar[QState.ChildMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __and__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QState.ChildMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QState.ChildMode: ...

    class RestorePolicy:
        DontRestoreProperties: ClassVar[QState.RestorePolicy] = ...
        RestoreProperties: ClassVar[QState.RestorePolicy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __and__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __rand__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __rmul__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __ror__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __rsub__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __rxor__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __sub__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
        def __xor__(self, other: typing.SupportsInt) -> QState.RestorePolicy: ...
    DontRestoreProperties: ClassVar[QState.RestorePolicy] = ...
    ExclusiveStates: ClassVar[QState.ChildMode] = ...
    ParallelStates: ClassVar[QState.ChildMode] = ...
    RestoreProperties: ClassVar[QState.RestorePolicy] = ...
    childModeChanged: ClassVar[Signal] = ...
    errorStateChanged: ClassVar[Signal] = ...
    finished: ClassVar[Signal] = ...
    initialStateChanged: ClassVar[Signal] = ...
    propertiesAssigned: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, childMode: QState.ChildMode, parent: typing.Union[QState,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., childModeChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., errorState: QAbstractState = ..., errorStateChanged: typing.Callable = ..., exited: typing.Callable = ..., finished: typing.Callable = ..., initialState: QAbstractState = ..., initialStateChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., propertiesAssigned: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QState,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., childMode: QState.ChildMode = ..., childModeChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., errorState: QAbstractState = ..., errorStateChanged: typing.Callable = ..., exited: typing.Callable = ..., finished: typing.Callable = ..., initialState: QAbstractState = ..., initialStateChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., propertiesAssigned: typing.Callable = ...) -> None: ...
    @overload
    def addTransition(self, arg__1: object, arg__2: QAbstractState) -> QSignalTransition: ...
    @overload
    def addTransition(self, sender: QObject, signal: bytes, target: QAbstractState) -> QSignalTransition: ...
    @overload
    def addTransition(self, target: QAbstractState) -> QAbstractTransition: ...
    @overload
    def addTransition(self, transition: QAbstractTransition) -> None: ...
    def assignProperty(self, object: QObject, name: str, value: typing.Any) -> None: ...
    def childMode(self) -> QState.ChildMode: ...
    def errorState(self) -> QAbstractState: ...
    def event(self, e: QEvent) -> bool: ...
    def initialState(self) -> QAbstractState: ...
    def onEntry(self, event: QEvent) -> None: ...
    def onExit(self, event: QEvent) -> None: ...
    def removeTransition(self, transition: QAbstractTransition) -> None: ...
    def setChildMode(self, mode: QState.ChildMode) -> None: ...
    def setErrorState(self, state: QAbstractState) -> None: ...
    def setInitialState(self, state: QAbstractState) -> None: ...
    def transitions(self) -> typing.List[QAbstractTransition]: ...

class QStateMachine(QState):
    class Error:
        NoCommonAncestorForTransitionError: ClassVar[QStateMachine.Error] = ...
        NoDefaultStateInHistoryStateError: ClassVar[QStateMachine.Error] = ...
        NoError: ClassVar[QStateMachine.Error] = ...
        NoInitialStateError: ClassVar[QStateMachine.Error] = ...
        StateMachineChildModeSetToParallelError: ClassVar[QStateMachine.Error] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __and__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __rand__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __rmul__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __ror__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __rsub__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __rxor__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __sub__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...
        def __xor__(self, other: typing.SupportsInt) -> QStateMachine.Error: ...

    class EventPriority:
        HighPriority: ClassVar[QStateMachine.EventPriority] = ...
        NormalPriority: ClassVar[QStateMachine.EventPriority] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __and__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __rand__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __rmul__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __ror__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __rsub__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __rxor__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __sub__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...
        def __xor__(self, other: typing.SupportsInt) -> QStateMachine.EventPriority: ...

    class SignalEvent(QEvent):
        @overload
        def __init__(self, SignalEvent: QStateMachine.SignalEvent) -> None: ...
        @overload
        def __init__(self, sender: QObject, signalIndex: int, arguments: typing.Sequence[typing.Any]) -> None: ...
        def arguments(self) -> typing.List[typing.Any]: ...
        def sender(self) -> QObject: ...
        def signalIndex(self) -> int: ...
        def __copy__(self) -> None: ...

    class WrappedEvent(QEvent):
        @overload
        def __init__(self, WrappedEvent: QStateMachine.WrappedEvent) -> None: ...
        @overload
        def __init__(self, object: QObject, event: QEvent) -> None: ...
        def event(self) -> QEvent: ...
        def object(self) -> QObject: ...
        def __copy__(self) -> None: ...
    HighPriority: ClassVar[QStateMachine.EventPriority] = ...
    NoCommonAncestorForTransitionError: ClassVar[QStateMachine.Error] = ...
    NoDefaultStateInHistoryStateError: ClassVar[QStateMachine.Error] = ...
    NoError: ClassVar[QStateMachine.Error] = ...
    NoInitialStateError: ClassVar[QStateMachine.Error] = ...
    NormalPriority: ClassVar[QStateMachine.EventPriority] = ...
    StateMachineChildModeSetToParallelError: ClassVar[QStateMachine.Error] = ...
    runningChanged: ClassVar[Signal] = ...
    started: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    stopped: ClassVar[Signal] = ...
    @overload
    def __init__(self, childMode: QState.ChildMode, parent: typing.Union[QObject,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., animated: bool = ..., childModeChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., errorState: typing.Any = ..., errorStateChanged: typing.Callable = ..., errorString: str = ..., exited: typing.Callable = ..., finished: typing.Callable = ..., globalRestorePolicy: typing.Any = ..., initialState: typing.Any = ..., initialStateChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., propertiesAssigned: typing.Callable = ..., running: bool = ..., runningChanged: typing.Callable = ..., started: typing.Callable = ..., stopped: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., active: bool = ..., activeChanged: typing.Callable = ..., animated: bool = ..., childMode: QStateMachine.ChildMode = ..., childModeChanged: typing.Callable = ..., destroyed: typing.Callable = ..., entered: typing.Callable = ..., errorState: typing.Any = ..., errorStateChanged: typing.Callable = ..., errorString: str = ..., exited: typing.Callable = ..., finished: typing.Callable = ..., globalRestorePolicy: typing.Any = ..., initialState: typing.Any = ..., initialStateChanged: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., propertiesAssigned: typing.Callable = ..., running: bool = ..., runningChanged: typing.Callable = ..., started: typing.Callable = ..., stopped: typing.Callable = ...) -> None: ...
    def addDefaultAnimation(self, animation: QAbstractAnimation) -> None: ...
    def addState(self, state: QAbstractState) -> None: ...
    def beginMicrostep(self, event: QEvent) -> None: ...
    def beginSelectTransitions(self, event: QEvent) -> None: ...
    def cancelDelayedEvent(self, id: int) -> bool: ...
    def clearError(self) -> None: ...
    @overload
    def configuration(self) -> typing.Set[QAbstractState]: ...
    @overload
    def configuration(self) -> typing.List[QAbstractState]: ...
    def defaultAnimations(self) -> typing.List[QAbstractAnimation]: ...
    def endMicrostep(self, event: QEvent) -> None: ...
    def endSelectTransitions(self, event: QEvent) -> None: ...
    def error(self) -> QStateMachine.Error: ...
    def errorString(self) -> str: ...
    def event(self, e: QEvent) -> bool: ...
    def eventFilter(self, watched: QObject, event: QEvent) -> bool: ...
    def globalRestorePolicy(self) -> QState.RestorePolicy: ...
    def isAnimated(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def onEntry(self, event: QEvent) -> None: ...
    def onExit(self, event: QEvent) -> None: ...
    def postDelayedEvent(self, event: QEvent, delay: int) -> int: ...
    def postEvent(self, event: QEvent, priority: QStateMachine.EventPriority = ...) -> None: ...
    def removeDefaultAnimation(self, animation: QAbstractAnimation) -> None: ...
    def removeState(self, state: QAbstractState) -> None: ...
    def setAnimated(self, enabled: bool) -> None: ...
    def setGlobalRestorePolicy(self, restorePolicy: QState.RestorePolicy) -> None: ...
    def setRunning(self, running: bool) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class QStorageInfo(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dir: QDir) -> None: ...
    @overload
    def __init__(self, other: QStorageInfo) -> None: ...
    @overload
    def __init__(self, path: str) -> None: ...
    def blockSize(self) -> int: ...
    def bytesAvailable(self) -> int: ...
    def bytesFree(self) -> int: ...
    def bytesTotal(self) -> int: ...
    def device(self) -> QByteArray: ...
    def displayName(self) -> str: ...
    def fileSystemType(self) -> QByteArray: ...
    def isReadOnly(self) -> bool: ...
    def isReady(self) -> bool: ...
    def isRoot(self) -> bool: ...
    def isValid(self) -> bool: ...
    @classmethod
    def mountedVolumes(cls) -> typing.List[QStorageInfo]: ...
    def name(self) -> str: ...
    def refresh(self) -> None: ...
    @classmethod
    def root(cls) -> QStorageInfo: ...
    def rootPath(self) -> str: ...
    def setPath(self, path: str) -> None: ...
    def subvolume(self) -> QByteArray: ...
    def swap(self, other: QStorageInfo) -> None: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QStringListModel(QAbstractListModel):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, parent: typing.Union[QObject,None] = ..., columnsAboutToBeInserted: typing.Callable = ..., columnsAboutToBeMoved: typing.Callable = ..., columnsAboutToBeRemoved: typing.Callable = ..., columnsInserted: typing.Callable = ..., columnsMoved: typing.Callable = ..., columnsRemoved: typing.Callable = ..., dataChanged: typing.Callable = ..., destroyed: typing.Callable = ..., headerDataChanged: typing.Callable = ..., layoutAboutToBeChanged: typing.Callable = ..., layoutChanged: typing.Callable = ..., modelAboutToBeReset: typing.Callable = ..., modelReset: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., rowsAboutToBeInserted: typing.Callable = ..., rowsAboutToBeMoved: typing.Callable = ..., rowsAboutToBeRemoved: typing.Callable = ..., rowsInserted: typing.Callable = ..., rowsMoved: typing.Callable = ..., rowsRemoved: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, strings: typing.Sequence[str], parent: typing.Union[QObject,None] = ..., columnsAboutToBeInserted: typing.Callable = ..., columnsAboutToBeMoved: typing.Callable = ..., columnsAboutToBeRemoved: typing.Callable = ..., columnsInserted: typing.Callable = ..., columnsMoved: typing.Callable = ..., columnsRemoved: typing.Callable = ..., dataChanged: typing.Callable = ..., destroyed: typing.Callable = ..., headerDataChanged: typing.Callable = ..., layoutAboutToBeChanged: typing.Callable = ..., layoutChanged: typing.Callable = ..., modelAboutToBeReset: typing.Callable = ..., modelReset: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., rowsAboutToBeInserted: typing.Callable = ..., rowsAboutToBeMoved: typing.Callable = ..., rowsAboutToBeRemoved: typing.Callable = ..., rowsInserted: typing.Callable = ..., rowsMoved: typing.Callable = ..., rowsRemoved: typing.Callable = ...) -> None: ...
    def data(self, index: QModelIndex, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def flags(self, index: QModelIndex) -> typing.Union[Qt.ItemFlags,Qt.ItemFlag]: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def itemData(self, index: QModelIndex) -> typing.Dict[int,typing.Any]: ...
    def moveRows(self, sourceParent: QModelIndex, sourceRow: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int,typing.Any]) -> bool: ...
    def setStringList(self, strings: typing.Sequence[str]) -> None: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def sort(self, column: int, order: Qt.SortOrder = ...) -> None: ...
    def stringList(self) -> typing.List[str]: ...
    def supportedDropActions(self) -> typing.Union[Qt.DropActions,Qt.DropAction]: ...

class QSysInfo(shiboken2.Object):
    class Endian:
        BigEndian: ClassVar[QSysInfo.Endian] = ...
        ByteOrder: ClassVar[QSysInfo.Endian] = ...
        LittleEndian: ClassVar[QSysInfo.Endian] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __and__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __rand__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __ror__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __sub__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...
        def __xor__(self, other: typing.SupportsInt) -> QSysInfo.Endian: ...

    class MacVersion:
        MV_10_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_10: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_11: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_12: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_2: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_3: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_4: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_5: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_6: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_7: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_8: ClassVar[QSysInfo.MacVersion] = ...
        MV_10_9: ClassVar[QSysInfo.MacVersion] = ...
        MV_9: ClassVar[QSysInfo.MacVersion] = ...
        MV_CHEETAH: ClassVar[QSysInfo.MacVersion] = ...
        MV_ELCAPITAN: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_10_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_4_3: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_5_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_5_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_6_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_6_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_7_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_7_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_8_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_8_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_8_2: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_8_3: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_8_4: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_9_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_9_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_9_2: ClassVar[QSysInfo.MacVersion] = ...
        MV_IOS_9_3: ClassVar[QSysInfo.MacVersion] = ...
        MV_JAGUAR: ClassVar[QSysInfo.MacVersion] = ...
        MV_LEOPARD: ClassVar[QSysInfo.MacVersion] = ...
        MV_LION: ClassVar[QSysInfo.MacVersion] = ...
        MV_MAVERICKS: ClassVar[QSysInfo.MacVersion] = ...
        MV_MOUNTAINLION: ClassVar[QSysInfo.MacVersion] = ...
        MV_None: ClassVar[QSysInfo.MacVersion] = ...
        MV_PANTHER: ClassVar[QSysInfo.MacVersion] = ...
        MV_PUMA: ClassVar[QSysInfo.MacVersion] = ...
        MV_SIERRA: ClassVar[QSysInfo.MacVersion] = ...
        MV_SNOWLEOPARD: ClassVar[QSysInfo.MacVersion] = ...
        MV_TIGER: ClassVar[QSysInfo.MacVersion] = ...
        MV_TVOS: ClassVar[QSysInfo.MacVersion] = ...
        MV_TVOS_10_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_TVOS_9_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_TVOS_9_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_TVOS_9_2: ClassVar[QSysInfo.MacVersion] = ...
        MV_Unknown: ClassVar[QSysInfo.MacVersion] = ...
        MV_WATCHOS: ClassVar[QSysInfo.MacVersion] = ...
        MV_WATCHOS_2_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_WATCHOS_2_1: ClassVar[QSysInfo.MacVersion] = ...
        MV_WATCHOS_2_2: ClassVar[QSysInfo.MacVersion] = ...
        MV_WATCHOS_3_0: ClassVar[QSysInfo.MacVersion] = ...
        MV_YOSEMITE: ClassVar[QSysInfo.MacVersion] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __and__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __rand__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __ror__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __sub__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...
        def __xor__(self, other: typing.SupportsInt) -> QSysInfo.MacVersion: ...

    class Sizes:
        WordSize: ClassVar[QSysInfo.Sizes] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __and__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __rand__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __ror__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __sub__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
        def __xor__(self, other: typing.SupportsInt) -> QSysInfo.Sizes: ...
    BigEndian: ClassVar[QSysInfo.Endian] = ...
    ByteOrder: ClassVar[QSysInfo.Endian] = ...
    LittleEndian: ClassVar[QSysInfo.Endian] = ...
    MV_10_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_10: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_11: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_12: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_2: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_3: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_4: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_5: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_6: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_7: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_8: ClassVar[QSysInfo.MacVersion] = ...
    MV_10_9: ClassVar[QSysInfo.MacVersion] = ...
    MV_9: ClassVar[QSysInfo.MacVersion] = ...
    MV_CHEETAH: ClassVar[QSysInfo.MacVersion] = ...
    MV_ELCAPITAN: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_10_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_4_3: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_5_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_5_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_6_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_6_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_7_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_7_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_8_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_8_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_8_2: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_8_3: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_8_4: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_9_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_9_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_9_2: ClassVar[QSysInfo.MacVersion] = ...
    MV_IOS_9_3: ClassVar[QSysInfo.MacVersion] = ...
    MV_JAGUAR: ClassVar[QSysInfo.MacVersion] = ...
    MV_LEOPARD: ClassVar[QSysInfo.MacVersion] = ...
    MV_LION: ClassVar[QSysInfo.MacVersion] = ...
    MV_MAVERICKS: ClassVar[QSysInfo.MacVersion] = ...
    MV_MOUNTAINLION: ClassVar[QSysInfo.MacVersion] = ...
    MV_None: ClassVar[QSysInfo.MacVersion] = ...
    MV_PANTHER: ClassVar[QSysInfo.MacVersion] = ...
    MV_PUMA: ClassVar[QSysInfo.MacVersion] = ...
    MV_SIERRA: ClassVar[QSysInfo.MacVersion] = ...
    MV_SNOWLEOPARD: ClassVar[QSysInfo.MacVersion] = ...
    MV_TIGER: ClassVar[QSysInfo.MacVersion] = ...
    MV_TVOS: ClassVar[QSysInfo.MacVersion] = ...
    MV_TVOS_10_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_TVOS_9_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_TVOS_9_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_TVOS_9_2: ClassVar[QSysInfo.MacVersion] = ...
    MV_Unknown: ClassVar[QSysInfo.MacVersion] = ...
    MV_WATCHOS: ClassVar[QSysInfo.MacVersion] = ...
    MV_WATCHOS_2_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_WATCHOS_2_1: ClassVar[QSysInfo.MacVersion] = ...
    MV_WATCHOS_2_2: ClassVar[QSysInfo.MacVersion] = ...
    MV_WATCHOS_3_0: ClassVar[QSysInfo.MacVersion] = ...
    MV_YOSEMITE: ClassVar[QSysInfo.MacVersion] = ...
    MacintoshVersion: ClassVar[QSysInfo.MacVersion] = ...
    WordSize: ClassVar[QSysInfo.Sizes] = ...
    def __init__(self) -> None: ...
    @classmethod
    def bootUniqueId(cls) -> QByteArray: ...
    @classmethod
    def buildAbi(cls) -> str: ...
    @classmethod
    def buildCpuArchitecture(cls) -> str: ...
    @classmethod
    def currentCpuArchitecture(cls) -> str: ...
    @classmethod
    def kernelType(cls) -> str: ...
    @classmethod
    def kernelVersion(cls) -> str: ...
    @classmethod
    def macVersion(cls) -> QSysInfo.MacVersion: ...
    @classmethod
    def machineHostName(cls) -> str: ...
    @classmethod
    def machineUniqueId(cls) -> QByteArray: ...
    @classmethod
    def prettyProductName(cls) -> str: ...
    @classmethod
    def productType(cls) -> str: ...
    @classmethod
    def productVersion(cls) -> str: ...

class QSystemSemaphore(shiboken2.Object):
    class AccessMode:
        Create: ClassVar[QSystemSemaphore.AccessMode] = ...
        Open: ClassVar[QSystemSemaphore.AccessMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __and__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QSystemSemaphore.AccessMode: ...

    class SystemSemaphoreError:
        AlreadyExists: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        KeyError: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        NoError: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        NotFound: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        OutOfResources: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        PermissionDenied: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        UnknownError: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __and__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __rand__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __rmul__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __ror__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __rsub__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __rxor__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __sub__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
        def __xor__(self, other: typing.SupportsInt) -> QSystemSemaphore.SystemSemaphoreError: ...
    AlreadyExists: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    Create: ClassVar[QSystemSemaphore.AccessMode] = ...
    KeyError: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    NoError: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    NotFound: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    Open: ClassVar[QSystemSemaphore.AccessMode] = ...
    OutOfResources: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    PermissionDenied: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    UnknownError: ClassVar[QSystemSemaphore.SystemSemaphoreError] = ...
    def __init__(self, key: str, initialValue: int = ..., mode: QSystemSemaphore.AccessMode = ...) -> None: ...
    def acquire(self) -> bool: ...
    def error(self) -> QSystemSemaphore.SystemSemaphoreError: ...
    def errorString(self) -> str: ...
    def key(self) -> str: ...
    def release(self, n: int = ...) -> bool: ...
    def setKey(self, key: str, initialValue: int = ..., mode: QSystemSemaphore.AccessMode = ...) -> None: ...

class QTemporaryDir(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, templateName: str) -> None: ...
    def autoRemove(self) -> bool: ...
    def errorString(self) -> str: ...
    def filePath(self, fileName: str) -> str: ...
    def isValid(self) -> bool: ...
    def path(self) -> str: ...
    def remove(self) -> bool: ...
    def setAutoRemove(self, b: bool) -> None: ...

class QTemporaryFile(QFile):
    staticMetaObject: ClassVar[QMetaObject] = ...
    @overload
    def __init__(self, aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, parent: typing.Optional[QObject], aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, templateName: str, aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    @overload
    def __init__(self, templateName: str, parent: typing.Optional[QObject], aboutToClose: typing.Callable = ..., bytesWritten: typing.Callable = ..., channelBytesWritten: typing.Callable = ..., channelReadyRead: typing.Callable = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., readChannelFinished: typing.Callable = ..., readyRead: typing.Callable = ...) -> None: ...
    def autoRemove(self) -> bool: ...
    @classmethod
    @overload
    def createLocalFile(cls, file: QFile) -> QTemporaryFile: ...
    @classmethod
    @overload
    def createLocalFile(cls, fileName: str) -> QTemporaryFile: ...
    @classmethod
    @overload
    def createNativeFile(cls, file: QFile) -> QTemporaryFile: ...
    @classmethod
    @overload
    def createNativeFile(cls, fileName: str) -> QTemporaryFile: ...
    def fileName(self) -> str: ...
    def fileTemplate(self) -> str: ...
    @overload
    def open(self) -> bool: ...
    @overload
    def open(self, flags: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag]) -> bool: ...
    def rename(self, newName: str) -> bool: ...
    def setAutoRemove(self, b: bool) -> None: ...
    def setFileTemplate(self, name: str) -> None: ...

class QTextBoundaryFinder(shiboken2.Object):
    class BoundaryReason:
        BreakOpportunity: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
        EndOfItem: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
        MandatoryBreak: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
        NotAtBoundary: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
        SoftHyphen: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
        StartOfItem: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QTextBoundaryFinder.BoundaryReason: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...

    class BoundaryReasons:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryReasons: ...

    class BoundaryType:
        Grapheme: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
        Line: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
        Sentence: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
        Word: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __and__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __sub__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextBoundaryFinder.BoundaryType: ...
    BreakOpportunity: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
    EndOfItem: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
    Grapheme: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
    Line: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
    MandatoryBreak: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
    NotAtBoundary: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
    Sentence: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
    SoftHyphen: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
    StartOfItem: ClassVar[QTextBoundaryFinder.BoundaryReason] = ...
    Word: ClassVar[QTextBoundaryFinder.BoundaryType] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QTextBoundaryFinder) -> None: ...
    @overload
    def __init__(self, type: QTextBoundaryFinder.BoundaryType, string: str) -> None: ...
    def boundaryReasons(self) -> typing.Union[QTextBoundaryFinder.BoundaryReasons,QTextBoundaryFinder.BoundaryReason]: ...
    def isAtBoundary(self) -> bool: ...
    def isValid(self) -> bool: ...
    def position(self) -> int: ...
    def setPosition(self, position: int) -> None: ...
    def string(self) -> str: ...
    def toEnd(self) -> None: ...
    def toNextBoundary(self) -> int: ...
    def toPreviousBoundary(self) -> int: ...
    def toStart(self) -> None: ...
    def type(self) -> QTextBoundaryFinder.BoundaryType: ...
    def __copy__(self) -> None: ...

class QTextCodec(shiboken2.Object):
    class ConversionFlag:
        ConvertInvalidToNull: ClassVar[QTextCodec.ConversionFlag] = ...
        DefaultConversion: ClassVar[QTextCodec.ConversionFlag] = ...
        FreeFunction: ClassVar[QTextCodec.ConversionFlag] = ...
        IgnoreHeader: ClassVar[QTextCodec.ConversionFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QTextCodec.ConversionFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...

    class ConversionFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QTextCodec.ConversionFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextCodec.ConversionFlags: ...

    class ConverterState(shiboken2.Object):
        flags: Any
        invalidChars: Any
        remainingChars: Any
        def __init__(self, f: typing.Union[QTextCodec.ConversionFlags,QTextCodec.ConversionFlag] = ...) -> None: ...
    ConvertInvalidToNull: ClassVar[QTextCodec.ConversionFlag] = ...
    DefaultConversion: ClassVar[QTextCodec.ConversionFlag] = ...
    FreeFunction: ClassVar[QTextCodec.ConversionFlag] = ...
    IgnoreHeader: ClassVar[QTextCodec.ConversionFlag] = ...
    def __init__(self) -> None: ...
    def aliases(self) -> typing.List[QByteArray]: ...
    @classmethod
    def availableCodecs(cls) -> typing.List[QByteArray]: ...
    @classmethod
    def availableMibs(cls) -> typing.List[int]: ...
    def canEncode(self, arg__1: str) -> bool: ...
    @classmethod
    @overload
    def codecForHtml(cls, ba: typing.Union[QByteArray,bytes]) -> QTextCodec: ...
    @classmethod
    @overload
    def codecForHtml(cls, ba: typing.Union[QByteArray,bytes], defaultCodec: QTextCodec) -> QTextCodec: ...
    @classmethod
    def codecForLocale(cls) -> QTextCodec: ...
    @classmethod
    def codecForMib(cls, mib: int) -> QTextCodec: ...
    @classmethod
    @overload
    def codecForName(cls, name: typing.Union[QByteArray,bytes]) -> QTextCodec: ...
    @classmethod
    @overload
    def codecForName(cls, name: bytes) -> QTextCodec: ...
    @classmethod
    @overload
    def codecForUtfText(cls, ba: typing.Union[QByteArray,bytes]) -> QTextCodec: ...
    @classmethod
    @overload
    def codecForUtfText(cls, ba: typing.Union[QByteArray,bytes], defaultCodec: QTextCodec) -> QTextCodec: ...
    def convertToUnicode(self, in_: bytes, length: int, state: QTextCodec.ConverterState) -> str: ...
    def fromUnicode(self, uc: str) -> QByteArray: ...
    def makeDecoder(self, flags: typing.Union[QTextCodec.ConversionFlags,QTextCodec.ConversionFlag] = ...) -> QTextDecoder: ...
    def makeEncoder(self, flags: typing.Union[QTextCodec.ConversionFlags,QTextCodec.ConversionFlag] = ...) -> QTextEncoder: ...
    def mibEnum(self) -> int: ...
    def name(self) -> QByteArray: ...
    @classmethod
    def setCodecForLocale(cls, c: QTextCodec) -> None: ...
    @overload
    def toUnicode(self, arg__1: typing.Union[QByteArray,bytes]) -> str: ...
    @overload
    def toUnicode(self, chars: bytes) -> str: ...
    @overload
    def toUnicode(self, in_: bytes, length: int, state: typing.Union[QTextCodec.ConverterState,None] = ...) -> str: ...

class QTextDecoder(shiboken2.Object):
    @overload
    def __init__(self, codec: QTextCodec) -> None: ...
    @overload
    def __init__(self, codec: QTextCodec, flags: typing.Union[QTextCodec.ConversionFlags,QTextCodec.ConversionFlag]) -> None: ...
    def hasFailure(self) -> bool: ...
    def needsMoreData(self) -> bool: ...
    def toUnicode(self, ba: typing.Union[QByteArray,bytes]) -> str: ...

class QTextEncoder(shiboken2.Object):
    @overload
    def __init__(self, codec: QTextCodec) -> None: ...
    @overload
    def __init__(self, codec: QTextCodec, flags: typing.Union[QTextCodec.ConversionFlags,QTextCodec.ConversionFlag]) -> None: ...
    def fromUnicode(self, str: str) -> QByteArray: ...
    def hasFailure(self) -> bool: ...

class QTextStream(shiboken2.Object):
    class FieldAlignment:
        AlignAccountingStyle: ClassVar[QTextStream.FieldAlignment] = ...
        AlignCenter: ClassVar[QTextStream.FieldAlignment] = ...
        AlignLeft: ClassVar[QTextStream.FieldAlignment] = ...
        AlignRight: ClassVar[QTextStream.FieldAlignment] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __and__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __sub__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextStream.FieldAlignment: ...

    class NumberFlag:
        ForcePoint: ClassVar[QTextStream.NumberFlag] = ...
        ForceSign: ClassVar[QTextStream.NumberFlag] = ...
        ShowBase: ClassVar[QTextStream.NumberFlag] = ...
        UppercaseBase: ClassVar[QTextStream.NumberFlag] = ...
        UppercaseDigits: ClassVar[QTextStream.NumberFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QTextStream.NumberFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...

    class NumberFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QTextStream.NumberFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextStream.NumberFlags: ...

    class RealNumberNotation:
        FixedNotation: ClassVar[QTextStream.RealNumberNotation] = ...
        ScientificNotation: ClassVar[QTextStream.RealNumberNotation] = ...
        SmartNotation: ClassVar[QTextStream.RealNumberNotation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __and__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __sub__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextStream.RealNumberNotation: ...

    class Status:
        Ok: ClassVar[QTextStream.Status] = ...
        ReadCorruptData: ClassVar[QTextStream.Status] = ...
        ReadPastEnd: ClassVar[QTextStream.Status] = ...
        WriteFailed: ClassVar[QTextStream.Status] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __and__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __rand__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __ror__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __sub__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
        def __xor__(self, other: typing.SupportsInt) -> QTextStream.Status: ...
    AlignAccountingStyle: ClassVar[QTextStream.FieldAlignment] = ...
    AlignCenter: ClassVar[QTextStream.FieldAlignment] = ...
    AlignLeft: ClassVar[QTextStream.FieldAlignment] = ...
    AlignRight: ClassVar[QTextStream.FieldAlignment] = ...
    FixedNotation: ClassVar[QTextStream.RealNumberNotation] = ...
    ForcePoint: ClassVar[QTextStream.NumberFlag] = ...
    ForceSign: ClassVar[QTextStream.NumberFlag] = ...
    Ok: ClassVar[QTextStream.Status] = ...
    ReadCorruptData: ClassVar[QTextStream.Status] = ...
    ReadPastEnd: ClassVar[QTextStream.Status] = ...
    ScientificNotation: ClassVar[QTextStream.RealNumberNotation] = ...
    ShowBase: ClassVar[QTextStream.NumberFlag] = ...
    SmartNotation: ClassVar[QTextStream.RealNumberNotation] = ...
    UppercaseBase: ClassVar[QTextStream.NumberFlag] = ...
    UppercaseDigits: ClassVar[QTextStream.NumberFlag] = ...
    WriteFailed: ClassVar[QTextStream.Status] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, array: typing.Union[QByteArray,bytes], openMode: typing.Union[QIODevice.OpenMode,QIODevice.OpenModeFlag] = ...) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    def atEnd(self) -> bool: ...
    def autoDetectUnicode(self) -> bool: ...
    def codec(self) -> QTextCodec: ...
    def device(self) -> QIODevice: ...
    def fieldAlignment(self) -> QTextStream.FieldAlignment: ...
    def fieldWidth(self) -> int: ...
    def flush(self) -> None: ...
    def generateByteOrderMark(self) -> bool: ...
    def integerBase(self) -> int: ...
    def locale(self) -> QLocale: ...
    def numberFlags(self) -> typing.Union[QTextStream.NumberFlags,QTextStream.NumberFlag]: ...
    def padChar(self) -> str: ...
    def pos(self) -> int: ...
    def read(self, maxlen: int) -> str: ...
    def readAll(self) -> str: ...
    def readLine(self, maxlen: int = ...) -> str: ...
    def realNumberNotation(self) -> QTextStream.RealNumberNotation: ...
    def realNumberPrecision(self) -> int: ...
    def reset(self) -> None: ...
    def resetStatus(self) -> None: ...
    def seek(self, pos: int) -> bool: ...
    def setAutoDetectUnicode(self, enabled: bool) -> None: ...
    @overload
    def setCodec(self, codec: QTextCodec) -> None: ...
    @overload
    def setCodec(self, codecName: bytes) -> None: ...
    def setDevice(self, device: QIODevice) -> None: ...
    def setFieldAlignment(self, alignment: QTextStream.FieldAlignment) -> None: ...
    def setFieldWidth(self, width: int) -> None: ...
    def setGenerateByteOrderMark(self, generate: bool) -> None: ...
    def setIntegerBase(self, base: int) -> None: ...
    def setLocale(self, locale: QLocale) -> None: ...
    def setNumberFlags(self, flags: typing.Union[QTextStream.NumberFlags,QTextStream.NumberFlag]) -> None: ...
    def setPadChar(self, ch: str) -> None: ...
    def setRealNumberNotation(self, notation: QTextStream.RealNumberNotation) -> None: ...
    def setRealNumberPrecision(self, precision: int) -> None: ...
    def setStatus(self, status: QTextStream.Status) -> None: ...
    def skipWhiteSpace(self) -> None: ...
    def status(self) -> QTextStream.Status: ...
    def string(self) -> typing.List[str]: ...
    @overload
    def __lshift__(self, array: typing.Union[QByteArray,bytes]) -> QTextStream: ...
    @overload
    def __lshift__(self, ch: str) -> QTextStream: ...
    @overload
    def __lshift__(self, ch: int) -> QTextStream: ...
    @overload
    def __lshift__(self, f: float) -> QTextStream: ...
    @overload
    def __lshift__(self, i: int) -> QTextStream: ...
    @overload
    def __lshift__(self, m: QTextStreamManipulator) -> QTextStream: ...
    @overload
    def __lshift__(self, s: str) -> QTextStream: ...
    def __rlshift__(self, other) -> Any: ...
    def __rrshift__(self, other) -> Any: ...
    def __rshift__(self, array: typing.Union[QByteArray,bytes]) -> QTextStream: ...

class QTextStreamManipulator(shiboken2.Object):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def exec_(self, s: QTextStream) -> None: ...
    def __copy__(self) -> None: ...

class QThread(QObject):
    class Priority:
        HighPriority: ClassVar[QThread.Priority] = ...
        HighestPriority: ClassVar[QThread.Priority] = ...
        IdlePriority: ClassVar[QThread.Priority] = ...
        InheritPriority: ClassVar[QThread.Priority] = ...
        LowPriority: ClassVar[QThread.Priority] = ...
        LowestPriority: ClassVar[QThread.Priority] = ...
        NormalPriority: ClassVar[QThread.Priority] = ...
        TimeCriticalPriority: ClassVar[QThread.Priority] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __and__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __rand__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __rmul__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __ror__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __rsub__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __rxor__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __sub__(self, other: typing.SupportsInt) -> QThread.Priority: ...
        def __xor__(self, other: typing.SupportsInt) -> QThread.Priority: ...
    HighPriority: ClassVar[QThread.Priority] = ...
    HighestPriority: ClassVar[QThread.Priority] = ...
    IdlePriority: ClassVar[QThread.Priority] = ...
    InheritPriority: ClassVar[QThread.Priority] = ...
    LowPriority: ClassVar[QThread.Priority] = ...
    LowestPriority: ClassVar[QThread.Priority] = ...
    NormalPriority: ClassVar[QThread.Priority] = ...
    TimeCriticalPriority: ClassVar[QThread.Priority] = ...
    finished: ClassVar[Signal] = ...
    started: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., finished: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., started: typing.Callable = ...) -> None: ...
    @classmethod
    def currentThread(cls) -> QThread: ...
    def event(self, event: QEvent) -> bool: ...
    def eventDispatcher(self) -> QAbstractEventDispatcher: ...
    def exec_(self) -> int: ...
    def exit(self, retcode: int = ...) -> None: ...
    @classmethod
    def idealThreadCount(cls) -> int: ...
    def isFinished(self) -> bool: ...
    def isInterruptionRequested(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def loopLevel(self) -> int: ...
    @classmethod
    def msleep(cls, arg__1: int) -> None: ...
    def priority(self) -> QThread.Priority: ...
    def quit(self) -> None: ...
    def requestInterruption(self) -> None: ...
    def run(self) -> None: ...
    def setEventDispatcher(self, eventDispatcher: QAbstractEventDispatcher) -> None: ...
    def setPriority(self, priority: QThread.Priority) -> None: ...
    def setStackSize(self, stackSize: int) -> None: ...
    @classmethod
    def setTerminationEnabled(cls, enabled: bool = ...) -> None: ...
    @classmethod
    def sleep(cls, arg__1: int) -> None: ...
    def stackSize(self) -> int: ...
    def start(self, priority: QThread.Priority = ...) -> None: ...
    def terminate(self) -> None: ...
    @classmethod
    def usleep(cls, arg__1: int) -> None: ...
    @overload
    def wait(self, deadline: QDeadlineTimer = ...) -> bool: ...
    @overload
    def wait(self, time: int) -> bool: ...
    @classmethod
    def yieldCurrentThread(cls) -> None: ...

class QThreadPool(QObject):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., activeThreadCount: int = ..., destroyed: typing.Callable = ..., expiryTimeout: int = ..., maxThreadCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., stackSize: int = ...) -> None: ...
    def activeThreadCount(self) -> int: ...
    def cancel(self, runnable: QRunnable) -> None: ...
    def clear(self) -> None: ...
    def contains(self, thread: QThread) -> bool: ...
    def expiryTimeout(self) -> int: ...
    @classmethod
    def globalInstance(cls) -> QThreadPool: ...
    def maxThreadCount(self) -> int: ...
    def releaseThread(self) -> None: ...
    def reserveThread(self) -> None: ...
    def setExpiryTimeout(self, expiryTimeout: int) -> None: ...
    def setMaxThreadCount(self, maxThreadCount: int) -> None: ...
    def setStackSize(self, stackSize: int) -> None: ...
    def stackSize(self) -> int: ...
    def start(self, runnable: QRunnable, priority: int = ...) -> None: ...
    def tryStart(self, runnable: QRunnable) -> bool: ...
    def tryTake(self, runnable: QRunnable) -> bool: ...
    def waitForDone(self, msecs: int = ...) -> bool: ...

class QTime(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QTime: QTime) -> None: ...
    @overload
    def __init__(self, h: int, m: int, s: int = ..., ms: int = ...) -> None: ...
    def addMSecs(self, ms: int) -> QTime: ...
    def addSecs(self, secs: int) -> QTime: ...
    @classmethod
    def currentTime(cls) -> QTime: ...
    def elapsed(self) -> int: ...
    @classmethod
    def fromMSecsSinceStartOfDay(cls, msecs: int) -> QTime: ...
    @classmethod
    @overload
    def fromString(cls, s: str, f: Qt.DateFormat = ...) -> QTime: ...
    @classmethod
    @overload
    def fromString(cls, s: str, format: str) -> QTime: ...
    def hour(self) -> int: ...
    def isNull(self) -> bool: ...
    @classmethod
    @overload
    def isValid(cls, h: int, m: int, s: int, ms: int = ...) -> bool: ...
    @classmethod
    @overload
    def isValid(cls, self) -> bool: ...
    def minute(self) -> int: ...
    def msec(self) -> int: ...
    def msecsSinceStartOfDay(self) -> int: ...
    def msecsTo(self, arg__1: QTime) -> int: ...
    def restart(self) -> int: ...
    def second(self) -> int: ...
    def secsTo(self, arg__1: QTime) -> int: ...
    def setHMS(self, h: int, m: int, s: int, ms: int = ...) -> bool: ...
    def start(self) -> None: ...
    def toPython(self) -> object: ...
    @overload
    def toString(self, f: Qt.DateFormat = ...) -> str: ...
    @overload
    def toString(self, format: str) -> str: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QTimeLine(QObject):
    class CurveShape:
        CosineCurve: ClassVar[QTimeLine.CurveShape] = ...
        EaseInCurve: ClassVar[QTimeLine.CurveShape] = ...
        EaseInOutCurve: ClassVar[QTimeLine.CurveShape] = ...
        EaseOutCurve: ClassVar[QTimeLine.CurveShape] = ...
        LinearCurve: ClassVar[QTimeLine.CurveShape] = ...
        SineCurve: ClassVar[QTimeLine.CurveShape] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __and__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __rand__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __ror__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __sub__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...
        def __xor__(self, other: typing.SupportsInt) -> QTimeLine.CurveShape: ...

    class Direction:
        Backward: ClassVar[QTimeLine.Direction] = ...
        Forward: ClassVar[QTimeLine.Direction] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __and__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __rand__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __ror__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __sub__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...
        def __xor__(self, other: typing.SupportsInt) -> QTimeLine.Direction: ...

    class State:
        NotRunning: ClassVar[QTimeLine.State] = ...
        Paused: ClassVar[QTimeLine.State] = ...
        Running: ClassVar[QTimeLine.State] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __and__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __rand__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __ror__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __sub__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
        def __xor__(self, other: typing.SupportsInt) -> QTimeLine.State: ...
    Backward: ClassVar[QTimeLine.Direction] = ...
    CosineCurve: ClassVar[QTimeLine.CurveShape] = ...
    EaseInCurve: ClassVar[QTimeLine.CurveShape] = ...
    EaseInOutCurve: ClassVar[QTimeLine.CurveShape] = ...
    EaseOutCurve: ClassVar[QTimeLine.CurveShape] = ...
    Forward: ClassVar[QTimeLine.Direction] = ...
    LinearCurve: ClassVar[QTimeLine.CurveShape] = ...
    NotRunning: ClassVar[QTimeLine.State] = ...
    Paused: ClassVar[QTimeLine.State] = ...
    Running: ClassVar[QTimeLine.State] = ...
    SineCurve: ClassVar[QTimeLine.CurveShape] = ...
    finished: ClassVar[Signal] = ...
    frameChanged: ClassVar[Signal] = ...
    stateChanged: ClassVar[Signal] = ...
    staticMetaObject: ClassVar[QMetaObject] = ...
    valueChanged: ClassVar[Signal] = ...
    def __init__(self, duration: int = ..., parent: typing.Union[QObject,None] = ..., currentTime: int = ..., curveShape: typing.Any = ..., destroyed: typing.Callable = ..., direction: typing.Any = ..., easingCurve: QEasingCurve = ..., finished: typing.Callable = ..., frameChanged: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., stateChanged: typing.Callable = ..., updateInterval: int = ..., valueChanged: typing.Callable = ...) -> None: ...
    def currentFrame(self) -> int: ...
    def currentTime(self) -> int: ...
    def currentValue(self) -> float: ...
    def curveShape(self) -> QTimeLine.CurveShape: ...
    def direction(self) -> QTimeLine.Direction: ...
    def duration(self) -> int: ...
    def easingCurve(self) -> QEasingCurve: ...
    def endFrame(self) -> int: ...
    def frameForTime(self, msec: int) -> int: ...
    def loopCount(self) -> int: ...
    def resume(self) -> None: ...
    def setCurrentTime(self, msec: int) -> None: ...
    def setCurveShape(self, shape: QTimeLine.CurveShape) -> None: ...
    def setDirection(self, direction: QTimeLine.Direction) -> None: ...
    def setDuration(self, duration: int) -> None: ...
    def setEasingCurve(self, curve: QEasingCurve) -> None: ...
    def setEndFrame(self, frame: int) -> None: ...
    def setFrameRange(self, startFrame: int, endFrame: int) -> None: ...
    def setLoopCount(self, count: int) -> None: ...
    def setPaused(self, paused: bool) -> None: ...
    def setStartFrame(self, frame: int) -> None: ...
    def setUpdateInterval(self, interval: int) -> None: ...
    def start(self) -> None: ...
    def startFrame(self) -> int: ...
    def state(self) -> QTimeLine.State: ...
    def stop(self) -> None: ...
    def timerEvent(self, event: QTimerEvent) -> None: ...
    def toggleDirection(self) -> None: ...
    def updateInterval(self) -> int: ...
    def valueForTime(self, msec: int) -> float: ...

class QTimeZone(shiboken2.Object):
    class NameType:
        DefaultName: ClassVar[QTimeZone.NameType] = ...
        LongName: ClassVar[QTimeZone.NameType] = ...
        OffsetName: ClassVar[QTimeZone.NameType] = ...
        ShortName: ClassVar[QTimeZone.NameType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __and__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __rand__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __ror__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __sub__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...
        def __xor__(self, other: typing.SupportsInt) -> QTimeZone.NameType: ...

    class OffsetData(shiboken2.Object):
        abbreviation: Any
        atUtc: Any
        daylightTimeOffset: Any
        offsetFromUtc: Any
        standardTimeOffset: Any
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, OffsetData: QTimeZone.OffsetData) -> None: ...
        def __copy__(self) -> None: ...

    class TimeType:
        DaylightTime: ClassVar[QTimeZone.TimeType] = ...
        GenericTime: ClassVar[QTimeZone.TimeType] = ...
        StandardTime: ClassVar[QTimeZone.TimeType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __and__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __rand__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __ror__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __sub__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
        def __xor__(self, other: typing.SupportsInt) -> QTimeZone.TimeType: ...
    DaylightTime: ClassVar[QTimeZone.TimeType] = ...
    DefaultName: ClassVar[QTimeZone.NameType] = ...
    GenericTime: ClassVar[QTimeZone.TimeType] = ...
    LongName: ClassVar[QTimeZone.NameType] = ...
    OffsetName: ClassVar[QTimeZone.NameType] = ...
    ShortName: ClassVar[QTimeZone.NameType] = ...
    StandardTime: ClassVar[QTimeZone.TimeType] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ianaId: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, offsetSeconds: int) -> None: ...
    @overload
    def __init__(self, other: QTimeZone) -> None: ...
    @overload
    def __init__(self, zoneId: typing.Union[QByteArray,bytes], offsetSeconds: int, name: str, abbreviation: str, country: QLocale.Country = ..., comment: str = ...) -> None: ...
    def abbreviation(self, atDateTime: QDateTime) -> str: ...
    @classmethod
    @overload
    def availableTimeZoneIds(cls) -> typing.List[QByteArray]: ...
    @classmethod
    @overload
    def availableTimeZoneIds(cls, country: QLocale.Country) -> typing.List[QByteArray]: ...
    @classmethod
    @overload
    def availableTimeZoneIds(cls, offsetSeconds: int) -> typing.List[QByteArray]: ...
    def comment(self) -> str: ...
    def country(self) -> QLocale.Country: ...
    def daylightTimeOffset(self, atDateTime: QDateTime) -> int: ...
    @overload
    def displayName(self, atDateTime: QDateTime, nameType: QTimeZone.NameType = ..., locale: QLocale = ...) -> str: ...
    @overload
    def displayName(self, timeType: QTimeZone.TimeType, nameType: QTimeZone.NameType = ..., locale: QLocale = ...) -> str: ...
    def hasDaylightTime(self) -> bool: ...
    def hasTransitions(self) -> bool: ...
    @classmethod
    def ianaIdToWindowsId(cls, ianaId: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    def id(self) -> QByteArray: ...
    def isDaylightTime(self, atDateTime: QDateTime) -> bool: ...
    @classmethod
    def isTimeZoneIdAvailable(cls, ianaId: typing.Union[QByteArray,bytes]) -> bool: ...
    def isValid(self) -> bool: ...
    def nextTransition(self, afterDateTime: QDateTime) -> QTimeZone.OffsetData: ...
    def offsetData(self, forDateTime: QDateTime) -> QTimeZone.OffsetData: ...
    def offsetFromUtc(self, atDateTime: QDateTime) -> int: ...
    def previousTransition(self, beforeDateTime: QDateTime) -> QTimeZone.OffsetData: ...
    def standardTimeOffset(self, atDateTime: QDateTime) -> int: ...
    def swap(self, other: QTimeZone) -> None: ...
    @classmethod
    def systemTimeZone(cls) -> QTimeZone: ...
    @classmethod
    def systemTimeZoneId(cls) -> QByteArray: ...
    def transitions(self, fromDateTime: QDateTime, toDateTime: QDateTime) -> typing.List[QTimeZone.OffsetData]: ...
    @classmethod
    def utc(cls) -> QTimeZone: ...
    @classmethod
    @overload
    def windowsIdToDefaultIanaId(cls, windowsId: typing.Union[QByteArray,bytes]) -> QByteArray: ...
    @classmethod
    @overload
    def windowsIdToDefaultIanaId(cls, windowsId: typing.Union[QByteArray,bytes], country: QLocale.Country) -> QByteArray: ...
    @classmethod
    @overload
    def windowsIdToIanaIds(cls, windowsId: typing.Union[QByteArray,bytes]) -> typing.List[QByteArray]: ...
    @classmethod
    @overload
    def windowsIdToIanaIds(cls, windowsId: typing.Union[QByteArray,bytes], country: QLocale.Country) -> typing.List[QByteArray]: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QTimer(QObject):
    staticMetaObject: ClassVar[QMetaObject] = ...
    timeout: ClassVar[Signal] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., active: bool = ..., destroyed: typing.Callable = ..., interval: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., remainingTime: int = ..., singleShot: bool = ..., timeout: typing.Callable = ..., timerType: Qt.TimerType = ...) -> None: ...
    def interval(self) -> int: ...
    def isActive(self) -> bool: ...
    def isSingleShot(self) -> bool: ...
    def killTimer(self, arg__1: int) -> None: ...
    def remainingTime(self) -> int: ...
    def setInterval(self, msec: int) -> None: ...
    def setSingleShot(self, singleShot: bool) -> None: ...
    def setTimerType(self, atype: Qt.TimerType) -> None: ...
    @classmethod
    @overload
    def singleShot(cls, arg__1: int, arg__2: typing.Callable) -> None: ...
    @classmethod
    @overload
    def singleShot(cls, msec: int, receiver: QObject, member: bytes) -> None: ...
    @classmethod
    @overload
    def singleShot(cls, msec: int, timerType: Qt.TimerType, receiver: QObject, member: bytes) -> None: ...
    @overload
    def start(self) -> None: ...
    @overload
    def start(self, msec: int) -> None: ...
    def stop(self) -> None: ...
    def timerEvent(self, arg__1: QTimerEvent) -> None: ...
    def timerId(self) -> int: ...
    def timerType(self) -> Qt.TimerType: ...

class QTimerEvent(QEvent):
    def __init__(self, timerId: int) -> None: ...
    def timerId(self) -> int: ...

class QTranslator(QObject):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., destroyed: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ...) -> None: ...
    def filePath(self) -> str: ...
    def isEmpty(self) -> bool: ...
    def language(self) -> str: ...
    @overload
    def load(self, data: bytes, len: int, directory: str = ...) -> bool: ...
    @overload
    def load(self, filename: str, directory: str = ..., search_delimiters: str = ..., suffix: str = ...) -> bool: ...
    @overload
    def load(self, locale: QLocale, filename: str, prefix: str = ..., directory: str = ..., suffix: str = ...) -> bool: ...
    def translate(self, context: bytes, sourceText: bytes, disambiguation: typing.Union[bytes,None] = ..., n: int = ...) -> str: ...

class QTransposeProxyModel(QAbstractProxyModel):
    staticMetaObject: ClassVar[QMetaObject] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., columnsAboutToBeInserted: typing.Callable = ..., columnsAboutToBeMoved: typing.Callable = ..., columnsAboutToBeRemoved: typing.Callable = ..., columnsInserted: typing.Callable = ..., columnsMoved: typing.Callable = ..., columnsRemoved: typing.Callable = ..., dataChanged: typing.Callable = ..., destroyed: typing.Callable = ..., headerDataChanged: typing.Callable = ..., layoutAboutToBeChanged: typing.Callable = ..., layoutChanged: typing.Callable = ..., modelAboutToBeReset: typing.Callable = ..., modelReset: typing.Callable = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., rowsAboutToBeInserted: typing.Callable = ..., rowsAboutToBeMoved: typing.Callable = ..., rowsAboutToBeRemoved: typing.Callable = ..., rowsInserted: typing.Callable = ..., rowsMoved: typing.Callable = ..., rowsRemoved: typing.Callable = ..., sourceModel: typing.Any = ..., sourceModelChanged: typing.Callable = ...) -> None: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    def headerData(self, section: int, orientation: Qt.Orientation, role: Qt.ItemDataRole = ...) -> typing.Any: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def itemData(self, index: QModelIndex) -> typing.Dict[int,typing.Any]: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def moveColumns(self, sourceParent: QModelIndex, sourceColumn: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveRows(self, sourceParent: QModelIndex, sourceRow: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    @overload
    def parent(self) -> QObject: ...
    @overload
    def parent(self, index: QModelIndex) -> QModelIndex: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def setHeaderData(self, section: int, orientation: Qt.Orientation, value: typing.Any, role: Qt.ItemDataRole = ...) -> bool: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int,typing.Any]) -> bool: ...
    def setSourceModel(self, newSourceModel: QAbstractItemModel) -> None: ...
    def sort(self, column: int, order: Qt.SortOrder = ...) -> None: ...
    def span(self, index: QModelIndex) -> QSize: ...

class QUrl(shiboken2.Object):
    class ComponentFormattingOption:
        DecodeReserved: ClassVar[QUrl.ComponentFormattingOption] = ...
        EncodeDelimiters: ClassVar[QUrl.ComponentFormattingOption] = ...
        EncodeReserved: ClassVar[QUrl.ComponentFormattingOption] = ...
        EncodeSpaces: ClassVar[QUrl.ComponentFormattingOption] = ...
        EncodeUnicode: ClassVar[QUrl.ComponentFormattingOption] = ...
        FullyDecoded: ClassVar[QUrl.ComponentFormattingOption] = ...
        FullyEncoded: ClassVar[QUrl.ComponentFormattingOption] = ...
        PrettyDecoded: ClassVar[QUrl.ComponentFormattingOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QUrl.ComponentFormattingOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...

    class FormattingOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QUrl.FormattingOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QUrl.FormattingOptions: ...

    class ParsingMode:
        DecodedMode: ClassVar[QUrl.ParsingMode] = ...
        StrictMode: ClassVar[QUrl.ParsingMode] = ...
        TolerantMode: ClassVar[QUrl.ParsingMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __and__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __rand__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __ror__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __sub__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...
        def __xor__(self, other: typing.SupportsInt) -> QUrl.ParsingMode: ...

    class UrlFormattingOption:
        None_: ClassVar[QUrl.UrlFormattingOption] = ...
        NormalizePathSegments: ClassVar[QUrl.UrlFormattingOption] = ...
        PreferLocalFile: ClassVar[QUrl.UrlFormattingOption] = ...
        RemoveAuthority: ClassVar[QUrl.UrlFormattingOption] = ...
        RemoveFilename: ClassVar[QUrl.UrlFormattingOption] = ...
        RemoveFragment: ClassVar[QUrl.UrlFormattingOption] = ...
        RemovePassword: ClassVar[QUrl.UrlFormattingOption] = ...
        RemovePath: ClassVar[QUrl.UrlFormattingOption] = ...
        RemovePort: ClassVar[QUrl.UrlFormattingOption] = ...
        RemoveQuery: ClassVar[QUrl.UrlFormattingOption] = ...
        RemoveScheme: ClassVar[QUrl.UrlFormattingOption] = ...
        RemoveUserInfo: ClassVar[QUrl.UrlFormattingOption] = ...
        StripTrailingSlash: ClassVar[QUrl.UrlFormattingOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __and__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __rand__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __rmul__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __ror__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __rsub__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __sub__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...
        def __xor__(self, other: typing.SupportsInt) -> QUrl.UrlFormattingOption: ...

    class UserInputResolutionOption:
        AssumeLocalFile: ClassVar[QUrl.UserInputResolutionOption] = ...
        DefaultResolution: ClassVar[QUrl.UserInputResolutionOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QUrl.UserInputResolutionOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...

    class UserInputResolutionOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> QUrl.UserInputResolutionOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> QUrl.UserInputResolutionOptions: ...
    AssumeLocalFile: ClassVar[QUrl.UserInputResolutionOption] = ...
    DecodeReserved: ClassVar[QUrl.ComponentFormattingOption] = ...
    DecodedMode: ClassVar[QUrl.ParsingMode] = ...
    DefaultResolution: ClassVar[QUrl.UserInputResolutionOption] = ...
    EncodeDelimiters: ClassVar[QUrl.ComponentFormattingOption] = ...
    EncodeReserved: ClassVar[QUrl.ComponentFormattingOption] = ...
    EncodeSpaces: ClassVar[QUrl.ComponentFormattingOption] = ...
    EncodeUnicode: ClassVar[QUrl.ComponentFormattingOption] = ...
    FullyDecoded: ClassVar[QUrl.ComponentFormattingOption] = ...
    FullyEncoded: ClassVar[QUrl.ComponentFormattingOption] = ...
    None_: ClassVar[QUrl.UrlFormattingOption] = ...
    NormalizePathSegments: ClassVar[QUrl.UrlFormattingOption] = ...
    PreferLocalFile: ClassVar[QUrl.UrlFormattingOption] = ...
    PrettyDecoded: ClassVar[QUrl.ComponentFormattingOption] = ...
    RemoveAuthority: ClassVar[QUrl.UrlFormattingOption] = ...
    RemoveFilename: ClassVar[QUrl.UrlFormattingOption] = ...
    RemoveFragment: ClassVar[QUrl.UrlFormattingOption] = ...
    RemovePassword: ClassVar[QUrl.UrlFormattingOption] = ...
    RemovePath: ClassVar[QUrl.UrlFormattingOption] = ...
    RemovePort: ClassVar[QUrl.UrlFormattingOption] = ...
    RemoveQuery: ClassVar[QUrl.UrlFormattingOption] = ...
    RemoveScheme: ClassVar[QUrl.UrlFormattingOption] = ...
    RemoveUserInfo: ClassVar[QUrl.UrlFormattingOption] = ...
    StrictMode: ClassVar[QUrl.ParsingMode] = ...
    StripTrailingSlash: ClassVar[QUrl.UrlFormattingOption] = ...
    TolerantMode: ClassVar[QUrl.ParsingMode] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: QUrl) -> None: ...
    @overload
    def __init__(self, url: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def adjusted(self, options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption]) -> QUrl: ...
    def authority(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    def clear(self) -> None: ...
    def errorString(self) -> str: ...
    def fileName(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    def fragment(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    @classmethod
    def fromAce(cls, arg__1: typing.Union[QByteArray,bytes]) -> str: ...
    @classmethod
    def fromEncoded(cls, url: typing.Union[QByteArray,bytes], mode: QUrl.ParsingMode = ...) -> QUrl: ...
    @classmethod
    def fromLocalFile(cls, localfile: str) -> QUrl: ...
    @classmethod
    def fromPercentEncoding(cls, arg__1: typing.Union[QByteArray,bytes]) -> str: ...
    @classmethod
    def fromStringList(cls, uris: typing.Sequence[str], mode: QUrl.ParsingMode = ...) -> typing.List[QUrl]: ...
    @classmethod
    @overload
    def fromUserInput(cls, userInput: str) -> QUrl: ...
    @classmethod
    @overload
    def fromUserInput(cls, userInput: str, workingDirectory: str, options: typing.Union[QUrl.UserInputResolutionOptions,QUrl.UserInputResolutionOption] = ...) -> QUrl: ...
    def hasFragment(self) -> bool: ...
    def hasQuery(self) -> bool: ...
    def host(self, arg__1: QUrl.ComponentFormattingOption = ...) -> str: ...
    @classmethod
    def idnWhitelist(cls) -> typing.List[str]: ...
    def isEmpty(self) -> bool: ...
    def isLocalFile(self) -> bool: ...
    def isParentOf(self, url: QUrl) -> bool: ...
    def isRelative(self) -> bool: ...
    def isValid(self) -> bool: ...
    def matches(self, url: QUrl, options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption]) -> bool: ...
    def password(self, arg__1: QUrl.ComponentFormattingOption = ...) -> str: ...
    def path(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    def port(self, defaultPort: int = ...) -> int: ...
    def query(self, arg__1: QUrl.ComponentFormattingOption = ...) -> str: ...
    def resolved(self, relative: QUrl) -> QUrl: ...
    def scheme(self) -> str: ...
    def setAuthority(self, authority: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setFragment(self, fragment: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setHost(self, host: str, mode: QUrl.ParsingMode = ...) -> None: ...
    @classmethod
    def setIdnWhitelist(cls, arg__1: typing.Sequence[str]) -> None: ...
    def setPassword(self, password: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setPath(self, path: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setPort(self, port: int) -> None: ...
    @overload
    def setQuery(self, query: QUrlQuery) -> None: ...
    @overload
    def setQuery(self, query: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setScheme(self, scheme: str) -> None: ...
    def setUrl(self, url: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setUserInfo(self, userInfo: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def setUserName(self, userName: str, mode: QUrl.ParsingMode = ...) -> None: ...
    def swap(self, other: QUrl) -> None: ...
    @classmethod
    def toAce(cls, arg__1: str) -> QByteArray: ...
    def toDisplayString(self, options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption] = ...) -> str: ...
    def toEncoded(self, options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption] = ...) -> QByteArray: ...
    def toLocalFile(self) -> str: ...
    @classmethod
    def toPercentEncoding(cls, arg__1: str, exclude: typing.Union[QByteArray,bytes] = ..., include: typing.Union[QByteArray,bytes] = ...) -> QByteArray: ...
    def toString(self, options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption] = ...) -> str: ...
    @classmethod
    def toStringList(cls, uris: typing.Sequence[QUrl], options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption] = ...) -> typing.List[str]: ...
    def topLevelDomain(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    def url(self, options: typing.Union[QUrl.FormattingOptions,QUrl.ComponentFormattingOption] = ...) -> str: ...
    def userInfo(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    def userName(self, options: QUrl.ComponentFormattingOption = ...) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QUrlQuery(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QUrlQuery) -> None: ...
    @overload
    def __init__(self, queryString: str) -> None: ...
    @overload
    def __init__(self, url: QUrl) -> None: ...
    def addQueryItem(self, key: str, value: str) -> None: ...
    def allQueryItemValues(self, key: str, encoding: QUrl.ComponentFormattingOption = ...) -> typing.List[str]: ...
    def clear(self) -> None: ...
    @classmethod
    def defaultQueryPairDelimiter(cls) -> str: ...
    @classmethod
    def defaultQueryValueDelimiter(cls) -> str: ...
    def hasQueryItem(self, key: str) -> bool: ...
    def isEmpty(self) -> bool: ...
    def query(self, encoding: QUrl.ComponentFormattingOption = ...) -> str: ...
    def queryItemValue(self, key: str, encoding: QUrl.ComponentFormattingOption = ...) -> str: ...
    def queryItems(self, encoding: QUrl.ComponentFormattingOption = ...) -> typing.List[typing.Tuple[str,str]]: ...
    def queryPairDelimiter(self) -> str: ...
    def queryValueDelimiter(self) -> str: ...
    def removeAllQueryItems(self, key: str) -> None: ...
    def removeQueryItem(self, key: str) -> None: ...
    def setQuery(self, queryString: str) -> None: ...
    def setQueryDelimiters(self, valueDelimiter: str, pairDelimiter: str) -> None: ...
    def setQueryItems(self, query: typing.Sequence[typing.Tuple[str,str]]) -> None: ...
    def swap(self, other: QUrlQuery) -> None: ...
    def toString(self, encoding: QUrl.ComponentFormattingOption = ...) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QUuid(shiboken2.Object):
    class StringFormat:
        Id128: ClassVar[QUuid.StringFormat] = ...
        WithBraces: ClassVar[QUuid.StringFormat] = ...
        WithoutBraces: ClassVar[QUuid.StringFormat] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __and__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __rand__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __rmul__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __ror__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __rsub__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __sub__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...
        def __xor__(self, other: typing.SupportsInt) -> QUuid.StringFormat: ...

    class Variant:
        DCE: ClassVar[QUuid.Variant] = ...
        Microsoft: ClassVar[QUuid.Variant] = ...
        NCS: ClassVar[QUuid.Variant] = ...
        Reserved: ClassVar[QUuid.Variant] = ...
        VarUnknown: ClassVar[QUuid.Variant] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __and__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __rand__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __rmul__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __ror__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __rsub__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __sub__(self, other: typing.SupportsInt) -> QUuid.Variant: ...
        def __xor__(self, other: typing.SupportsInt) -> QUuid.Variant: ...

    class Version:
        EmbeddedPOSIX: ClassVar[QUuid.Version] = ...
        Md5: ClassVar[QUuid.Version] = ...
        Name: ClassVar[QUuid.Version] = ...
        Random: ClassVar[QUuid.Version] = ...
        Sha1: ClassVar[QUuid.Version] = ...
        Time: ClassVar[QUuid.Version] = ...
        VerUnknown: ClassVar[QUuid.Version] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __and__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __rand__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __rmul__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __ror__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __rsub__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __rxor__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __sub__(self, other: typing.SupportsInt) -> QUuid.Version: ...
        def __xor__(self, other: typing.SupportsInt) -> QUuid.Version: ...
    DCE: ClassVar[QUuid.Variant] = ...
    EmbeddedPOSIX: ClassVar[QUuid.Version] = ...
    Id128: ClassVar[QUuid.StringFormat] = ...
    Md5: ClassVar[QUuid.Version] = ...
    Microsoft: ClassVar[QUuid.Variant] = ...
    NCS: ClassVar[QUuid.Variant] = ...
    Name: ClassVar[QUuid.Version] = ...
    Random: ClassVar[QUuid.Version] = ...
    Reserved: ClassVar[QUuid.Variant] = ...
    Sha1: ClassVar[QUuid.Version] = ...
    Time: ClassVar[QUuid.Version] = ...
    VarUnknown: ClassVar[QUuid.Variant] = ...
    VerUnknown: ClassVar[QUuid.Version] = ...
    WithBraces: ClassVar[QUuid.StringFormat] = ...
    WithoutBraces: ClassVar[QUuid.StringFormat] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, arg__1: str) -> None: ...
    @overload
    def __init__(self, arg__1: bytes) -> None: ...
    @overload
    def __init__(self, l: int, w1: int, w2: int, b1: int, b2: int, b3: int, b4: int, b5: int, b6: int, b7: int, b8: int) -> None: ...
    @classmethod
    def createUuid(cls) -> QUuid: ...
    @classmethod
    @overload
    def createUuidV3(cls, ns: QUuid, baseData: typing.Union[QByteArray,bytes]) -> QUuid: ...
    @classmethod
    @overload
    def createUuidV3(cls, ns: QUuid, baseData: str) -> QUuid: ...
    @classmethod
    @overload
    def createUuidV5(cls, ns: QUuid, baseData: typing.Union[QByteArray,bytes]) -> QUuid: ...
    @classmethod
    @overload
    def createUuidV5(cls, ns: QUuid, baseData: str) -> QUuid: ...
    @classmethod
    def fromRfc4122(cls, arg__1: typing.Union[QByteArray,bytes]) -> QUuid: ...
    def isNull(self) -> bool: ...
    @overload
    def toByteArray(self) -> QByteArray: ...
    @overload
    def toByteArray(self, mode: QUuid.StringFormat) -> QByteArray: ...
    def toRfc4122(self) -> QByteArray: ...
    @overload
    def toString(self) -> str: ...
    @overload
    def toString(self, mode: QUuid.StringFormat) -> str: ...
    def variant(self) -> QUuid.Variant: ...
    def version(self) -> QUuid.Version: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QVariantAnimation(QAbstractAnimation):
    staticMetaObject: ClassVar[QMetaObject] = ...
    valueChanged: ClassVar[Signal] = ...
    def __init__(self, parent: typing.Union[QObject,None] = ..., currentLoop: int = ..., currentLoopChanged: typing.Callable = ..., currentTime: int = ..., currentValue: object = ..., destroyed: typing.Callable = ..., direction: QVariantAnimation.Direction = ..., directionChanged: typing.Callable = ..., duration: int = ..., easingCurve: QEasingCurve = ..., endValue: object = ..., finished: typing.Callable = ..., loopCount: int = ..., objectName: str = ..., objectNameChanged: typing.Callable = ..., startValue: object = ..., state: QVariantAnimation.State = ..., stateChanged: typing.Callable = ..., valueChanged: typing.Callable = ...) -> None: ...
    def currentValue(self) -> typing.Any: ...
    def duration(self) -> int: ...
    def easingCurve(self) -> QEasingCurve: ...
    def endValue(self) -> typing.Any: ...
    def event(self, event: QEvent) -> bool: ...
    def interpolated(self, from_: typing.Any, to: typing.Any, progress: float) -> typing.Any: ...
    def keyValueAt(self, step: float) -> typing.Any: ...
    def keyValues(self) -> typing.List[typing.Tuple[float,typing.Any]]: ...
    def setDuration(self, msecs: int) -> None: ...
    def setEasingCurve(self, easing: QEasingCurve) -> None: ...
    def setEndValue(self, value: typing.Any) -> None: ...
    def setKeyValueAt(self, step: float, value: typing.Any) -> None: ...
    def setKeyValues(self, values: typing.List[typing.Tuple[float,typing.Any]]) -> None: ...
    def setStartValue(self, value: typing.Any) -> None: ...
    def startValue(self) -> typing.Any: ...
    def updateCurrentTime(self, arg__1: int) -> None: ...
    def updateCurrentValue(self, value: typing.Any) -> None: ...
    def updateState(self, newState: QAbstractAnimation.State, oldState: QAbstractAnimation.State) -> None: ...

class QVersionNumber(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, maj: int) -> None: ...
    @overload
    def __init__(self, maj: int, min: int) -> None: ...
    @overload
    def __init__(self, maj: int, min: int, mic: int) -> None: ...
    @overload
    def __init__(self, seg: typing.List[int]) -> None: ...
    @classmethod
    def commonPrefix(cls, v1: QVersionNumber, v2: QVersionNumber) -> QVersionNumber: ...
    @classmethod
    def compare(cls, v1: QVersionNumber, v2: QVersionNumber) -> int: ...
    @classmethod
    def fromString(cls, string: str) -> typing.Tuple[QVersionNumber,int]: ...
    def isNormalized(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isPrefixOf(self, other: QVersionNumber) -> bool: ...
    def majorVersion(self) -> int: ...
    def microVersion(self) -> int: ...
    def minorVersion(self) -> int: ...
    def normalized(self) -> QVersionNumber: ...
    def segmentAt(self, index: int) -> int: ...
    def segmentCount(self) -> int: ...
    def segments(self) -> typing.List[int]: ...
    def toString(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QWaitCondition(shiboken2.Object):
    def __init__(self) -> None: ...
    def notify_all(self) -> None: ...
    def notify_one(self) -> None: ...
    @overload
    def wait(self, lockedMutex: QMutex, deadline: QDeadlineTimer = ...) -> bool: ...
    @overload
    def wait(self, lockedMutex: QMutex, time: int) -> bool: ...
    @overload
    def wait(self, lockedReadWriteLock: QReadWriteLock, deadline: QDeadlineTimer = ...) -> bool: ...
    @overload
    def wait(self, lockedReadWriteLock: QReadWriteLock, time: int) -> bool: ...
    def wakeAll(self) -> None: ...
    def wakeOne(self) -> None: ...

class QWriteLocker(shiboken2.Object):
    def __init__(self, readWriteLock: QReadWriteLock) -> None: ...
    def readWriteLock(self) -> QReadWriteLock: ...
    def relock(self) -> None: ...
    def unlock(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, arg__1: object, arg__2: object, arg__3: object) -> None: ...

class QXmlStreamAttribute(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QXmlStreamAttribute) -> None: ...
    @overload
    def __init__(self, namespaceUri: str, name: str, value: str) -> None: ...
    @overload
    def __init__(self, qualifiedName: str, value: str) -> None: ...
    def isDefault(self) -> bool: ...
    def name(self) -> str: ...
    def namespaceUri(self) -> str: ...
    def prefix(self) -> str: ...
    def qualifiedName(self) -> str: ...
    def value(self) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QXmlStreamAttributes(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, QXmlStreamAttributes: QXmlStreamAttributes) -> None: ...
    @overload
    def append(self, namespaceUri: str, name: str, value: str) -> None: ...
    @overload
    def append(self, qualifiedName: str, value: str) -> None: ...
    def at(self, i: int) -> QXmlStreamAttribute: ...
    def back(self) -> QXmlStreamAttribute: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def constData(self) -> QXmlStreamAttribute: ...
    def constFirst(self) -> QXmlStreamAttribute: ...
    def constLast(self) -> QXmlStreamAttribute: ...
    def contains(self, t: QXmlStreamAttribute) -> bool: ...
    @overload
    def count(self) -> int: ...
    @overload
    def count(self, t: QXmlStreamAttribute) -> int: ...
    def data(self) -> QXmlStreamAttribute: ...
    def empty(self) -> bool: ...
    def endsWith(self, t: QXmlStreamAttribute) -> bool: ...
    def fill(self, t: QXmlStreamAttribute, size: int = ...) -> typing.List[QXmlStreamAttribute]: ...
    def first(self) -> QXmlStreamAttribute: ...
    def front(self) -> QXmlStreamAttribute: ...
    @overload
    def hasAttribute(self, namespaceUri: str, name: str) -> bool: ...
    @overload
    def hasAttribute(self, qualifiedName: str) -> bool: ...
    def indexOf(self, t: QXmlStreamAttribute, from_: int = ...) -> int: ...
    @overload
    def insert(self, i: int, n: int, t: QXmlStreamAttribute) -> None: ...
    @overload
    def insert(self, i: int, t: QXmlStreamAttribute) -> None: ...
    def isEmpty(self) -> bool: ...
    def isSharedWith(self, other: typing.List[QXmlStreamAttribute]) -> bool: ...
    def last(self) -> QXmlStreamAttribute: ...
    def lastIndexOf(self, t: QXmlStreamAttribute, from_: int = ...) -> int: ...
    def length(self) -> int: ...
    def mid(self, pos: int, len: int = ...) -> typing.List[QXmlStreamAttribute]: ...
    def move(self, from_: int, to: int) -> None: ...
    def prepend(self, t: QXmlStreamAttribute) -> None: ...
    @overload
    def remove(self, i: int) -> None: ...
    @overload
    def remove(self, i: int, n: int) -> None: ...
    def removeAll(self, t: QXmlStreamAttribute) -> int: ...
    def removeAt(self, i: int) -> None: ...
    def removeFirst(self) -> None: ...
    def removeLast(self) -> None: ...
    def removeOne(self, t: QXmlStreamAttribute) -> bool: ...
    def replace(self, i: int, t: QXmlStreamAttribute) -> None: ...
    def reserve(self, size: int) -> None: ...
    def resize(self, size: int) -> None: ...
    def setSharable(self, sharable: bool) -> None: ...
    def shrink_to_fit(self) -> None: ...
    def size(self) -> int: ...
    def squeeze(self) -> None: ...
    def startsWith(self, t: QXmlStreamAttribute) -> bool: ...
    def swap(self, other: typing.List[QXmlStreamAttribute]) -> None: ...
    def swapItemsAt(self, i: int, j: int) -> None: ...
    def takeAt(self, i: int) -> QXmlStreamAttribute: ...
    def takeFirst(self) -> QXmlStreamAttribute: ...
    def takeLast(self) -> QXmlStreamAttribute: ...
    @overload
    def value(self, namespaceUri: str, name: str) -> str: ...
    @overload
    def value(self, qualifiedName: str) -> str: ...
    def __add__(self, l: typing.List[QXmlStreamAttribute]) -> typing.List[QXmlStreamAttribute]: ...
    def __copy__(self) -> None: ...
    def __delitem__(self, other) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index) -> Any: ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, t: QXmlStreamAttribute) -> typing.List[QXmlStreamAttribute]: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    @overload
    def __lshift__(self, l: typing.List[QXmlStreamAttribute]) -> typing.List[QXmlStreamAttribute]: ...
    @overload
    def __lshift__(self, t: QXmlStreamAttribute) -> typing.List[QXmlStreamAttribute]: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other) -> Any: ...
    def __rlshift__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> None: ...

class QXmlStreamEntityDeclaration(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QXmlStreamEntityDeclaration) -> None: ...
    def name(self) -> str: ...
    def notationName(self) -> str: ...
    def publicId(self) -> str: ...
    def systemId(self) -> str: ...
    def value(self) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QXmlStreamEntityResolver(shiboken2.Object):
    def __init__(self) -> None: ...
    def resolveEntity(self, publicId: str, systemId: str) -> str: ...
    def resolveUndeclaredEntity(self, name: str) -> str: ...

class QXmlStreamNamespaceDeclaration(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QXmlStreamNamespaceDeclaration) -> None: ...
    @overload
    def __init__(self, prefix: str, namespaceUri: str) -> None: ...
    def namespaceUri(self) -> str: ...
    def prefix(self) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QXmlStreamNotationDeclaration(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg__1: QXmlStreamNotationDeclaration) -> None: ...
    def name(self) -> str: ...
    def publicId(self) -> str: ...
    def systemId(self) -> str: ...
    def __copy__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class QXmlStreamReader(shiboken2.Object):
    class Error:
        CustomError: ClassVar[QXmlStreamReader.Error] = ...
        NoError: ClassVar[QXmlStreamReader.Error] = ...
        NotWellFormedError: ClassVar[QXmlStreamReader.Error] = ...
        PrematureEndOfDocumentError: ClassVar[QXmlStreamReader.Error] = ...
        UnexpectedElementError: ClassVar[QXmlStreamReader.Error] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __and__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __rand__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __rmul__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __ror__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __rsub__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __rxor__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __sub__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...
        def __xor__(self, other: typing.SupportsInt) -> QXmlStreamReader.Error: ...

    class ReadElementTextBehaviour:
        ErrorOnUnexpectedElement: ClassVar[QXmlStreamReader.ReadElementTextBehaviour] = ...
        IncludeChildElements: ClassVar[QXmlStreamReader.ReadElementTextBehaviour] = ...
        SkipChildElements: ClassVar[QXmlStreamReader.ReadElementTextBehaviour] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __and__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __rand__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __rmul__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __ror__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __rsub__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __rxor__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __sub__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...
        def __xor__(self, other: typing.SupportsInt) -> QXmlStreamReader.ReadElementTextBehaviour: ...

    class TokenType:
        Characters: ClassVar[QXmlStreamReader.TokenType] = ...
        Comment: ClassVar[QXmlStreamReader.TokenType] = ...
        DTD: ClassVar[QXmlStreamReader.TokenType] = ...
        EndDocument: ClassVar[QXmlStreamReader.TokenType] = ...
        EndElement: ClassVar[QXmlStreamReader.TokenType] = ...
        EntityReference: ClassVar[QXmlStreamReader.TokenType] = ...
        Invalid: ClassVar[QXmlStreamReader.TokenType] = ...
        NoToken: ClassVar[QXmlStreamReader.TokenType] = ...
        ProcessingInstruction: ClassVar[QXmlStreamReader.TokenType] = ...
        StartDocument: ClassVar[QXmlStreamReader.TokenType] = ...
        StartElement: ClassVar[QXmlStreamReader.TokenType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __and__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __rand__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __rmul__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __ror__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __rsub__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __rxor__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __sub__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
        def __xor__(self, other: typing.SupportsInt) -> QXmlStreamReader.TokenType: ...
    Characters: ClassVar[QXmlStreamReader.TokenType] = ...
    Comment: ClassVar[QXmlStreamReader.TokenType] = ...
    CustomError: ClassVar[QXmlStreamReader.Error] = ...
    DTD: ClassVar[QXmlStreamReader.TokenType] = ...
    EndDocument: ClassVar[QXmlStreamReader.TokenType] = ...
    EndElement: ClassVar[QXmlStreamReader.TokenType] = ...
    EntityReference: ClassVar[QXmlStreamReader.TokenType] = ...
    ErrorOnUnexpectedElement: ClassVar[QXmlStreamReader.ReadElementTextBehaviour] = ...
    IncludeChildElements: ClassVar[QXmlStreamReader.ReadElementTextBehaviour] = ...
    Invalid: ClassVar[QXmlStreamReader.TokenType] = ...
    NoError: ClassVar[QXmlStreamReader.Error] = ...
    NoToken: ClassVar[QXmlStreamReader.TokenType] = ...
    NotWellFormedError: ClassVar[QXmlStreamReader.Error] = ...
    PrematureEndOfDocumentError: ClassVar[QXmlStreamReader.Error] = ...
    ProcessingInstruction: ClassVar[QXmlStreamReader.TokenType] = ...
    SkipChildElements: ClassVar[QXmlStreamReader.ReadElementTextBehaviour] = ...
    StartDocument: ClassVar[QXmlStreamReader.TokenType] = ...
    StartElement: ClassVar[QXmlStreamReader.TokenType] = ...
    UnexpectedElementError: ClassVar[QXmlStreamReader.Error] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, data: str) -> None: ...
    @overload
    def __init__(self, data: bytes) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def addData(self, data: str) -> None: ...
    @overload
    def addData(self, data: bytes) -> None: ...
    def addExtraNamespaceDeclaration(self, extraNamespaceDeclaraction: QXmlStreamNamespaceDeclaration) -> None: ...
    def addExtraNamespaceDeclarations(self, extraNamespaceDeclaractions: typing.List[QXmlStreamNamespaceDeclaration]) -> None: ...
    def atEnd(self) -> bool: ...
    def attributes(self) -> QXmlStreamAttributes: ...
    def characterOffset(self) -> int: ...
    def clear(self) -> None: ...
    def columnNumber(self) -> int: ...
    def device(self) -> QIODevice: ...
    def documentEncoding(self) -> str: ...
    def documentVersion(self) -> str: ...
    def dtdName(self) -> str: ...
    def dtdPublicId(self) -> str: ...
    def dtdSystemId(self) -> str: ...
    def entityDeclarations(self) -> typing.List[QXmlStreamEntityDeclaration]: ...
    def entityExpansionLimit(self) -> int: ...
    def entityResolver(self) -> QXmlStreamEntityResolver: ...
    def error(self) -> QXmlStreamReader.Error: ...
    def errorString(self) -> str: ...
    def hasError(self) -> bool: ...
    def isCDATA(self) -> bool: ...
    def isCharacters(self) -> bool: ...
    def isComment(self) -> bool: ...
    def isDTD(self) -> bool: ...
    def isEndDocument(self) -> bool: ...
    def isEndElement(self) -> bool: ...
    def isEntityReference(self) -> bool: ...
    def isProcessingInstruction(self) -> bool: ...
    def isStandaloneDocument(self) -> bool: ...
    def isStartDocument(self) -> bool: ...
    def isStartElement(self) -> bool: ...
    def isWhitespace(self) -> bool: ...
    def lineNumber(self) -> int: ...
    def name(self) -> str: ...
    def namespaceDeclarations(self) -> typing.List[QXmlStreamNamespaceDeclaration]: ...
    def namespaceProcessing(self) -> bool: ...
    def namespaceUri(self) -> str: ...
    def notationDeclarations(self) -> typing.List[QXmlStreamNotationDeclaration]: ...
    def prefix(self) -> str: ...
    def processingInstructionData(self) -> str: ...
    def processingInstructionTarget(self) -> str: ...
    def qualifiedName(self) -> str: ...
    def raiseError(self, message: str = ...) -> None: ...
    def readElementText(self, behaviour: QXmlStreamReader.ReadElementTextBehaviour = ...) -> str: ...
    def readNext(self) -> QXmlStreamReader.TokenType: ...
    def readNextStartElement(self) -> bool: ...
    def setDevice(self, device: QIODevice) -> None: ...
    def setEntityExpansionLimit(self, limit: int) -> None: ...
    def setEntityResolver(self, resolver: QXmlStreamEntityResolver) -> None: ...
    def setNamespaceProcessing(self, arg__1: bool) -> None: ...
    def skipCurrentElement(self) -> None: ...
    def text(self) -> str: ...
    def tokenString(self) -> str: ...
    def tokenType(self) -> QXmlStreamReader.TokenType: ...

class QXmlStreamWriter(shiboken2.Object):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, array: typing.Union[QByteArray,bytes]) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    def autoFormatting(self) -> bool: ...
    def autoFormattingIndent(self) -> int: ...
    def codec(self) -> QTextCodec: ...
    def device(self) -> QIODevice: ...
    def hasError(self) -> bool: ...
    def setAutoFormatting(self, arg__1: bool) -> None: ...
    def setAutoFormattingIndent(self, spacesOrTabs: int) -> None: ...
    @overload
    def setCodec(self, codec: QTextCodec) -> None: ...
    @overload
    def setCodec(self, codecName: bytes) -> None: ...
    def setDevice(self, device: QIODevice) -> None: ...
    @overload
    def writeAttribute(self, attribute: QXmlStreamAttribute) -> None: ...
    @overload
    def writeAttribute(self, namespaceUri: str, name: str, value: str) -> None: ...
    @overload
    def writeAttribute(self, qualifiedName: str, value: str) -> None: ...
    def writeAttributes(self, attributes: QXmlStreamAttributes) -> None: ...
    def writeCDATA(self, text: str) -> None: ...
    def writeCharacters(self, text: str) -> None: ...
    def writeComment(self, text: str) -> None: ...
    def writeCurrentToken(self, reader: QXmlStreamReader) -> None: ...
    def writeDTD(self, dtd: str) -> None: ...
    def writeDefaultNamespace(self, namespaceUri: str) -> None: ...
    @overload
    def writeEmptyElement(self, namespaceUri: str, name: str) -> None: ...
    @overload
    def writeEmptyElement(self, qualifiedName: str) -> None: ...
    def writeEndDocument(self) -> None: ...
    def writeEndElement(self) -> None: ...
    def writeEntityReference(self, name: str) -> None: ...
    def writeNamespace(self, namespaceUri: str, prefix: str = ...) -> None: ...
    def writeProcessingInstruction(self, target: str, data: str = ...) -> None: ...
    @overload
    def writeStartDocument(self) -> None: ...
    @overload
    def writeStartDocument(self, version: str) -> None: ...
    @overload
    def writeStartDocument(self, version: str, standalone: bool) -> None: ...
    @overload
    def writeStartElement(self, namespaceUri: str, name: str) -> None: ...
    @overload
    def writeStartElement(self, qualifiedName: str) -> None: ...
    @overload
    def writeTextElement(self, namespaceUri: str, name: str, text: str) -> None: ...
    @overload
    def writeTextElement(self, qualifiedName: str, text: str) -> None: ...

class Qt(shiboken2.Object):
    class Alignment:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.Alignment: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Alignment: ...

    class AlignmentFlag:
        AlignAbsolute: ClassVar[Qt.AlignmentFlag] = ...
        AlignBaseline: ClassVar[Qt.AlignmentFlag] = ...
        AlignBottom: ClassVar[Qt.AlignmentFlag] = ...
        AlignCenter: ClassVar[Qt.AlignmentFlag] = ...
        AlignHCenter: ClassVar[Qt.AlignmentFlag] = ...
        AlignHorizontal_Mask: ClassVar[Qt.AlignmentFlag] = ...
        AlignJustify: ClassVar[Qt.AlignmentFlag] = ...
        AlignLeading: ClassVar[Qt.AlignmentFlag] = ...
        AlignLeft: ClassVar[Qt.AlignmentFlag] = ...
        AlignRight: ClassVar[Qt.AlignmentFlag] = ...
        AlignTop: ClassVar[Qt.AlignmentFlag] = ...
        AlignTrailing: ClassVar[Qt.AlignmentFlag] = ...
        AlignVCenter: ClassVar[Qt.AlignmentFlag] = ...
        AlignVertical_Mask: ClassVar[Qt.AlignmentFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.AlignmentFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Alignment: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Alignment: ...

    class AnchorPoint:
        AnchorBottom: ClassVar[Qt.AnchorPoint] = ...
        AnchorHorizontalCenter: ClassVar[Qt.AnchorPoint] = ...
        AnchorLeft: ClassVar[Qt.AnchorPoint] = ...
        AnchorRight: ClassVar[Qt.AnchorPoint] = ...
        AnchorTop: ClassVar[Qt.AnchorPoint] = ...
        AnchorVerticalCenter: ClassVar[Qt.AnchorPoint] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.AnchorPoint: ...

    class ApplicationAttribute:
        AA_AttributeCount: ClassVar[Qt.ApplicationAttribute] = ...
        AA_CompressHighFrequencyEvents: ClassVar[Qt.ApplicationAttribute] = ...
        AA_CompressTabletEvents: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DisableHighDpiScaling: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DisableNativeVirtualKeyboard: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DisableSessionManager: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DisableShaderDiskCache: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DisableWindowContextHelpButton: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DontCheckOpenGLContextThreadAffinity: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DontCreateNativeWidgetSiblings: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DontShowIconsInMenus: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DontShowShortcutsInContextMenus: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DontUseNativeDialogs: ClassVar[Qt.ApplicationAttribute] = ...
        AA_DontUseNativeMenuBar: ClassVar[Qt.ApplicationAttribute] = ...
        AA_EnableHighDpiScaling: ClassVar[Qt.ApplicationAttribute] = ...
        AA_ForceRasterWidgets: ClassVar[Qt.ApplicationAttribute] = ...
        AA_ImmediateWidgetCreation: ClassVar[Qt.ApplicationAttribute] = ...
        AA_MSWindowsUseDirect3DByDefault: ClassVar[Qt.ApplicationAttribute] = ...
        AA_MacDontSwapCtrlAndMeta: ClassVar[Qt.ApplicationAttribute] = ...
        AA_MacPluginApplication: ClassVar[Qt.ApplicationAttribute] = ...
        AA_NativeWindows: ClassVar[Qt.ApplicationAttribute] = ...
        AA_PluginApplication: ClassVar[Qt.ApplicationAttribute] = ...
        AA_SetPalette: ClassVar[Qt.ApplicationAttribute] = ...
        AA_ShareOpenGLContexts: ClassVar[Qt.ApplicationAttribute] = ...
        AA_SynthesizeMouseForUnhandledTabletEvents: ClassVar[Qt.ApplicationAttribute] = ...
        AA_SynthesizeMouseForUnhandledTouchEvents: ClassVar[Qt.ApplicationAttribute] = ...
        AA_SynthesizeTouchForUnhandledMouseEvents: ClassVar[Qt.ApplicationAttribute] = ...
        AA_Use96Dpi: ClassVar[Qt.ApplicationAttribute] = ...
        AA_UseDesktopOpenGL: ClassVar[Qt.ApplicationAttribute] = ...
        AA_UseHighDpiPixmaps: ClassVar[Qt.ApplicationAttribute] = ...
        AA_UseOpenGLES: ClassVar[Qt.ApplicationAttribute] = ...
        AA_UseSoftwareOpenGL: ClassVar[Qt.ApplicationAttribute] = ...
        AA_UseStyleSheetPropagationInWidgetStyles: ClassVar[Qt.ApplicationAttribute] = ...
        AA_X11InitThreads: ClassVar[Qt.ApplicationAttribute] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ApplicationAttribute: ...

    class ApplicationState:
        ApplicationActive: ClassVar[Qt.ApplicationState] = ...
        ApplicationHidden: ClassVar[Qt.ApplicationState] = ...
        ApplicationInactive: ClassVar[Qt.ApplicationState] = ...
        ApplicationSuspended: ClassVar[Qt.ApplicationState] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ApplicationState: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...

    class ApplicationStates:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ApplicationStates: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ApplicationStates: ...

    class ArrowType:
        DownArrow: ClassVar[Qt.ArrowType] = ...
        LeftArrow: ClassVar[Qt.ArrowType] = ...
        NoArrow: ClassVar[Qt.ArrowType] = ...
        RightArrow: ClassVar[Qt.ArrowType] = ...
        UpArrow: ClassVar[Qt.ArrowType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ArrowType: ...

    class AspectRatioMode:
        IgnoreAspectRatio: ClassVar[Qt.AspectRatioMode] = ...
        KeepAspectRatio: ClassVar[Qt.AspectRatioMode] = ...
        KeepAspectRatioByExpanding: ClassVar[Qt.AspectRatioMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.AspectRatioMode: ...

    class Axis:
        XAxis: ClassVar[Qt.Axis] = ...
        YAxis: ClassVar[Qt.Axis] = ...
        ZAxis: ClassVar[Qt.Axis] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.Axis: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Axis: ...

    class BGMode:
        OpaqueMode: ClassVar[Qt.BGMode] = ...
        TransparentMode: ClassVar[Qt.BGMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.BGMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.BGMode: ...

    class BrushStyle:
        BDiagPattern: ClassVar[Qt.BrushStyle] = ...
        ConicalGradientPattern: ClassVar[Qt.BrushStyle] = ...
        CrossPattern: ClassVar[Qt.BrushStyle] = ...
        Dense1Pattern: ClassVar[Qt.BrushStyle] = ...
        Dense2Pattern: ClassVar[Qt.BrushStyle] = ...
        Dense3Pattern: ClassVar[Qt.BrushStyle] = ...
        Dense4Pattern: ClassVar[Qt.BrushStyle] = ...
        Dense5Pattern: ClassVar[Qt.BrushStyle] = ...
        Dense6Pattern: ClassVar[Qt.BrushStyle] = ...
        Dense7Pattern: ClassVar[Qt.BrushStyle] = ...
        DiagCrossPattern: ClassVar[Qt.BrushStyle] = ...
        FDiagPattern: ClassVar[Qt.BrushStyle] = ...
        HorPattern: ClassVar[Qt.BrushStyle] = ...
        LinearGradientPattern: ClassVar[Qt.BrushStyle] = ...
        NoBrush: ClassVar[Qt.BrushStyle] = ...
        RadialGradientPattern: ClassVar[Qt.BrushStyle] = ...
        SolidPattern: ClassVar[Qt.BrushStyle] = ...
        TexturePattern: ClassVar[Qt.BrushStyle] = ...
        VerPattern: ClassVar[Qt.BrushStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.BrushStyle: ...

    class CaseSensitivity:
        CaseInsensitive: ClassVar[Qt.CaseSensitivity] = ...
        CaseSensitive: ClassVar[Qt.CaseSensitivity] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.CaseSensitivity: ...

    class CheckState:
        Checked: ClassVar[Qt.CheckState] = ...
        PartiallyChecked: ClassVar[Qt.CheckState] = ...
        Unchecked: ClassVar[Qt.CheckState] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.CheckState: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.CheckState: ...

    class ChecksumType:
        ChecksumIso3309: ClassVar[Qt.ChecksumType] = ...
        ChecksumItuV41: ClassVar[Qt.ChecksumType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ChecksumType: ...

    class ClipOperation:
        IntersectClip: ClassVar[Qt.ClipOperation] = ...
        NoClip: ClassVar[Qt.ClipOperation] = ...
        ReplaceClip: ClassVar[Qt.ClipOperation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ClipOperation: ...

    class ConnectionType:
        AutoConnection: ClassVar[Qt.ConnectionType] = ...
        BlockingQueuedConnection: ClassVar[Qt.ConnectionType] = ...
        DirectConnection: ClassVar[Qt.ConnectionType] = ...
        QueuedConnection: ClassVar[Qt.ConnectionType] = ...
        UniqueConnection: ClassVar[Qt.ConnectionType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ConnectionType: ...

    class ContextMenuPolicy:
        ActionsContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
        CustomContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
        DefaultContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
        NoContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
        PreventContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ContextMenuPolicy: ...

    class CoordinateSystem:
        DeviceCoordinates: ClassVar[Qt.CoordinateSystem] = ...
        LogicalCoordinates: ClassVar[Qt.CoordinateSystem] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.CoordinateSystem: ...

    class Corner:
        BottomLeftCorner: ClassVar[Qt.Corner] = ...
        BottomRightCorner: ClassVar[Qt.Corner] = ...
        TopLeftCorner: ClassVar[Qt.Corner] = ...
        TopRightCorner: ClassVar[Qt.Corner] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.Corner: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Corner: ...

    class CursorMoveStyle:
        LogicalMoveStyle: ClassVar[Qt.CursorMoveStyle] = ...
        VisualMoveStyle: ClassVar[Qt.CursorMoveStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.CursorMoveStyle: ...

    class CursorShape:
        ArrowCursor: ClassVar[Qt.CursorShape] = ...
        BitmapCursor: ClassVar[Qt.CursorShape] = ...
        BlankCursor: ClassVar[Qt.CursorShape] = ...
        BusyCursor: ClassVar[Qt.CursorShape] = ...
        ClosedHandCursor: ClassVar[Qt.CursorShape] = ...
        CrossCursor: ClassVar[Qt.CursorShape] = ...
        CustomCursor: ClassVar[Qt.CursorShape] = ...
        DragCopyCursor: ClassVar[Qt.CursorShape] = ...
        DragLinkCursor: ClassVar[Qt.CursorShape] = ...
        DragMoveCursor: ClassVar[Qt.CursorShape] = ...
        ForbiddenCursor: ClassVar[Qt.CursorShape] = ...
        IBeamCursor: ClassVar[Qt.CursorShape] = ...
        LastCursor: ClassVar[Qt.CursorShape] = ...
        OpenHandCursor: ClassVar[Qt.CursorShape] = ...
        PointingHandCursor: ClassVar[Qt.CursorShape] = ...
        SizeAllCursor: ClassVar[Qt.CursorShape] = ...
        SizeBDiagCursor: ClassVar[Qt.CursorShape] = ...
        SizeFDiagCursor: ClassVar[Qt.CursorShape] = ...
        SizeHorCursor: ClassVar[Qt.CursorShape] = ...
        SizeVerCursor: ClassVar[Qt.CursorShape] = ...
        SplitHCursor: ClassVar[Qt.CursorShape] = ...
        SplitVCursor: ClassVar[Qt.CursorShape] = ...
        UpArrowCursor: ClassVar[Qt.CursorShape] = ...
        WaitCursor: ClassVar[Qt.CursorShape] = ...
        WhatsThisCursor: ClassVar[Qt.CursorShape] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.CursorShape: ...

    class DateFormat:
        DefaultLocaleLongDate: ClassVar[Qt.DateFormat] = ...
        DefaultLocaleShortDate: ClassVar[Qt.DateFormat] = ...
        ISODate: ClassVar[Qt.DateFormat] = ...
        ISODateWithMs: ClassVar[Qt.DateFormat] = ...
        LocalDate: ClassVar[Qt.DateFormat] = ...
        LocaleDate: ClassVar[Qt.DateFormat] = ...
        RFC2822Date: ClassVar[Qt.DateFormat] = ...
        SystemLocaleDate: ClassVar[Qt.DateFormat] = ...
        SystemLocaleLongDate: ClassVar[Qt.DateFormat] = ...
        SystemLocaleShortDate: ClassVar[Qt.DateFormat] = ...
        TextDate: ClassVar[Qt.DateFormat] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DateFormat: ...

    class DayOfWeek:
        Friday: ClassVar[Qt.DayOfWeek] = ...
        Monday: ClassVar[Qt.DayOfWeek] = ...
        Saturday: ClassVar[Qt.DayOfWeek] = ...
        Sunday: ClassVar[Qt.DayOfWeek] = ...
        Thursday: ClassVar[Qt.DayOfWeek] = ...
        Tuesday: ClassVar[Qt.DayOfWeek] = ...
        Wednesday: ClassVar[Qt.DayOfWeek] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DayOfWeek: ...

    class DockWidgetArea:
        AllDockWidgetAreas: ClassVar[Qt.DockWidgetArea] = ...
        BottomDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
        DockWidgetArea_Mask: ClassVar[Qt.DockWidgetArea] = ...
        LeftDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
        NoDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
        RightDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
        TopDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.DockWidgetArea: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...

    class DockWidgetAreaSizes:
        NDockWidgetAreas: ClassVar[Qt.DockWidgetAreaSizes] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreaSizes: ...

    class DockWidgetAreas:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.DockWidgetAreas: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DockWidgetAreas: ...

    class DropAction:
        ActionMask: ClassVar[Qt.DropAction] = ...
        CopyAction: ClassVar[Qt.DropAction] = ...
        IgnoreAction: ClassVar[Qt.DropAction] = ...
        LinkAction: ClassVar[Qt.DropAction] = ...
        MoveAction: ClassVar[Qt.DropAction] = ...
        TargetMoveAction: ClassVar[Qt.DropAction] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.DropAction: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DropActions: ...

    class DropActions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.DropActions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.DropActions: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.DropActions: ...

    class Edge:
        BottomEdge: ClassVar[Qt.Edge] = ...
        LeftEdge: ClassVar[Qt.Edge] = ...
        RightEdge: ClassVar[Qt.Edge] = ...
        TopEdge: ClassVar[Qt.Edge] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.Edge: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Edges: ...

    class Edges:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.Edges: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Edges: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Edges: ...

    class EnterKeyType:
        EnterKeyDefault: ClassVar[Qt.EnterKeyType] = ...
        EnterKeyDone: ClassVar[Qt.EnterKeyType] = ...
        EnterKeyGo: ClassVar[Qt.EnterKeyType] = ...
        EnterKeyNext: ClassVar[Qt.EnterKeyType] = ...
        EnterKeyPrevious: ClassVar[Qt.EnterKeyType] = ...
        EnterKeyReturn: ClassVar[Qt.EnterKeyType] = ...
        EnterKeySearch: ClassVar[Qt.EnterKeyType] = ...
        EnterKeySend: ClassVar[Qt.EnterKeyType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.EnterKeyType: ...

    class EventPriority:
        HighEventPriority: ClassVar[Qt.EventPriority] = ...
        LowEventPriority: ClassVar[Qt.EventPriority] = ...
        NormalEventPriority: ClassVar[Qt.EventPriority] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.EventPriority: ...

    class FillRule:
        OddEvenFill: ClassVar[Qt.FillRule] = ...
        WindingFill: ClassVar[Qt.FillRule] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.FillRule: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.FillRule: ...

    class FindChildOption:
        FindChildrenRecursively: ClassVar[Qt.FindChildOption] = ...
        FindDirectChildrenOnly: ClassVar[Qt.FindChildOption] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.FindChildOption: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...

    class FindChildOptions:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.FindChildOptions: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.FindChildOptions: ...

    class FocusPolicy:
        ClickFocus: ClassVar[Qt.FocusPolicy] = ...
        NoFocus: ClassVar[Qt.FocusPolicy] = ...
        StrongFocus: ClassVar[Qt.FocusPolicy] = ...
        TabFocus: ClassVar[Qt.FocusPolicy] = ...
        WheelFocus: ClassVar[Qt.FocusPolicy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.FocusPolicy: ...

    class FocusReason:
        ActiveWindowFocusReason: ClassVar[Qt.FocusReason] = ...
        BacktabFocusReason: ClassVar[Qt.FocusReason] = ...
        MenuBarFocusReason: ClassVar[Qt.FocusReason] = ...
        MouseFocusReason: ClassVar[Qt.FocusReason] = ...
        NoFocusReason: ClassVar[Qt.FocusReason] = ...
        OtherFocusReason: ClassVar[Qt.FocusReason] = ...
        PopupFocusReason: ClassVar[Qt.FocusReason] = ...
        ShortcutFocusReason: ClassVar[Qt.FocusReason] = ...
        TabFocusReason: ClassVar[Qt.FocusReason] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.FocusReason: ...

    class GestureFlag:
        DontStartGestureOnChildren: ClassVar[Qt.GestureFlag] = ...
        IgnoredGesturesPropagateToParent: ClassVar[Qt.GestureFlag] = ...
        ReceivePartialGestures: ClassVar[Qt.GestureFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.GestureFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...

    class GestureFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.GestureFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.GestureFlags: ...

    class GestureState:
        GestureCanceled: ClassVar[Qt.GestureState] = ...
        GestureFinished: ClassVar[Qt.GestureState] = ...
        GestureStarted: ClassVar[Qt.GestureState] = ...
        GestureUpdated: ClassVar[Qt.GestureState] = ...
        NoGesture: ClassVar[Qt.GestureState] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.GestureState: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.GestureState: ...

    class GestureType:
        CustomGesture: ClassVar[Qt.GestureType] = ...
        LastGestureType: ClassVar[Qt.GestureType] = ...
        PanGesture: ClassVar[Qt.GestureType] = ...
        PinchGesture: ClassVar[Qt.GestureType] = ...
        SwipeGesture: ClassVar[Qt.GestureType] = ...
        TapAndHoldGesture: ClassVar[Qt.GestureType] = ...
        TapGesture: ClassVar[Qt.GestureType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.GestureType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.GestureType: ...

    class GlobalColor:
        black: ClassVar[Qt.GlobalColor] = ...
        blue: ClassVar[Qt.GlobalColor] = ...
        color0: ClassVar[Qt.GlobalColor] = ...
        color1: ClassVar[Qt.GlobalColor] = ...
        cyan: ClassVar[Qt.GlobalColor] = ...
        darkBlue: ClassVar[Qt.GlobalColor] = ...
        darkCyan: ClassVar[Qt.GlobalColor] = ...
        darkGray: ClassVar[Qt.GlobalColor] = ...
        darkGreen: ClassVar[Qt.GlobalColor] = ...
        darkMagenta: ClassVar[Qt.GlobalColor] = ...
        darkRed: ClassVar[Qt.GlobalColor] = ...
        darkYellow: ClassVar[Qt.GlobalColor] = ...
        gray: ClassVar[Qt.GlobalColor] = ...
        green: ClassVar[Qt.GlobalColor] = ...
        lightGray: ClassVar[Qt.GlobalColor] = ...
        magenta: ClassVar[Qt.GlobalColor] = ...
        red: ClassVar[Qt.GlobalColor] = ...
        transparent: ClassVar[Qt.GlobalColor] = ...
        values: ClassVar[dict] = ...
        white: ClassVar[Qt.GlobalColor] = ...
        yellow: ClassVar[Qt.GlobalColor] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.GlobalColor: ...

    class HighDpiScaleFactorRoundingPolicy:
        Ceil: ClassVar[Qt.HighDpiScaleFactorRoundingPolicy] = ...
        Floor: ClassVar[Qt.HighDpiScaleFactorRoundingPolicy] = ...
        PassThrough: ClassVar[Qt.HighDpiScaleFactorRoundingPolicy] = ...
        Round: ClassVar[Qt.HighDpiScaleFactorRoundingPolicy] = ...
        RoundPreferFloor: ClassVar[Qt.HighDpiScaleFactorRoundingPolicy] = ...
        Unset: ClassVar[Qt.HighDpiScaleFactorRoundingPolicy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.HighDpiScaleFactorRoundingPolicy: ...

    class HitTestAccuracy:
        ExactHit: ClassVar[Qt.HitTestAccuracy] = ...
        FuzzyHit: ClassVar[Qt.HitTestAccuracy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.HitTestAccuracy: ...

    class ImageConversionFlag:
        AlphaDither_Mask: ClassVar[Qt.ImageConversionFlag] = ...
        AutoColor: ClassVar[Qt.ImageConversionFlag] = ...
        AutoDither: ClassVar[Qt.ImageConversionFlag] = ...
        AvoidDither: ClassVar[Qt.ImageConversionFlag] = ...
        ColorMode_Mask: ClassVar[Qt.ImageConversionFlag] = ...
        ColorOnly: ClassVar[Qt.ImageConversionFlag] = ...
        DiffuseAlphaDither: ClassVar[Qt.ImageConversionFlag] = ...
        DiffuseDither: ClassVar[Qt.ImageConversionFlag] = ...
        DitherMode_Mask: ClassVar[Qt.ImageConversionFlag] = ...
        Dither_Mask: ClassVar[Qt.ImageConversionFlag] = ...
        MonoOnly: ClassVar[Qt.ImageConversionFlag] = ...
        NoAlpha: ClassVar[Qt.ImageConversionFlag] = ...
        NoFormatConversion: ClassVar[Qt.ImageConversionFlag] = ...
        NoOpaqueDetection: ClassVar[Qt.ImageConversionFlag] = ...
        OrderedAlphaDither: ClassVar[Qt.ImageConversionFlag] = ...
        OrderedDither: ClassVar[Qt.ImageConversionFlag] = ...
        PreferDither: ClassVar[Qt.ImageConversionFlag] = ...
        ThresholdAlphaDither: ClassVar[Qt.ImageConversionFlag] = ...
        ThresholdDither: ClassVar[Qt.ImageConversionFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ImageConversionFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...

    class ImageConversionFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ImageConversionFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ImageConversionFlags: ...

    class InputMethodHint:
        ImhDate: ClassVar[Qt.InputMethodHint] = ...
        ImhDialableCharactersOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhDigitsOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhEmailCharactersOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhExclusiveInputMask: ClassVar[Qt.InputMethodHint] = ...
        ImhFormattedNumbersOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhHiddenText: ClassVar[Qt.InputMethodHint] = ...
        ImhLatinOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhLowercaseOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhMultiLine: ClassVar[Qt.InputMethodHint] = ...
        ImhNoAutoUppercase: ClassVar[Qt.InputMethodHint] = ...
        ImhNoEditMenu: ClassVar[Qt.InputMethodHint] = ...
        ImhNoPredictiveText: ClassVar[Qt.InputMethodHint] = ...
        ImhNoTextHandles: ClassVar[Qt.InputMethodHint] = ...
        ImhNone: ClassVar[Qt.InputMethodHint] = ...
        ImhPreferLatin: ClassVar[Qt.InputMethodHint] = ...
        ImhPreferLowercase: ClassVar[Qt.InputMethodHint] = ...
        ImhPreferNumbers: ClassVar[Qt.InputMethodHint] = ...
        ImhPreferUppercase: ClassVar[Qt.InputMethodHint] = ...
        ImhSensitiveData: ClassVar[Qt.InputMethodHint] = ...
        ImhTime: ClassVar[Qt.InputMethodHint] = ...
        ImhUppercaseOnly: ClassVar[Qt.InputMethodHint] = ...
        ImhUrlCharactersOnly: ClassVar[Qt.InputMethodHint] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.InputMethodHint: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...

    class InputMethodHints:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.InputMethodHints: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.InputMethodHints: ...

    class InputMethodQueries:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.InputMethodQueries: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...

    class InputMethodQuery:
        ImAbsolutePosition: ClassVar[Qt.InputMethodQuery] = ...
        ImAnchorPosition: ClassVar[Qt.InputMethodQuery] = ...
        ImAnchorRectangle: ClassVar[Qt.InputMethodQuery] = ...
        ImCurrentSelection: ClassVar[Qt.InputMethodQuery] = ...
        ImCursorPosition: ClassVar[Qt.InputMethodQuery] = ...
        ImCursorRectangle: ClassVar[Qt.InputMethodQuery] = ...
        ImEnabled: ClassVar[Qt.InputMethodQuery] = ...
        ImEnterKeyType: ClassVar[Qt.InputMethodQuery] = ...
        ImFont: ClassVar[Qt.InputMethodQuery] = ...
        ImHints: ClassVar[Qt.InputMethodQuery] = ...
        ImInputItemClipRectangle: ClassVar[Qt.InputMethodQuery] = ...
        ImMaximumTextLength: ClassVar[Qt.InputMethodQuery] = ...
        ImMicroFocus: ClassVar[Qt.InputMethodQuery] = ...
        ImPlatformData: ClassVar[Qt.InputMethodQuery] = ...
        ImPreferredLanguage: ClassVar[Qt.InputMethodQuery] = ...
        ImQueryAll: ClassVar[Qt.InputMethodQuery] = ...
        ImQueryInput: ClassVar[Qt.InputMethodQuery] = ...
        ImSurroundingText: ClassVar[Qt.InputMethodQuery] = ...
        ImTextAfterCursor: ClassVar[Qt.InputMethodQuery] = ...
        ImTextBeforeCursor: ClassVar[Qt.InputMethodQuery] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.InputMethodQuery: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.InputMethodQueries: ...

    class ItemDataRole:
        AccessibleDescriptionRole: ClassVar[Qt.ItemDataRole] = ...
        AccessibleTextRole: ClassVar[Qt.ItemDataRole] = ...
        BackgroundColorRole: ClassVar[Qt.ItemDataRole] = ...
        BackgroundRole: ClassVar[Qt.ItemDataRole] = ...
        CheckStateRole: ClassVar[Qt.ItemDataRole] = ...
        DecorationPropertyRole: ClassVar[Qt.ItemDataRole] = ...
        DecorationRole: ClassVar[Qt.ItemDataRole] = ...
        DisplayPropertyRole: ClassVar[Qt.ItemDataRole] = ...
        DisplayRole: ClassVar[Qt.ItemDataRole] = ...
        EditRole: ClassVar[Qt.ItemDataRole] = ...
        FontRole: ClassVar[Qt.ItemDataRole] = ...
        ForegroundRole: ClassVar[Qt.ItemDataRole] = ...
        InitialSortOrderRole: ClassVar[Qt.ItemDataRole] = ...
        SizeHintRole: ClassVar[Qt.ItemDataRole] = ...
        StatusTipPropertyRole: ClassVar[Qt.ItemDataRole] = ...
        StatusTipRole: ClassVar[Qt.ItemDataRole] = ...
        TextAlignmentRole: ClassVar[Qt.ItemDataRole] = ...
        TextColorRole: ClassVar[Qt.ItemDataRole] = ...
        ToolTipPropertyRole: ClassVar[Qt.ItemDataRole] = ...
        ToolTipRole: ClassVar[Qt.ItemDataRole] = ...
        UserRole: ClassVar[Qt.ItemDataRole] = ...
        WhatsThisPropertyRole: ClassVar[Qt.ItemDataRole] = ...
        WhatsThisRole: ClassVar[Qt.ItemDataRole] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ItemDataRole: ...

    class ItemFlag:
        ItemIsAutoTristate: ClassVar[Qt.ItemFlag] = ...
        ItemIsDragEnabled: ClassVar[Qt.ItemFlag] = ...
        ItemIsDropEnabled: ClassVar[Qt.ItemFlag] = ...
        ItemIsEditable: ClassVar[Qt.ItemFlag] = ...
        ItemIsEnabled: ClassVar[Qt.ItemFlag] = ...
        ItemIsSelectable: ClassVar[Qt.ItemFlag] = ...
        ItemIsTristate: ClassVar[Qt.ItemFlag] = ...
        ItemIsUserCheckable: ClassVar[Qt.ItemFlag] = ...
        ItemIsUserTristate: ClassVar[Qt.ItemFlag] = ...
        ItemNeverHasChildren: ClassVar[Qt.ItemFlag] = ...
        NoItemFlags: ClassVar[Qt.ItemFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ItemFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...

    class ItemFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ItemFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ItemFlags: ...

    class ItemSelectionMode:
        ContainsItemBoundingRect: ClassVar[Qt.ItemSelectionMode] = ...
        ContainsItemShape: ClassVar[Qt.ItemSelectionMode] = ...
        IntersectsItemBoundingRect: ClassVar[Qt.ItemSelectionMode] = ...
        IntersectsItemShape: ClassVar[Qt.ItemSelectionMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ItemSelectionMode: ...

    class ItemSelectionOperation:
        AddToSelection: ClassVar[Qt.ItemSelectionOperation] = ...
        ReplaceSelection: ClassVar[Qt.ItemSelectionOperation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ItemSelectionOperation: ...

    class Key:
        Key_0: ClassVar[Qt.Key] = ...
        Key_1: ClassVar[Qt.Key] = ...
        Key_2: ClassVar[Qt.Key] = ...
        Key_3: ClassVar[Qt.Key] = ...
        Key_4: ClassVar[Qt.Key] = ...
        Key_5: ClassVar[Qt.Key] = ...
        Key_6: ClassVar[Qt.Key] = ...
        Key_7: ClassVar[Qt.Key] = ...
        Key_8: ClassVar[Qt.Key] = ...
        Key_9: ClassVar[Qt.Key] = ...
        Key_A: ClassVar[Qt.Key] = ...
        Key_AE: ClassVar[Qt.Key] = ...
        Key_Aacute: ClassVar[Qt.Key] = ...
        Key_Acircumflex: ClassVar[Qt.Key] = ...
        Key_AddFavorite: ClassVar[Qt.Key] = ...
        Key_Adiaeresis: ClassVar[Qt.Key] = ...
        Key_Agrave: ClassVar[Qt.Key] = ...
        Key_Alt: ClassVar[Qt.Key] = ...
        Key_AltGr: ClassVar[Qt.Key] = ...
        Key_Ampersand: ClassVar[Qt.Key] = ...
        Key_Any: ClassVar[Qt.Key] = ...
        Key_Apostrophe: ClassVar[Qt.Key] = ...
        Key_ApplicationLeft: ClassVar[Qt.Key] = ...
        Key_ApplicationRight: ClassVar[Qt.Key] = ...
        Key_Aring: ClassVar[Qt.Key] = ...
        Key_AsciiCircum: ClassVar[Qt.Key] = ...
        Key_AsciiTilde: ClassVar[Qt.Key] = ...
        Key_Asterisk: ClassVar[Qt.Key] = ...
        Key_At: ClassVar[Qt.Key] = ...
        Key_Atilde: ClassVar[Qt.Key] = ...
        Key_AudioCycleTrack: ClassVar[Qt.Key] = ...
        Key_AudioForward: ClassVar[Qt.Key] = ...
        Key_AudioRandomPlay: ClassVar[Qt.Key] = ...
        Key_AudioRepeat: ClassVar[Qt.Key] = ...
        Key_AudioRewind: ClassVar[Qt.Key] = ...
        Key_Away: ClassVar[Qt.Key] = ...
        Key_B: ClassVar[Qt.Key] = ...
        Key_Back: ClassVar[Qt.Key] = ...
        Key_BackForward: ClassVar[Qt.Key] = ...
        Key_Backslash: ClassVar[Qt.Key] = ...
        Key_Backspace: ClassVar[Qt.Key] = ...
        Key_Backtab: ClassVar[Qt.Key] = ...
        Key_Bar: ClassVar[Qt.Key] = ...
        Key_BassBoost: ClassVar[Qt.Key] = ...
        Key_BassDown: ClassVar[Qt.Key] = ...
        Key_BassUp: ClassVar[Qt.Key] = ...
        Key_Battery: ClassVar[Qt.Key] = ...
        Key_Blue: ClassVar[Qt.Key] = ...
        Key_Bluetooth: ClassVar[Qt.Key] = ...
        Key_Book: ClassVar[Qt.Key] = ...
        Key_BraceLeft: ClassVar[Qt.Key] = ...
        Key_BraceRight: ClassVar[Qt.Key] = ...
        Key_BracketLeft: ClassVar[Qt.Key] = ...
        Key_BracketRight: ClassVar[Qt.Key] = ...
        Key_BrightnessAdjust: ClassVar[Qt.Key] = ...
        Key_C: ClassVar[Qt.Key] = ...
        Key_CD: ClassVar[Qt.Key] = ...
        Key_Calculator: ClassVar[Qt.Key] = ...
        Key_Calendar: ClassVar[Qt.Key] = ...
        Key_Call: ClassVar[Qt.Key] = ...
        Key_Camera: ClassVar[Qt.Key] = ...
        Key_CameraFocus: ClassVar[Qt.Key] = ...
        Key_Cancel: ClassVar[Qt.Key] = ...
        Key_CapsLock: ClassVar[Qt.Key] = ...
        Key_Ccedilla: ClassVar[Qt.Key] = ...
        Key_ChannelDown: ClassVar[Qt.Key] = ...
        Key_ChannelUp: ClassVar[Qt.Key] = ...
        Key_Clear: ClassVar[Qt.Key] = ...
        Key_ClearGrab: ClassVar[Qt.Key] = ...
        Key_Close: ClassVar[Qt.Key] = ...
        Key_Codeinput: ClassVar[Qt.Key] = ...
        Key_Colon: ClassVar[Qt.Key] = ...
        Key_Comma: ClassVar[Qt.Key] = ...
        Key_Community: ClassVar[Qt.Key] = ...
        Key_Context1: ClassVar[Qt.Key] = ...
        Key_Context2: ClassVar[Qt.Key] = ...
        Key_Context3: ClassVar[Qt.Key] = ...
        Key_Context4: ClassVar[Qt.Key] = ...
        Key_ContrastAdjust: ClassVar[Qt.Key] = ...
        Key_Control: ClassVar[Qt.Key] = ...
        Key_Copy: ClassVar[Qt.Key] = ...
        Key_Cut: ClassVar[Qt.Key] = ...
        Key_D: ClassVar[Qt.Key] = ...
        Key_DOS: ClassVar[Qt.Key] = ...
        Key_Dead_A: ClassVar[Qt.Key] = ...
        Key_Dead_Abovecomma: ClassVar[Qt.Key] = ...
        Key_Dead_Abovedot: ClassVar[Qt.Key] = ...
        Key_Dead_Abovereversedcomma: ClassVar[Qt.Key] = ...
        Key_Dead_Abovering: ClassVar[Qt.Key] = ...
        Key_Dead_Aboveverticalline: ClassVar[Qt.Key] = ...
        Key_Dead_Acute: ClassVar[Qt.Key] = ...
        Key_Dead_Belowbreve: ClassVar[Qt.Key] = ...
        Key_Dead_Belowcircumflex: ClassVar[Qt.Key] = ...
        Key_Dead_Belowcomma: ClassVar[Qt.Key] = ...
        Key_Dead_Belowdiaeresis: ClassVar[Qt.Key] = ...
        Key_Dead_Belowdot: ClassVar[Qt.Key] = ...
        Key_Dead_Belowmacron: ClassVar[Qt.Key] = ...
        Key_Dead_Belowring: ClassVar[Qt.Key] = ...
        Key_Dead_Belowtilde: ClassVar[Qt.Key] = ...
        Key_Dead_Belowverticalline: ClassVar[Qt.Key] = ...
        Key_Dead_Breve: ClassVar[Qt.Key] = ...
        Key_Dead_Capital_Schwa: ClassVar[Qt.Key] = ...
        Key_Dead_Caron: ClassVar[Qt.Key] = ...
        Key_Dead_Cedilla: ClassVar[Qt.Key] = ...
        Key_Dead_Circumflex: ClassVar[Qt.Key] = ...
        Key_Dead_Currency: ClassVar[Qt.Key] = ...
        Key_Dead_Diaeresis: ClassVar[Qt.Key] = ...
        Key_Dead_Doubleacute: ClassVar[Qt.Key] = ...
        Key_Dead_Doublegrave: ClassVar[Qt.Key] = ...
        Key_Dead_E: ClassVar[Qt.Key] = ...
        Key_Dead_Grave: ClassVar[Qt.Key] = ...
        Key_Dead_Greek: ClassVar[Qt.Key] = ...
        Key_Dead_Hook: ClassVar[Qt.Key] = ...
        Key_Dead_Horn: ClassVar[Qt.Key] = ...
        Key_Dead_I: ClassVar[Qt.Key] = ...
        Key_Dead_Invertedbreve: ClassVar[Qt.Key] = ...
        Key_Dead_Iota: ClassVar[Qt.Key] = ...
        Key_Dead_Longsolidusoverlay: ClassVar[Qt.Key] = ...
        Key_Dead_Lowline: ClassVar[Qt.Key] = ...
        Key_Dead_Macron: ClassVar[Qt.Key] = ...
        Key_Dead_O: ClassVar[Qt.Key] = ...
        Key_Dead_Ogonek: ClassVar[Qt.Key] = ...
        Key_Dead_Semivoiced_Sound: ClassVar[Qt.Key] = ...
        Key_Dead_Small_Schwa: ClassVar[Qt.Key] = ...
        Key_Dead_Stroke: ClassVar[Qt.Key] = ...
        Key_Dead_Tilde: ClassVar[Qt.Key] = ...
        Key_Dead_U: ClassVar[Qt.Key] = ...
        Key_Dead_Voiced_Sound: ClassVar[Qt.Key] = ...
        Key_Dead_a: ClassVar[Qt.Key] = ...
        Key_Dead_e: ClassVar[Qt.Key] = ...
        Key_Dead_i: ClassVar[Qt.Key] = ...
        Key_Dead_o: ClassVar[Qt.Key] = ...
        Key_Dead_u: ClassVar[Qt.Key] = ...
        Key_Delete: ClassVar[Qt.Key] = ...
        Key_Direction_L: ClassVar[Qt.Key] = ...
        Key_Direction_R: ClassVar[Qt.Key] = ...
        Key_Display: ClassVar[Qt.Key] = ...
        Key_Documents: ClassVar[Qt.Key] = ...
        Key_Dollar: ClassVar[Qt.Key] = ...
        Key_Down: ClassVar[Qt.Key] = ...
        Key_E: ClassVar[Qt.Key] = ...
        Key_ETH: ClassVar[Qt.Key] = ...
        Key_Eacute: ClassVar[Qt.Key] = ...
        Key_Ecircumflex: ClassVar[Qt.Key] = ...
        Key_Ediaeresis: ClassVar[Qt.Key] = ...
        Key_Egrave: ClassVar[Qt.Key] = ...
        Key_Eisu_Shift: ClassVar[Qt.Key] = ...
        Key_Eisu_toggle: ClassVar[Qt.Key] = ...
        Key_Eject: ClassVar[Qt.Key] = ...
        Key_End: ClassVar[Qt.Key] = ...
        Key_Enter: ClassVar[Qt.Key] = ...
        Key_Equal: ClassVar[Qt.Key] = ...
        Key_Escape: ClassVar[Qt.Key] = ...
        Key_Excel: ClassVar[Qt.Key] = ...
        Key_Exclam: ClassVar[Qt.Key] = ...
        Key_Execute: ClassVar[Qt.Key] = ...
        Key_Exit: ClassVar[Qt.Key] = ...
        Key_Explorer: ClassVar[Qt.Key] = ...
        Key_F: ClassVar[Qt.Key] = ...
        Key_F1: ClassVar[Qt.Key] = ...
        Key_F10: ClassVar[Qt.Key] = ...
        Key_F11: ClassVar[Qt.Key] = ...
        Key_F12: ClassVar[Qt.Key] = ...
        Key_F13: ClassVar[Qt.Key] = ...
        Key_F14: ClassVar[Qt.Key] = ...
        Key_F15: ClassVar[Qt.Key] = ...
        Key_F16: ClassVar[Qt.Key] = ...
        Key_F17: ClassVar[Qt.Key] = ...
        Key_F18: ClassVar[Qt.Key] = ...
        Key_F19: ClassVar[Qt.Key] = ...
        Key_F2: ClassVar[Qt.Key] = ...
        Key_F20: ClassVar[Qt.Key] = ...
        Key_F21: ClassVar[Qt.Key] = ...
        Key_F22: ClassVar[Qt.Key] = ...
        Key_F23: ClassVar[Qt.Key] = ...
        Key_F24: ClassVar[Qt.Key] = ...
        Key_F25: ClassVar[Qt.Key] = ...
        Key_F26: ClassVar[Qt.Key] = ...
        Key_F27: ClassVar[Qt.Key] = ...
        Key_F28: ClassVar[Qt.Key] = ...
        Key_F29: ClassVar[Qt.Key] = ...
        Key_F3: ClassVar[Qt.Key] = ...
        Key_F30: ClassVar[Qt.Key] = ...
        Key_F31: ClassVar[Qt.Key] = ...
        Key_F32: ClassVar[Qt.Key] = ...
        Key_F33: ClassVar[Qt.Key] = ...
        Key_F34: ClassVar[Qt.Key] = ...
        Key_F35: ClassVar[Qt.Key] = ...
        Key_F4: ClassVar[Qt.Key] = ...
        Key_F5: ClassVar[Qt.Key] = ...
        Key_F6: ClassVar[Qt.Key] = ...
        Key_F7: ClassVar[Qt.Key] = ...
        Key_F8: ClassVar[Qt.Key] = ...
        Key_F9: ClassVar[Qt.Key] = ...
        Key_Favorites: ClassVar[Qt.Key] = ...
        Key_Finance: ClassVar[Qt.Key] = ...
        Key_Find: ClassVar[Qt.Key] = ...
        Key_Flip: ClassVar[Qt.Key] = ...
        Key_Forward: ClassVar[Qt.Key] = ...
        Key_G: ClassVar[Qt.Key] = ...
        Key_Game: ClassVar[Qt.Key] = ...
        Key_Go: ClassVar[Qt.Key] = ...
        Key_Greater: ClassVar[Qt.Key] = ...
        Key_Green: ClassVar[Qt.Key] = ...
        Key_Guide: ClassVar[Qt.Key] = ...
        Key_H: ClassVar[Qt.Key] = ...
        Key_Hangul: ClassVar[Qt.Key] = ...
        Key_Hangul_Banja: ClassVar[Qt.Key] = ...
        Key_Hangul_End: ClassVar[Qt.Key] = ...
        Key_Hangul_Hanja: ClassVar[Qt.Key] = ...
        Key_Hangul_Jamo: ClassVar[Qt.Key] = ...
        Key_Hangul_Jeonja: ClassVar[Qt.Key] = ...
        Key_Hangul_PostHanja: ClassVar[Qt.Key] = ...
        Key_Hangul_PreHanja: ClassVar[Qt.Key] = ...
        Key_Hangul_Romaja: ClassVar[Qt.Key] = ...
        Key_Hangul_Special: ClassVar[Qt.Key] = ...
        Key_Hangul_Start: ClassVar[Qt.Key] = ...
        Key_Hangup: ClassVar[Qt.Key] = ...
        Key_Hankaku: ClassVar[Qt.Key] = ...
        Key_Help: ClassVar[Qt.Key] = ...
        Key_Henkan: ClassVar[Qt.Key] = ...
        Key_Hibernate: ClassVar[Qt.Key] = ...
        Key_Hiragana: ClassVar[Qt.Key] = ...
        Key_Hiragana_Katakana: ClassVar[Qt.Key] = ...
        Key_History: ClassVar[Qt.Key] = ...
        Key_Home: ClassVar[Qt.Key] = ...
        Key_HomePage: ClassVar[Qt.Key] = ...
        Key_HotLinks: ClassVar[Qt.Key] = ...
        Key_Hyper_L: ClassVar[Qt.Key] = ...
        Key_Hyper_R: ClassVar[Qt.Key] = ...
        Key_I: ClassVar[Qt.Key] = ...
        Key_Iacute: ClassVar[Qt.Key] = ...
        Key_Icircumflex: ClassVar[Qt.Key] = ...
        Key_Idiaeresis: ClassVar[Qt.Key] = ...
        Key_Igrave: ClassVar[Qt.Key] = ...
        Key_Info: ClassVar[Qt.Key] = ...
        Key_Insert: ClassVar[Qt.Key] = ...
        Key_J: ClassVar[Qt.Key] = ...
        Key_K: ClassVar[Qt.Key] = ...
        Key_Kana_Lock: ClassVar[Qt.Key] = ...
        Key_Kana_Shift: ClassVar[Qt.Key] = ...
        Key_Kanji: ClassVar[Qt.Key] = ...
        Key_Katakana: ClassVar[Qt.Key] = ...
        Key_KeyboardBrightnessDown: ClassVar[Qt.Key] = ...
        Key_KeyboardBrightnessUp: ClassVar[Qt.Key] = ...
        Key_KeyboardLightOnOff: ClassVar[Qt.Key] = ...
        Key_L: ClassVar[Qt.Key] = ...
        Key_LastNumberRedial: ClassVar[Qt.Key] = ...
        Key_Launch0: ClassVar[Qt.Key] = ...
        Key_Launch1: ClassVar[Qt.Key] = ...
        Key_Launch2: ClassVar[Qt.Key] = ...
        Key_Launch3: ClassVar[Qt.Key] = ...
        Key_Launch4: ClassVar[Qt.Key] = ...
        Key_Launch5: ClassVar[Qt.Key] = ...
        Key_Launch6: ClassVar[Qt.Key] = ...
        Key_Launch7: ClassVar[Qt.Key] = ...
        Key_Launch8: ClassVar[Qt.Key] = ...
        Key_Launch9: ClassVar[Qt.Key] = ...
        Key_LaunchA: ClassVar[Qt.Key] = ...
        Key_LaunchB: ClassVar[Qt.Key] = ...
        Key_LaunchC: ClassVar[Qt.Key] = ...
        Key_LaunchD: ClassVar[Qt.Key] = ...
        Key_LaunchE: ClassVar[Qt.Key] = ...
        Key_LaunchF: ClassVar[Qt.Key] = ...
        Key_LaunchG: ClassVar[Qt.Key] = ...
        Key_LaunchH: ClassVar[Qt.Key] = ...
        Key_LaunchMail: ClassVar[Qt.Key] = ...
        Key_LaunchMedia: ClassVar[Qt.Key] = ...
        Key_Left: ClassVar[Qt.Key] = ...
        Key_Less: ClassVar[Qt.Key] = ...
        Key_LightBulb: ClassVar[Qt.Key] = ...
        Key_LogOff: ClassVar[Qt.Key] = ...
        Key_M: ClassVar[Qt.Key] = ...
        Key_MailForward: ClassVar[Qt.Key] = ...
        Key_Market: ClassVar[Qt.Key] = ...
        Key_Massyo: ClassVar[Qt.Key] = ...
        Key_MediaLast: ClassVar[Qt.Key] = ...
        Key_MediaNext: ClassVar[Qt.Key] = ...
        Key_MediaPause: ClassVar[Qt.Key] = ...
        Key_MediaPlay: ClassVar[Qt.Key] = ...
        Key_MediaPrevious: ClassVar[Qt.Key] = ...
        Key_MediaRecord: ClassVar[Qt.Key] = ...
        Key_MediaStop: ClassVar[Qt.Key] = ...
        Key_MediaTogglePlayPause: ClassVar[Qt.Key] = ...
        Key_Meeting: ClassVar[Qt.Key] = ...
        Key_Memo: ClassVar[Qt.Key] = ...
        Key_Menu: ClassVar[Qt.Key] = ...
        Key_MenuKB: ClassVar[Qt.Key] = ...
        Key_MenuPB: ClassVar[Qt.Key] = ...
        Key_Messenger: ClassVar[Qt.Key] = ...
        Key_Meta: ClassVar[Qt.Key] = ...
        Key_MicMute: ClassVar[Qt.Key] = ...
        Key_MicVolumeDown: ClassVar[Qt.Key] = ...
        Key_MicVolumeUp: ClassVar[Qt.Key] = ...
        Key_Minus: ClassVar[Qt.Key] = ...
        Key_Mode_switch: ClassVar[Qt.Key] = ...
        Key_MonBrightnessDown: ClassVar[Qt.Key] = ...
        Key_MonBrightnessUp: ClassVar[Qt.Key] = ...
        Key_Muhenkan: ClassVar[Qt.Key] = ...
        Key_Multi_key: ClassVar[Qt.Key] = ...
        Key_MultipleCandidate: ClassVar[Qt.Key] = ...
        Key_Music: ClassVar[Qt.Key] = ...
        Key_MySites: ClassVar[Qt.Key] = ...
        Key_N: ClassVar[Qt.Key] = ...
        Key_New: ClassVar[Qt.Key] = ...
        Key_News: ClassVar[Qt.Key] = ...
        Key_No: ClassVar[Qt.Key] = ...
        Key_Ntilde: ClassVar[Qt.Key] = ...
        Key_NumLock: ClassVar[Qt.Key] = ...
        Key_NumberSign: ClassVar[Qt.Key] = ...
        Key_O: ClassVar[Qt.Key] = ...
        Key_Oacute: ClassVar[Qt.Key] = ...
        Key_Ocircumflex: ClassVar[Qt.Key] = ...
        Key_Odiaeresis: ClassVar[Qt.Key] = ...
        Key_OfficeHome: ClassVar[Qt.Key] = ...
        Key_Ograve: ClassVar[Qt.Key] = ...
        Key_Ooblique: ClassVar[Qt.Key] = ...
        Key_Open: ClassVar[Qt.Key] = ...
        Key_OpenUrl: ClassVar[Qt.Key] = ...
        Key_Option: ClassVar[Qt.Key] = ...
        Key_Otilde: ClassVar[Qt.Key] = ...
        Key_P: ClassVar[Qt.Key] = ...
        Key_PageDown: ClassVar[Qt.Key] = ...
        Key_PageUp: ClassVar[Qt.Key] = ...
        Key_ParenLeft: ClassVar[Qt.Key] = ...
        Key_ParenRight: ClassVar[Qt.Key] = ...
        Key_Paste: ClassVar[Qt.Key] = ...
        Key_Pause: ClassVar[Qt.Key] = ...
        Key_Percent: ClassVar[Qt.Key] = ...
        Key_Period: ClassVar[Qt.Key] = ...
        Key_Phone: ClassVar[Qt.Key] = ...
        Key_Pictures: ClassVar[Qt.Key] = ...
        Key_Play: ClassVar[Qt.Key] = ...
        Key_Plus: ClassVar[Qt.Key] = ...
        Key_PowerDown: ClassVar[Qt.Key] = ...
        Key_PowerOff: ClassVar[Qt.Key] = ...
        Key_PreviousCandidate: ClassVar[Qt.Key] = ...
        Key_Print: ClassVar[Qt.Key] = ...
        Key_Printer: ClassVar[Qt.Key] = ...
        Key_Q: ClassVar[Qt.Key] = ...
        Key_Question: ClassVar[Qt.Key] = ...
        Key_QuoteDbl: ClassVar[Qt.Key] = ...
        Key_QuoteLeft: ClassVar[Qt.Key] = ...
        Key_R: ClassVar[Qt.Key] = ...
        Key_Red: ClassVar[Qt.Key] = ...
        Key_Redo: ClassVar[Qt.Key] = ...
        Key_Refresh: ClassVar[Qt.Key] = ...
        Key_Reload: ClassVar[Qt.Key] = ...
        Key_Reply: ClassVar[Qt.Key] = ...
        Key_Return: ClassVar[Qt.Key] = ...
        Key_Right: ClassVar[Qt.Key] = ...
        Key_Romaji: ClassVar[Qt.Key] = ...
        Key_RotateWindows: ClassVar[Qt.Key] = ...
        Key_RotationKB: ClassVar[Qt.Key] = ...
        Key_RotationPB: ClassVar[Qt.Key] = ...
        Key_S: ClassVar[Qt.Key] = ...
        Key_Save: ClassVar[Qt.Key] = ...
        Key_ScreenSaver: ClassVar[Qt.Key] = ...
        Key_ScrollLock: ClassVar[Qt.Key] = ...
        Key_Search: ClassVar[Qt.Key] = ...
        Key_Select: ClassVar[Qt.Key] = ...
        Key_Semicolon: ClassVar[Qt.Key] = ...
        Key_Send: ClassVar[Qt.Key] = ...
        Key_Settings: ClassVar[Qt.Key] = ...
        Key_Shift: ClassVar[Qt.Key] = ...
        Key_Shop: ClassVar[Qt.Key] = ...
        Key_SingleCandidate: ClassVar[Qt.Key] = ...
        Key_Slash: ClassVar[Qt.Key] = ...
        Key_Sleep: ClassVar[Qt.Key] = ...
        Key_Space: ClassVar[Qt.Key] = ...
        Key_Spell: ClassVar[Qt.Key] = ...
        Key_SplitScreen: ClassVar[Qt.Key] = ...
        Key_Standby: ClassVar[Qt.Key] = ...
        Key_Stop: ClassVar[Qt.Key] = ...
        Key_Subtitle: ClassVar[Qt.Key] = ...
        Key_Super_L: ClassVar[Qt.Key] = ...
        Key_Super_R: ClassVar[Qt.Key] = ...
        Key_Support: ClassVar[Qt.Key] = ...
        Key_Suspend: ClassVar[Qt.Key] = ...
        Key_SysReq: ClassVar[Qt.Key] = ...
        Key_T: ClassVar[Qt.Key] = ...
        Key_THORN: ClassVar[Qt.Key] = ...
        Key_Tab: ClassVar[Qt.Key] = ...
        Key_TaskPane: ClassVar[Qt.Key] = ...
        Key_Terminal: ClassVar[Qt.Key] = ...
        Key_Time: ClassVar[Qt.Key] = ...
        Key_ToDoList: ClassVar[Qt.Key] = ...
        Key_ToggleCallHangup: ClassVar[Qt.Key] = ...
        Key_Tools: ClassVar[Qt.Key] = ...
        Key_TopMenu: ClassVar[Qt.Key] = ...
        Key_TouchpadOff: ClassVar[Qt.Key] = ...
        Key_TouchpadOn: ClassVar[Qt.Key] = ...
        Key_TouchpadToggle: ClassVar[Qt.Key] = ...
        Key_Touroku: ClassVar[Qt.Key] = ...
        Key_Travel: ClassVar[Qt.Key] = ...
        Key_TrebleDown: ClassVar[Qt.Key] = ...
        Key_TrebleUp: ClassVar[Qt.Key] = ...
        Key_U: ClassVar[Qt.Key] = ...
        Key_UWB: ClassVar[Qt.Key] = ...
        Key_Uacute: ClassVar[Qt.Key] = ...
        Key_Ucircumflex: ClassVar[Qt.Key] = ...
        Key_Udiaeresis: ClassVar[Qt.Key] = ...
        Key_Ugrave: ClassVar[Qt.Key] = ...
        Key_Underscore: ClassVar[Qt.Key] = ...
        Key_Undo: ClassVar[Qt.Key] = ...
        Key_Up: ClassVar[Qt.Key] = ...
        Key_V: ClassVar[Qt.Key] = ...
        Key_Video: ClassVar[Qt.Key] = ...
        Key_View: ClassVar[Qt.Key] = ...
        Key_VoiceDial: ClassVar[Qt.Key] = ...
        Key_VolumeDown: ClassVar[Qt.Key] = ...
        Key_VolumeMute: ClassVar[Qt.Key] = ...
        Key_VolumeUp: ClassVar[Qt.Key] = ...
        Key_W: ClassVar[Qt.Key] = ...
        Key_WLAN: ClassVar[Qt.Key] = ...
        Key_WWW: ClassVar[Qt.Key] = ...
        Key_WakeUp: ClassVar[Qt.Key] = ...
        Key_WebCam: ClassVar[Qt.Key] = ...
        Key_Word: ClassVar[Qt.Key] = ...
        Key_X: ClassVar[Qt.Key] = ...
        Key_Xfer: ClassVar[Qt.Key] = ...
        Key_Y: ClassVar[Qt.Key] = ...
        Key_Yacute: ClassVar[Qt.Key] = ...
        Key_Yellow: ClassVar[Qt.Key] = ...
        Key_Yes: ClassVar[Qt.Key] = ...
        Key_Z: ClassVar[Qt.Key] = ...
        Key_Zenkaku: ClassVar[Qt.Key] = ...
        Key_Zenkaku_Hankaku: ClassVar[Qt.Key] = ...
        Key_Zoom: ClassVar[Qt.Key] = ...
        Key_ZoomIn: ClassVar[Qt.Key] = ...
        Key_ZoomOut: ClassVar[Qt.Key] = ...
        Key_acute: ClassVar[Qt.Key] = ...
        Key_brokenbar: ClassVar[Qt.Key] = ...
        Key_cedilla: ClassVar[Qt.Key] = ...
        Key_cent: ClassVar[Qt.Key] = ...
        Key_copyright: ClassVar[Qt.Key] = ...
        Key_currency: ClassVar[Qt.Key] = ...
        Key_degree: ClassVar[Qt.Key] = ...
        Key_diaeresis: ClassVar[Qt.Key] = ...
        Key_division: ClassVar[Qt.Key] = ...
        Key_exclamdown: ClassVar[Qt.Key] = ...
        Key_guillemotleft: ClassVar[Qt.Key] = ...
        Key_guillemotright: ClassVar[Qt.Key] = ...
        Key_hyphen: ClassVar[Qt.Key] = ...
        Key_iTouch: ClassVar[Qt.Key] = ...
        Key_macron: ClassVar[Qt.Key] = ...
        Key_masculine: ClassVar[Qt.Key] = ...
        Key_mu: ClassVar[Qt.Key] = ...
        Key_multiply: ClassVar[Qt.Key] = ...
        Key_nobreakspace: ClassVar[Qt.Key] = ...
        Key_notsign: ClassVar[Qt.Key] = ...
        Key_onehalf: ClassVar[Qt.Key] = ...
        Key_onequarter: ClassVar[Qt.Key] = ...
        Key_onesuperior: ClassVar[Qt.Key] = ...
        Key_ordfeminine: ClassVar[Qt.Key] = ...
        Key_paragraph: ClassVar[Qt.Key] = ...
        Key_periodcentered: ClassVar[Qt.Key] = ...
        Key_plusminus: ClassVar[Qt.Key] = ...
        Key_questiondown: ClassVar[Qt.Key] = ...
        Key_registered: ClassVar[Qt.Key] = ...
        Key_section: ClassVar[Qt.Key] = ...
        Key_ssharp: ClassVar[Qt.Key] = ...
        Key_sterling: ClassVar[Qt.Key] = ...
        Key_threequarters: ClassVar[Qt.Key] = ...
        Key_threesuperior: ClassVar[Qt.Key] = ...
        Key_twosuperior: ClassVar[Qt.Key] = ...
        Key_unknown: ClassVar[Qt.Key] = ...
        Key_ydiaeresis: ClassVar[Qt.Key] = ...
        Key_yen: ClassVar[Qt.Key] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.Key: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Key: ...

    class KeyboardModifier:
        AltModifier: ClassVar[Qt.KeyboardModifier] = ...
        ControlModifier: ClassVar[Qt.KeyboardModifier] = ...
        GroupSwitchModifier: ClassVar[Qt.KeyboardModifier] = ...
        KeyboardModifierMask: ClassVar[Qt.KeyboardModifier] = ...
        KeypadModifier: ClassVar[Qt.KeyboardModifier] = ...
        MetaModifier: ClassVar[Qt.KeyboardModifier] = ...
        NoModifier: ClassVar[Qt.KeyboardModifier] = ...
        ShiftModifier: ClassVar[Qt.KeyboardModifier] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.KeyboardModifier: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...

    class KeyboardModifiers:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.KeyboardModifiers: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.KeyboardModifiers: ...

    class LayoutDirection:
        LayoutDirectionAuto: ClassVar[Qt.LayoutDirection] = ...
        LeftToRight: ClassVar[Qt.LayoutDirection] = ...
        RightToLeft: ClassVar[Qt.LayoutDirection] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.LayoutDirection: ...

    class MaskMode:
        MaskInColor: ClassVar[Qt.MaskMode] = ...
        MaskOutColor: ClassVar[Qt.MaskMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MaskMode: ...

    class MatchFlag:
        MatchCaseSensitive: ClassVar[Qt.MatchFlag] = ...
        MatchContains: ClassVar[Qt.MatchFlag] = ...
        MatchEndsWith: ClassVar[Qt.MatchFlag] = ...
        MatchExactly: ClassVar[Qt.MatchFlag] = ...
        MatchFixedString: ClassVar[Qt.MatchFlag] = ...
        MatchRecursive: ClassVar[Qt.MatchFlag] = ...
        MatchRegExp: ClassVar[Qt.MatchFlag] = ...
        MatchRegularExpression: ClassVar[Qt.MatchFlag] = ...
        MatchStartsWith: ClassVar[Qt.MatchFlag] = ...
        MatchWildcard: ClassVar[Qt.MatchFlag] = ...
        MatchWrap: ClassVar[Qt.MatchFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.MatchFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...

    class MatchFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.MatchFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MatchFlags: ...

    class Modifier:
        ALT: ClassVar[Qt.Modifier] = ...
        CTRL: ClassVar[Qt.Modifier] = ...
        META: ClassVar[Qt.Modifier] = ...
        MODIFIER_MASK: ClassVar[Qt.Modifier] = ...
        SHIFT: ClassVar[Qt.Modifier] = ...
        UNICODE_ACCEL: ClassVar[Qt.Modifier] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.Modifier: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Modifier: ...

    class MouseButton:
        AllButtons: ClassVar[Qt.MouseButton] = ...
        BackButton: ClassVar[Qt.MouseButton] = ...
        ExtraButton1: ClassVar[Qt.MouseButton] = ...
        ExtraButton10: ClassVar[Qt.MouseButton] = ...
        ExtraButton11: ClassVar[Qt.MouseButton] = ...
        ExtraButton12: ClassVar[Qt.MouseButton] = ...
        ExtraButton13: ClassVar[Qt.MouseButton] = ...
        ExtraButton14: ClassVar[Qt.MouseButton] = ...
        ExtraButton15: ClassVar[Qt.MouseButton] = ...
        ExtraButton16: ClassVar[Qt.MouseButton] = ...
        ExtraButton17: ClassVar[Qt.MouseButton] = ...
        ExtraButton18: ClassVar[Qt.MouseButton] = ...
        ExtraButton19: ClassVar[Qt.MouseButton] = ...
        ExtraButton2: ClassVar[Qt.MouseButton] = ...
        ExtraButton20: ClassVar[Qt.MouseButton] = ...
        ExtraButton21: ClassVar[Qt.MouseButton] = ...
        ExtraButton22: ClassVar[Qt.MouseButton] = ...
        ExtraButton23: ClassVar[Qt.MouseButton] = ...
        ExtraButton24: ClassVar[Qt.MouseButton] = ...
        ExtraButton3: ClassVar[Qt.MouseButton] = ...
        ExtraButton4: ClassVar[Qt.MouseButton] = ...
        ExtraButton5: ClassVar[Qt.MouseButton] = ...
        ExtraButton6: ClassVar[Qt.MouseButton] = ...
        ExtraButton7: ClassVar[Qt.MouseButton] = ...
        ExtraButton8: ClassVar[Qt.MouseButton] = ...
        ExtraButton9: ClassVar[Qt.MouseButton] = ...
        ForwardButton: ClassVar[Qt.MouseButton] = ...
        LeftButton: ClassVar[Qt.MouseButton] = ...
        MaxMouseButton: ClassVar[Qt.MouseButton] = ...
        MidButton: ClassVar[Qt.MouseButton] = ...
        MiddleButton: ClassVar[Qt.MouseButton] = ...
        MouseButtonMask: ClassVar[Qt.MouseButton] = ...
        NoButton: ClassVar[Qt.MouseButton] = ...
        RightButton: ClassVar[Qt.MouseButton] = ...
        TaskButton: ClassVar[Qt.MouseButton] = ...
        XButton1: ClassVar[Qt.MouseButton] = ...
        XButton2: ClassVar[Qt.MouseButton] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.MouseButton: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...

    class MouseButtons:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.MouseButtons: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MouseButtons: ...

    class MouseEventFlag:
        MouseEventCreatedDoubleClick: ClassVar[Qt.MouseEventFlag] = ...
        MouseEventFlagMask: ClassVar[Qt.MouseEventFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.MouseEventFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...

    class MouseEventFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.MouseEventFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MouseEventFlags: ...

    class MouseEventSource:
        MouseEventNotSynthesized: ClassVar[Qt.MouseEventSource] = ...
        MouseEventSynthesizedByApplication: ClassVar[Qt.MouseEventSource] = ...
        MouseEventSynthesizedByQt: ClassVar[Qt.MouseEventSource] = ...
        MouseEventSynthesizedBySystem: ClassVar[Qt.MouseEventSource] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.MouseEventSource: ...

    class NativeGestureType:
        BeginNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        EndNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        PanNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        RotateNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        SmartZoomNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        SwipeNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        ZoomNativeGesture: ClassVar[Qt.NativeGestureType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.NativeGestureType: ...

    class NavigationMode:
        NavigationModeCursorAuto: ClassVar[Qt.NavigationMode] = ...
        NavigationModeCursorForceVisible: ClassVar[Qt.NavigationMode] = ...
        NavigationModeKeypadDirectional: ClassVar[Qt.NavigationMode] = ...
        NavigationModeKeypadTabOrder: ClassVar[Qt.NavigationMode] = ...
        NavigationModeNone: ClassVar[Qt.NavigationMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.NavigationMode: ...

    class Orientation:
        Horizontal: ClassVar[Qt.Orientation] = ...
        Vertical: ClassVar[Qt.Orientation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.Orientation: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Orientations: ...

    class Orientations:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.Orientations: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.Orientations: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.Orientations: ...

    class PenCapStyle:
        FlatCap: ClassVar[Qt.PenCapStyle] = ...
        MPenCapStyle: ClassVar[Qt.PenCapStyle] = ...
        RoundCap: ClassVar[Qt.PenCapStyle] = ...
        SquareCap: ClassVar[Qt.PenCapStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.PenCapStyle: ...

    class PenJoinStyle:
        BevelJoin: ClassVar[Qt.PenJoinStyle] = ...
        MPenJoinStyle: ClassVar[Qt.PenJoinStyle] = ...
        MiterJoin: ClassVar[Qt.PenJoinStyle] = ...
        RoundJoin: ClassVar[Qt.PenJoinStyle] = ...
        SvgMiterJoin: ClassVar[Qt.PenJoinStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.PenJoinStyle: ...

    class PenStyle:
        CustomDashLine: ClassVar[Qt.PenStyle] = ...
        DashDotDotLine: ClassVar[Qt.PenStyle] = ...
        DashDotLine: ClassVar[Qt.PenStyle] = ...
        DashLine: ClassVar[Qt.PenStyle] = ...
        DotLine: ClassVar[Qt.PenStyle] = ...
        MPenStyle: ClassVar[Qt.PenStyle] = ...
        NoPen: ClassVar[Qt.PenStyle] = ...
        SolidLine: ClassVar[Qt.PenStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.PenStyle: ...

    class ScreenOrientation:
        InvertedLandscapeOrientation: ClassVar[Qt.ScreenOrientation] = ...
        InvertedPortraitOrientation: ClassVar[Qt.ScreenOrientation] = ...
        LandscapeOrientation: ClassVar[Qt.ScreenOrientation] = ...
        PortraitOrientation: ClassVar[Qt.ScreenOrientation] = ...
        PrimaryOrientation: ClassVar[Qt.ScreenOrientation] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ScreenOrientation: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...

    class ScreenOrientations:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ScreenOrientations: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ScreenOrientations: ...

    class ScrollBarPolicy:
        ScrollBarAlwaysOff: ClassVar[Qt.ScrollBarPolicy] = ...
        ScrollBarAlwaysOn: ClassVar[Qt.ScrollBarPolicy] = ...
        ScrollBarAsNeeded: ClassVar[Qt.ScrollBarPolicy] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ScrollBarPolicy: ...

    class ScrollPhase:
        NoScrollPhase: ClassVar[Qt.ScrollPhase] = ...
        ScrollBegin: ClassVar[Qt.ScrollPhase] = ...
        ScrollEnd: ClassVar[Qt.ScrollPhase] = ...
        ScrollMomentum: ClassVar[Qt.ScrollPhase] = ...
        ScrollUpdate: ClassVar[Qt.ScrollPhase] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ScrollPhase: ...

    class ShortcutContext:
        ApplicationShortcut: ClassVar[Qt.ShortcutContext] = ...
        WidgetShortcut: ClassVar[Qt.ShortcutContext] = ...
        WidgetWithChildrenShortcut: ClassVar[Qt.ShortcutContext] = ...
        WindowShortcut: ClassVar[Qt.ShortcutContext] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ShortcutContext: ...

    class SizeHint:
        MaximumSize: ClassVar[Qt.SizeHint] = ...
        MinimumDescent: ClassVar[Qt.SizeHint] = ...
        MinimumSize: ClassVar[Qt.SizeHint] = ...
        NSizeHints: ClassVar[Qt.SizeHint] = ...
        PreferredSize: ClassVar[Qt.SizeHint] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.SizeHint: ...

    class SizeMode:
        AbsoluteSize: ClassVar[Qt.SizeMode] = ...
        RelativeSize: ClassVar[Qt.SizeMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.SizeMode: ...

    class SortOrder:
        AscendingOrder: ClassVar[Qt.SortOrder] = ...
        DescendingOrder: ClassVar[Qt.SortOrder] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.SortOrder: ...

    class SplitBehavior:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.SplitBehavior: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...

    class SplitBehaviorFlags:
        KeepEmptyParts: ClassVar[Qt.SplitBehaviorFlags] = ...
        SkipEmptyParts: ClassVar[Qt.SplitBehaviorFlags] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.SplitBehaviorFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.SplitBehavior: ...

    class TabFocusBehavior:
        NoTabFocus: ClassVar[Qt.TabFocusBehavior] = ...
        TabFocusAllControls: ClassVar[Qt.TabFocusBehavior] = ...
        TabFocusListControls: ClassVar[Qt.TabFocusBehavior] = ...
        TabFocusTextControls: ClassVar[Qt.TabFocusBehavior] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TabFocusBehavior: ...

    class TextElideMode:
        ElideLeft: ClassVar[Qt.TextElideMode] = ...
        ElideMiddle: ClassVar[Qt.TextElideMode] = ...
        ElideNone: ClassVar[Qt.TextElideMode] = ...
        ElideRight: ClassVar[Qt.TextElideMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TextElideMode: ...

    class TextFlag:
        TextBypassShaping: ClassVar[Qt.TextFlag] = ...
        TextDontClip: ClassVar[Qt.TextFlag] = ...
        TextDontPrint: ClassVar[Qt.TextFlag] = ...
        TextExpandTabs: ClassVar[Qt.TextFlag] = ...
        TextForceLeftToRight: ClassVar[Qt.TextFlag] = ...
        TextForceRightToLeft: ClassVar[Qt.TextFlag] = ...
        TextHideMnemonic: ClassVar[Qt.TextFlag] = ...
        TextIncludeTrailingSpaces: ClassVar[Qt.TextFlag] = ...
        TextJustificationForced: ClassVar[Qt.TextFlag] = ...
        TextLongestVariant: ClassVar[Qt.TextFlag] = ...
        TextShowMnemonic: ClassVar[Qt.TextFlag] = ...
        TextSingleLine: ClassVar[Qt.TextFlag] = ...
        TextWordWrap: ClassVar[Qt.TextFlag] = ...
        TextWrapAnywhere: ClassVar[Qt.TextFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TextFlag: ...

    class TextFormat:
        AutoText: ClassVar[Qt.TextFormat] = ...
        MarkdownText: ClassVar[Qt.TextFormat] = ...
        PlainText: ClassVar[Qt.TextFormat] = ...
        RichText: ClassVar[Qt.TextFormat] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TextFormat: ...

    class TextInteractionFlag:
        LinksAccessibleByKeyboard: ClassVar[Qt.TextInteractionFlag] = ...
        LinksAccessibleByMouse: ClassVar[Qt.TextInteractionFlag] = ...
        NoTextInteraction: ClassVar[Qt.TextInteractionFlag] = ...
        TextBrowserInteraction: ClassVar[Qt.TextInteractionFlag] = ...
        TextEditable: ClassVar[Qt.TextInteractionFlag] = ...
        TextEditorInteraction: ClassVar[Qt.TextInteractionFlag] = ...
        TextSelectableByKeyboard: ClassVar[Qt.TextInteractionFlag] = ...
        TextSelectableByMouse: ClassVar[Qt.TextInteractionFlag] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.TextInteractionFlag: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...

    class TextInteractionFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.TextInteractionFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TextInteractionFlags: ...

    class TileRule:
        RepeatTile: ClassVar[Qt.TileRule] = ...
        RoundTile: ClassVar[Qt.TileRule] = ...
        StretchTile: ClassVar[Qt.TileRule] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TileRule: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TileRule: ...

    class TimeSpec:
        LocalTime: ClassVar[Qt.TimeSpec] = ...
        OffsetFromUTC: ClassVar[Qt.TimeSpec] = ...
        TimeZone: ClassVar[Qt.TimeSpec] = ...
        UTC: ClassVar[Qt.TimeSpec] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TimeSpec: ...

    class TimerType:
        CoarseTimer: ClassVar[Qt.TimerType] = ...
        PreciseTimer: ClassVar[Qt.TimerType] = ...
        VeryCoarseTimer: ClassVar[Qt.TimerType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TimerType: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TimerType: ...

    class ToolBarArea:
        AllToolBarAreas: ClassVar[Qt.ToolBarArea] = ...
        BottomToolBarArea: ClassVar[Qt.ToolBarArea] = ...
        LeftToolBarArea: ClassVar[Qt.ToolBarArea] = ...
        NoToolBarArea: ClassVar[Qt.ToolBarArea] = ...
        RightToolBarArea: ClassVar[Qt.ToolBarArea] = ...
        ToolBarArea_Mask: ClassVar[Qt.ToolBarArea] = ...
        TopToolBarArea: ClassVar[Qt.ToolBarArea] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ToolBarArea: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...

    class ToolBarAreaSizes:
        NToolBarAreas: ClassVar[Qt.ToolBarAreaSizes] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ToolBarAreaSizes: ...

    class ToolBarAreas:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.ToolBarAreas: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ToolBarAreas: ...

    class ToolButtonStyle:
        ToolButtonFollowStyle: ClassVar[Qt.ToolButtonStyle] = ...
        ToolButtonIconOnly: ClassVar[Qt.ToolButtonStyle] = ...
        ToolButtonTextBesideIcon: ClassVar[Qt.ToolButtonStyle] = ...
        ToolButtonTextOnly: ClassVar[Qt.ToolButtonStyle] = ...
        ToolButtonTextUnderIcon: ClassVar[Qt.ToolButtonStyle] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.ToolButtonStyle: ...

    class TouchPointState:
        TouchPointMoved: ClassVar[Qt.TouchPointState] = ...
        TouchPointPressed: ClassVar[Qt.TouchPointState] = ...
        TouchPointReleased: ClassVar[Qt.TouchPointState] = ...
        TouchPointStationary: ClassVar[Qt.TouchPointState] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.TouchPointState: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...

    class TouchPointStates:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.TouchPointStates: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TouchPointStates: ...

    class TransformationMode:
        FastTransformation: ClassVar[Qt.TransformationMode] = ...
        SmoothTransformation: ClassVar[Qt.TransformationMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.TransformationMode: ...

    class UIEffect:
        UI_AnimateCombo: ClassVar[Qt.UIEffect] = ...
        UI_AnimateMenu: ClassVar[Qt.UIEffect] = ...
        UI_AnimateToolBox: ClassVar[Qt.UIEffect] = ...
        UI_AnimateTooltip: ClassVar[Qt.UIEffect] = ...
        UI_FadeMenu: ClassVar[Qt.UIEffect] = ...
        UI_FadeTooltip: ClassVar[Qt.UIEffect] = ...
        UI_General: ClassVar[Qt.UIEffect] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.UIEffect: ...

    class WhiteSpaceMode:
        WhiteSpaceModeUndefined: ClassVar[Qt.WhiteSpaceMode] = ...
        WhiteSpaceNoWrap: ClassVar[Qt.WhiteSpaceMode] = ...
        WhiteSpaceNormal: ClassVar[Qt.WhiteSpaceMode] = ...
        WhiteSpacePre: ClassVar[Qt.WhiteSpaceMode] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WhiteSpaceMode: ...

    class WidgetAttribute:
        WA_AcceptDrops: ClassVar[Qt.WidgetAttribute] = ...
        WA_AcceptTouchEvents: ClassVar[Qt.WidgetAttribute] = ...
        WA_AlwaysShowToolTips: ClassVar[Qt.WidgetAttribute] = ...
        WA_AlwaysStackOnTop: ClassVar[Qt.WidgetAttribute] = ...
        WA_AttributeCount: ClassVar[Qt.WidgetAttribute] = ...
        WA_CanHostQMdiSubWindowTitleBar: ClassVar[Qt.WidgetAttribute] = ...
        WA_ContentsMarginsRespectsSafeArea: ClassVar[Qt.WidgetAttribute] = ...
        WA_ContentsPropagated: ClassVar[Qt.WidgetAttribute] = ...
        WA_CustomWhatsThis: ClassVar[Qt.WidgetAttribute] = ...
        WA_DeleteOnClose: ClassVar[Qt.WidgetAttribute] = ...
        WA_Disabled: ClassVar[Qt.WidgetAttribute] = ...
        WA_DontCreateNativeAncestors: ClassVar[Qt.WidgetAttribute] = ...
        WA_DontShowOnScreen: ClassVar[Qt.WidgetAttribute] = ...
        WA_DropSiteRegistered: ClassVar[Qt.WidgetAttribute] = ...
        WA_ForceAcceptDrops: ClassVar[Qt.WidgetAttribute] = ...
        WA_ForceDisabled: ClassVar[Qt.WidgetAttribute] = ...
        WA_ForceUpdatesDisabled: ClassVar[Qt.WidgetAttribute] = ...
        WA_GrabbedShortcut: ClassVar[Qt.WidgetAttribute] = ...
        WA_GroupLeader: ClassVar[Qt.WidgetAttribute] = ...
        WA_Hover: ClassVar[Qt.WidgetAttribute] = ...
        WA_InputMethodEnabled: ClassVar[Qt.WidgetAttribute] = ...
        WA_InputMethodTransparent: ClassVar[Qt.WidgetAttribute] = ...
        WA_InvalidSize: ClassVar[Qt.WidgetAttribute] = ...
        WA_KeyCompression: ClassVar[Qt.WidgetAttribute] = ...
        WA_KeyboardFocusChange: ClassVar[Qt.WidgetAttribute] = ...
        WA_LaidOut: ClassVar[Qt.WidgetAttribute] = ...
        WA_LayoutOnEntireRect: ClassVar[Qt.WidgetAttribute] = ...
        WA_LayoutUsesWidgetRect: ClassVar[Qt.WidgetAttribute] = ...
        WA_MSWindowsUseDirect3D: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacAlwaysShowToolWindow: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacBrushedMetal: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacFrameworkScaled: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacMetalStyle: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacMiniSize: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacNoClickThrough: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacNoShadow: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacNormalSize: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacOpaqueSizeGrip: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacShowFocusRect: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacSmallSize: ClassVar[Qt.WidgetAttribute] = ...
        WA_MacVariableSize: ClassVar[Qt.WidgetAttribute] = ...
        WA_Mapped: ClassVar[Qt.WidgetAttribute] = ...
        WA_MouseNoMask: ClassVar[Qt.WidgetAttribute] = ...
        WA_MouseTracking: ClassVar[Qt.WidgetAttribute] = ...
        WA_Moved: ClassVar[Qt.WidgetAttribute] = ...
        WA_NativeWindow: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoBackground: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoChildEventsForParent: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoChildEventsFromChildren: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoMousePropagation: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoMouseReplay: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoSystemBackground: ClassVar[Qt.WidgetAttribute] = ...
        WA_NoX11EventCompression: ClassVar[Qt.WidgetAttribute] = ...
        WA_OpaquePaintEvent: ClassVar[Qt.WidgetAttribute] = ...
        WA_OutsideWSRange: ClassVar[Qt.WidgetAttribute] = ...
        WA_PaintOnScreen: ClassVar[Qt.WidgetAttribute] = ...
        WA_PaintUnclipped: ClassVar[Qt.WidgetAttribute] = ...
        WA_PendingMoveEvent: ClassVar[Qt.WidgetAttribute] = ...
        WA_PendingResizeEvent: ClassVar[Qt.WidgetAttribute] = ...
        WA_PendingUpdate: ClassVar[Qt.WidgetAttribute] = ...
        WA_QuitOnClose: ClassVar[Qt.WidgetAttribute] = ...
        WA_Resized: ClassVar[Qt.WidgetAttribute] = ...
        WA_RightToLeft: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetCursor: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetFont: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetLayoutDirection: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetLocale: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetPalette: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetStyle: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetWindowIcon: ClassVar[Qt.WidgetAttribute] = ...
        WA_SetWindowModality: ClassVar[Qt.WidgetAttribute] = ...
        WA_ShowModal: ClassVar[Qt.WidgetAttribute] = ...
        WA_ShowWithoutActivating: ClassVar[Qt.WidgetAttribute] = ...
        WA_StaticContents: ClassVar[Qt.WidgetAttribute] = ...
        WA_StyleSheet: ClassVar[Qt.WidgetAttribute] = ...
        WA_StyleSheetTarget: ClassVar[Qt.WidgetAttribute] = ...
        WA_StyledBackground: ClassVar[Qt.WidgetAttribute] = ...
        WA_TabletTracking: ClassVar[Qt.WidgetAttribute] = ...
        WA_TintedBackground: ClassVar[Qt.WidgetAttribute] = ...
        WA_TouchPadAcceptSingleTouchEvents: ClassVar[Qt.WidgetAttribute] = ...
        WA_TranslucentBackground: ClassVar[Qt.WidgetAttribute] = ...
        WA_TransparentForMouseEvents: ClassVar[Qt.WidgetAttribute] = ...
        WA_UnderMouse: ClassVar[Qt.WidgetAttribute] = ...
        WA_UpdatesDisabled: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_AcceptedTouchBeginEvent: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_CompressKeys: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_ConfigPending: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_Created: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_DND: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_ExplicitShowHide: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_Hidden: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_InPaintEvent: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_OwnSizePolicy: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_Polished: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_Reparented: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_Visible: ClassVar[Qt.WidgetAttribute] = ...
        WA_WState_WindowOpacitySet: ClassVar[Qt.WidgetAttribute] = ...
        WA_WindowModified: ClassVar[Qt.WidgetAttribute] = ...
        WA_WindowPropagation: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11BypassTransientForHint: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11DoNotAcceptFocus: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeCombo: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeDND: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeDesktop: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeDialog: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeDock: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeDropDownMenu: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeMenu: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeNotification: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypePopupMenu: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeSplash: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeToolBar: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeToolTip: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11NetWmWindowTypeUtility: ClassVar[Qt.WidgetAttribute] = ...
        WA_X11OpenGLOverlay: ClassVar[Qt.WidgetAttribute] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WidgetAttribute: ...

    class WindowFlags:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.WindowFlags: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...

    class WindowFrameSection:
        BottomLeftSection: ClassVar[Qt.WindowFrameSection] = ...
        BottomRightSection: ClassVar[Qt.WindowFrameSection] = ...
        BottomSection: ClassVar[Qt.WindowFrameSection] = ...
        LeftSection: ClassVar[Qt.WindowFrameSection] = ...
        NoSection: ClassVar[Qt.WindowFrameSection] = ...
        RightSection: ClassVar[Qt.WindowFrameSection] = ...
        TitleBarArea: ClassVar[Qt.WindowFrameSection] = ...
        TopLeftSection: ClassVar[Qt.WindowFrameSection] = ...
        TopRightSection: ClassVar[Qt.WindowFrameSection] = ...
        TopSection: ClassVar[Qt.WindowFrameSection] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WindowFrameSection: ...

    class WindowModality:
        ApplicationModal: ClassVar[Qt.WindowModality] = ...
        NonModal: ClassVar[Qt.WindowModality] = ...
        WindowModal: ClassVar[Qt.WindowModality] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __add__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __mul__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __pos__(self) -> Any: ...
        def __radd__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __rmul__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __rsub__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __sub__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WindowModality: ...

    class WindowState:
        WindowActive: ClassVar[Qt.WindowState] = ...
        WindowFullScreen: ClassVar[Qt.WindowState] = ...
        WindowMaximized: ClassVar[Qt.WindowState] = ...
        WindowMinimized: ClassVar[Qt.WindowState] = ...
        WindowNoState: ClassVar[Qt.WindowState] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.WindowState: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...

    class WindowStates:
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.WindowStates: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WindowStates: ...

    class WindowType:
        BypassGraphicsProxyWidget: ClassVar[Qt.WindowType] = ...
        BypassWindowManagerHint: ClassVar[Qt.WindowType] = ...
        CoverWindow: ClassVar[Qt.WindowType] = ...
        CustomizeWindowHint: ClassVar[Qt.WindowType] = ...
        Desktop: ClassVar[Qt.WindowType] = ...
        Dialog: ClassVar[Qt.WindowType] = ...
        Drawer: ClassVar[Qt.WindowType] = ...
        ForeignWindow: ClassVar[Qt.WindowType] = ...
        FramelessWindowHint: ClassVar[Qt.WindowType] = ...
        MSWindowsFixedSizeDialogHint: ClassVar[Qt.WindowType] = ...
        MSWindowsOwnDC: ClassVar[Qt.WindowType] = ...
        MacWindowToolBarButtonHint: ClassVar[Qt.WindowType] = ...
        MaximizeUsingFullscreenGeometryHint: ClassVar[Qt.WindowType] = ...
        NoDropShadowWindowHint: ClassVar[Qt.WindowType] = ...
        Popup: ClassVar[Qt.WindowType] = ...
        Sheet: ClassVar[Qt.WindowType] = ...
        SplashScreen: ClassVar[Qt.WindowType] = ...
        SubWindow: ClassVar[Qt.WindowType] = ...
        Tool: ClassVar[Qt.WindowType] = ...
        ToolTip: ClassVar[Qt.WindowType] = ...
        Widget: ClassVar[Qt.WindowType] = ...
        Window: ClassVar[Qt.WindowType] = ...
        WindowCloseButtonHint: ClassVar[Qt.WindowType] = ...
        WindowContextHelpButtonHint: ClassVar[Qt.WindowType] = ...
        WindowDoesNotAcceptFocus: ClassVar[Qt.WindowType] = ...
        WindowFullscreenButtonHint: ClassVar[Qt.WindowType] = ...
        WindowMaximizeButtonHint: ClassVar[Qt.WindowType] = ...
        WindowMinMaxButtonsHint: ClassVar[Qt.WindowType] = ...
        WindowMinimizeButtonHint: ClassVar[Qt.WindowType] = ...
        WindowOverridesSystemGestures: ClassVar[Qt.WindowType] = ...
        WindowShadeButtonHint: ClassVar[Qt.WindowType] = ...
        WindowStaysOnBottomHint: ClassVar[Qt.WindowType] = ...
        WindowStaysOnTopHint: ClassVar[Qt.WindowType] = ...
        WindowSystemMenuHint: ClassVar[Qt.WindowType] = ...
        WindowTitleHint: ClassVar[Qt.WindowType] = ...
        WindowTransparentForInput: ClassVar[Qt.WindowType] = ...
        WindowType_Mask: ClassVar[Qt.WindowType] = ...
        X11BypassWindowManagerHint: ClassVar[Qt.WindowType] = ...
        values: ClassVar[dict] = ...
        name: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        def __and__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Qt.WindowType: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __rand__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __ror__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __rxor__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
        def __xor__(self, other: typing.SupportsInt) -> Qt.WindowFlags: ...
    AA_AttributeCount: ClassVar[Qt.ApplicationAttribute] = ...
    AA_CompressHighFrequencyEvents: ClassVar[Qt.ApplicationAttribute] = ...
    AA_CompressTabletEvents: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DisableHighDpiScaling: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DisableNativeVirtualKeyboard: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DisableSessionManager: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DisableShaderDiskCache: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DisableWindowContextHelpButton: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DontCheckOpenGLContextThreadAffinity: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DontCreateNativeWidgetSiblings: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DontShowIconsInMenus: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DontShowShortcutsInContextMenus: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DontUseNativeDialogs: ClassVar[Qt.ApplicationAttribute] = ...
    AA_DontUseNativeMenuBar: ClassVar[Qt.ApplicationAttribute] = ...
    AA_EnableHighDpiScaling: ClassVar[Qt.ApplicationAttribute] = ...
    AA_ForceRasterWidgets: ClassVar[Qt.ApplicationAttribute] = ...
    AA_ImmediateWidgetCreation: ClassVar[Qt.ApplicationAttribute] = ...
    AA_MSWindowsUseDirect3DByDefault: ClassVar[Qt.ApplicationAttribute] = ...
    AA_MacDontSwapCtrlAndMeta: ClassVar[Qt.ApplicationAttribute] = ...
    AA_MacPluginApplication: ClassVar[Qt.ApplicationAttribute] = ...
    AA_NativeWindows: ClassVar[Qt.ApplicationAttribute] = ...
    AA_PluginApplication: ClassVar[Qt.ApplicationAttribute] = ...
    AA_SetPalette: ClassVar[Qt.ApplicationAttribute] = ...
    AA_ShareOpenGLContexts: ClassVar[Qt.ApplicationAttribute] = ...
    AA_SynthesizeMouseForUnhandledTabletEvents: ClassVar[Qt.ApplicationAttribute] = ...
    AA_SynthesizeMouseForUnhandledTouchEvents: ClassVar[Qt.ApplicationAttribute] = ...
    AA_SynthesizeTouchForUnhandledMouseEvents: ClassVar[Qt.ApplicationAttribute] = ...
    AA_Use96Dpi: ClassVar[Qt.ApplicationAttribute] = ...
    AA_UseDesktopOpenGL: ClassVar[Qt.ApplicationAttribute] = ...
    AA_UseHighDpiPixmaps: ClassVar[Qt.ApplicationAttribute] = ...
    AA_UseOpenGLES: ClassVar[Qt.ApplicationAttribute] = ...
    AA_UseSoftwareOpenGL: ClassVar[Qt.ApplicationAttribute] = ...
    AA_UseStyleSheetPropagationInWidgetStyles: ClassVar[Qt.ApplicationAttribute] = ...
    AA_X11InitThreads: ClassVar[Qt.ApplicationAttribute] = ...
    ALT: ClassVar[Qt.Modifier] = ...
    AbsoluteSize: ClassVar[Qt.SizeMode] = ...
    AccessibleDescriptionRole: ClassVar[Qt.ItemDataRole] = ...
    AccessibleTextRole: ClassVar[Qt.ItemDataRole] = ...
    ActionMask: ClassVar[Qt.DropAction] = ...
    ActionsContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
    ActiveWindowFocusReason: ClassVar[Qt.FocusReason] = ...
    AddToSelection: ClassVar[Qt.ItemSelectionOperation] = ...
    AlignAbsolute: ClassVar[Qt.AlignmentFlag] = ...
    AlignBaseline: ClassVar[Qt.AlignmentFlag] = ...
    AlignBottom: ClassVar[Qt.AlignmentFlag] = ...
    AlignCenter: ClassVar[Qt.AlignmentFlag] = ...
    AlignHCenter: ClassVar[Qt.AlignmentFlag] = ...
    AlignHorizontal_Mask: ClassVar[Qt.AlignmentFlag] = ...
    AlignJustify: ClassVar[Qt.AlignmentFlag] = ...
    AlignLeading: ClassVar[Qt.AlignmentFlag] = ...
    AlignLeft: ClassVar[Qt.AlignmentFlag] = ...
    AlignRight: ClassVar[Qt.AlignmentFlag] = ...
    AlignTop: ClassVar[Qt.AlignmentFlag] = ...
    AlignTrailing: ClassVar[Qt.AlignmentFlag] = ...
    AlignVCenter: ClassVar[Qt.AlignmentFlag] = ...
    AlignVertical_Mask: ClassVar[Qt.AlignmentFlag] = ...
    AllButtons: ClassVar[Qt.MouseButton] = ...
    AllDockWidgetAreas: ClassVar[Qt.DockWidgetArea] = ...
    AllToolBarAreas: ClassVar[Qt.ToolBarArea] = ...
    AlphaDither_Mask: ClassVar[Qt.ImageConversionFlag] = ...
    AltModifier: ClassVar[Qt.KeyboardModifier] = ...
    AnchorBottom: ClassVar[Qt.AnchorPoint] = ...
    AnchorHorizontalCenter: ClassVar[Qt.AnchorPoint] = ...
    AnchorLeft: ClassVar[Qt.AnchorPoint] = ...
    AnchorRight: ClassVar[Qt.AnchorPoint] = ...
    AnchorTop: ClassVar[Qt.AnchorPoint] = ...
    AnchorVerticalCenter: ClassVar[Qt.AnchorPoint] = ...
    ApplicationActive: ClassVar[Qt.ApplicationState] = ...
    ApplicationHidden: ClassVar[Qt.ApplicationState] = ...
    ApplicationInactive: ClassVar[Qt.ApplicationState] = ...
    ApplicationModal: ClassVar[Qt.WindowModality] = ...
    ApplicationShortcut: ClassVar[Qt.ShortcutContext] = ...
    ApplicationSuspended: ClassVar[Qt.ApplicationState] = ...
    ArrowCursor: ClassVar[Qt.CursorShape] = ...
    AscendingOrder: ClassVar[Qt.SortOrder] = ...
    AutoColor: ClassVar[Qt.ImageConversionFlag] = ...
    AutoConnection: ClassVar[Qt.ConnectionType] = ...
    AutoDither: ClassVar[Qt.ImageConversionFlag] = ...
    AutoText: ClassVar[Qt.TextFormat] = ...
    AvoidDither: ClassVar[Qt.ImageConversionFlag] = ...
    BDiagPattern: ClassVar[Qt.BrushStyle] = ...
    BackButton: ClassVar[Qt.MouseButton] = ...
    BackgroundColorRole: ClassVar[Qt.ItemDataRole] = ...
    BackgroundRole: ClassVar[Qt.ItemDataRole] = ...
    BacktabFocusReason: ClassVar[Qt.FocusReason] = ...
    BeginNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    BevelJoin: ClassVar[Qt.PenJoinStyle] = ...
    BitmapCursor: ClassVar[Qt.CursorShape] = ...
    BlankCursor: ClassVar[Qt.CursorShape] = ...
    BlockingQueuedConnection: ClassVar[Qt.ConnectionType] = ...
    BottomDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
    BottomEdge: ClassVar[Qt.Edge] = ...
    BottomLeftCorner: ClassVar[Qt.Corner] = ...
    BottomLeftSection: ClassVar[Qt.WindowFrameSection] = ...
    BottomRightCorner: ClassVar[Qt.Corner] = ...
    BottomRightSection: ClassVar[Qt.WindowFrameSection] = ...
    BottomSection: ClassVar[Qt.WindowFrameSection] = ...
    BottomToolBarArea: ClassVar[Qt.ToolBarArea] = ...
    BusyCursor: ClassVar[Qt.CursorShape] = ...
    BypassGraphicsProxyWidget: ClassVar[Qt.WindowType] = ...
    BypassWindowManagerHint: ClassVar[Qt.WindowType] = ...
    CTRL: ClassVar[Qt.Modifier] = ...
    CaseInsensitive: ClassVar[Qt.CaseSensitivity] = ...
    CaseSensitive: ClassVar[Qt.CaseSensitivity] = ...
    CheckStateRole: ClassVar[Qt.ItemDataRole] = ...
    Checked: ClassVar[Qt.CheckState] = ...
    ChecksumIso3309: ClassVar[Qt.ChecksumType] = ...
    ChecksumItuV41: ClassVar[Qt.ChecksumType] = ...
    ClickFocus: ClassVar[Qt.FocusPolicy] = ...
    ClosedHandCursor: ClassVar[Qt.CursorShape] = ...
    CoarseTimer: ClassVar[Qt.TimerType] = ...
    ColorMode_Mask: ClassVar[Qt.ImageConversionFlag] = ...
    ColorOnly: ClassVar[Qt.ImageConversionFlag] = ...
    ConicalGradientPattern: ClassVar[Qt.BrushStyle] = ...
    ContainsItemBoundingRect: ClassVar[Qt.ItemSelectionMode] = ...
    ContainsItemShape: ClassVar[Qt.ItemSelectionMode] = ...
    ControlModifier: ClassVar[Qt.KeyboardModifier] = ...
    CopyAction: ClassVar[Qt.DropAction] = ...
    CoverWindow: ClassVar[Qt.WindowType] = ...
    CrossCursor: ClassVar[Qt.CursorShape] = ...
    CrossPattern: ClassVar[Qt.BrushStyle] = ...
    CustomContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
    CustomCursor: ClassVar[Qt.CursorShape] = ...
    CustomDashLine: ClassVar[Qt.PenStyle] = ...
    CustomGesture: ClassVar[Qt.GestureType] = ...
    CustomizeWindowHint: ClassVar[Qt.WindowType] = ...
    DashDotDotLine: ClassVar[Qt.PenStyle] = ...
    DashDotLine: ClassVar[Qt.PenStyle] = ...
    DashLine: ClassVar[Qt.PenStyle] = ...
    DecorationPropertyRole: ClassVar[Qt.ItemDataRole] = ...
    DecorationRole: ClassVar[Qt.ItemDataRole] = ...
    DefaultContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
    DefaultLocaleLongDate: ClassVar[Qt.DateFormat] = ...
    DefaultLocaleShortDate: ClassVar[Qt.DateFormat] = ...
    Dense1Pattern: ClassVar[Qt.BrushStyle] = ...
    Dense2Pattern: ClassVar[Qt.BrushStyle] = ...
    Dense3Pattern: ClassVar[Qt.BrushStyle] = ...
    Dense4Pattern: ClassVar[Qt.BrushStyle] = ...
    Dense5Pattern: ClassVar[Qt.BrushStyle] = ...
    Dense6Pattern: ClassVar[Qt.BrushStyle] = ...
    Dense7Pattern: ClassVar[Qt.BrushStyle] = ...
    DescendingOrder: ClassVar[Qt.SortOrder] = ...
    Desktop: ClassVar[Qt.WindowType] = ...
    DeviceCoordinates: ClassVar[Qt.CoordinateSystem] = ...
    DiagCrossPattern: ClassVar[Qt.BrushStyle] = ...
    Dialog: ClassVar[Qt.WindowType] = ...
    DiffuseAlphaDither: ClassVar[Qt.ImageConversionFlag] = ...
    DiffuseDither: ClassVar[Qt.ImageConversionFlag] = ...
    DirectConnection: ClassVar[Qt.ConnectionType] = ...
    DisplayPropertyRole: ClassVar[Qt.ItemDataRole] = ...
    DisplayRole: ClassVar[Qt.ItemDataRole] = ...
    DitherMode_Mask: ClassVar[Qt.ImageConversionFlag] = ...
    Dither_Mask: ClassVar[Qt.ImageConversionFlag] = ...
    DockWidgetArea_Mask: ClassVar[Qt.DockWidgetArea] = ...
    DontStartGestureOnChildren: ClassVar[Qt.GestureFlag] = ...
    DotLine: ClassVar[Qt.PenStyle] = ...
    DownArrow: ClassVar[Qt.ArrowType] = ...
    DragCopyCursor: ClassVar[Qt.CursorShape] = ...
    DragLinkCursor: ClassVar[Qt.CursorShape] = ...
    DragMoveCursor: ClassVar[Qt.CursorShape] = ...
    Drawer: ClassVar[Qt.WindowType] = ...
    EditRole: ClassVar[Qt.ItemDataRole] = ...
    ElideLeft: ClassVar[Qt.TextElideMode] = ...
    ElideMiddle: ClassVar[Qt.TextElideMode] = ...
    ElideNone: ClassVar[Qt.TextElideMode] = ...
    ElideRight: ClassVar[Qt.TextElideMode] = ...
    EndNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    EnterKeyDefault: ClassVar[Qt.EnterKeyType] = ...
    EnterKeyDone: ClassVar[Qt.EnterKeyType] = ...
    EnterKeyGo: ClassVar[Qt.EnterKeyType] = ...
    EnterKeyNext: ClassVar[Qt.EnterKeyType] = ...
    EnterKeyPrevious: ClassVar[Qt.EnterKeyType] = ...
    EnterKeyReturn: ClassVar[Qt.EnterKeyType] = ...
    EnterKeySearch: ClassVar[Qt.EnterKeyType] = ...
    EnterKeySend: ClassVar[Qt.EnterKeyType] = ...
    ExactHit: ClassVar[Qt.HitTestAccuracy] = ...
    ExtraButton1: ClassVar[Qt.MouseButton] = ...
    ExtraButton10: ClassVar[Qt.MouseButton] = ...
    ExtraButton11: ClassVar[Qt.MouseButton] = ...
    ExtraButton12: ClassVar[Qt.MouseButton] = ...
    ExtraButton13: ClassVar[Qt.MouseButton] = ...
    ExtraButton14: ClassVar[Qt.MouseButton] = ...
    ExtraButton15: ClassVar[Qt.MouseButton] = ...
    ExtraButton16: ClassVar[Qt.MouseButton] = ...
    ExtraButton17: ClassVar[Qt.MouseButton] = ...
    ExtraButton18: ClassVar[Qt.MouseButton] = ...
    ExtraButton19: ClassVar[Qt.MouseButton] = ...
    ExtraButton2: ClassVar[Qt.MouseButton] = ...
    ExtraButton20: ClassVar[Qt.MouseButton] = ...
    ExtraButton21: ClassVar[Qt.MouseButton] = ...
    ExtraButton22: ClassVar[Qt.MouseButton] = ...
    ExtraButton23: ClassVar[Qt.MouseButton] = ...
    ExtraButton24: ClassVar[Qt.MouseButton] = ...
    ExtraButton3: ClassVar[Qt.MouseButton] = ...
    ExtraButton4: ClassVar[Qt.MouseButton] = ...
    ExtraButton5: ClassVar[Qt.MouseButton] = ...
    ExtraButton6: ClassVar[Qt.MouseButton] = ...
    ExtraButton7: ClassVar[Qt.MouseButton] = ...
    ExtraButton8: ClassVar[Qt.MouseButton] = ...
    ExtraButton9: ClassVar[Qt.MouseButton] = ...
    FDiagPattern: ClassVar[Qt.BrushStyle] = ...
    FastTransformation: ClassVar[Qt.TransformationMode] = ...
    FindChildrenRecursively: ClassVar[Qt.FindChildOption] = ...
    FindDirectChildrenOnly: ClassVar[Qt.FindChildOption] = ...
    FlatCap: ClassVar[Qt.PenCapStyle] = ...
    FontRole: ClassVar[Qt.ItemDataRole] = ...
    ForbiddenCursor: ClassVar[Qt.CursorShape] = ...
    ForegroundRole: ClassVar[Qt.ItemDataRole] = ...
    ForeignWindow: ClassVar[Qt.WindowType] = ...
    ForwardButton: ClassVar[Qt.MouseButton] = ...
    FramelessWindowHint: ClassVar[Qt.WindowType] = ...
    Friday: ClassVar[Qt.DayOfWeek] = ...
    FuzzyHit: ClassVar[Qt.HitTestAccuracy] = ...
    GestureCanceled: ClassVar[Qt.GestureState] = ...
    GestureFinished: ClassVar[Qt.GestureState] = ...
    GestureStarted: ClassVar[Qt.GestureState] = ...
    GestureUpdated: ClassVar[Qt.GestureState] = ...
    GroupSwitchModifier: ClassVar[Qt.KeyboardModifier] = ...
    HighEventPriority: ClassVar[Qt.EventPriority] = ...
    HorPattern: ClassVar[Qt.BrushStyle] = ...
    Horizontal: ClassVar[Qt.Orientation] = ...
    IBeamCursor: ClassVar[Qt.CursorShape] = ...
    ISODate: ClassVar[Qt.DateFormat] = ...
    ISODateWithMs: ClassVar[Qt.DateFormat] = ...
    IgnoreAction: ClassVar[Qt.DropAction] = ...
    IgnoreAspectRatio: ClassVar[Qt.AspectRatioMode] = ...
    IgnoredGesturesPropagateToParent: ClassVar[Qt.GestureFlag] = ...
    ImAbsolutePosition: ClassVar[Qt.InputMethodQuery] = ...
    ImAnchorPosition: ClassVar[Qt.InputMethodQuery] = ...
    ImAnchorRectangle: ClassVar[Qt.InputMethodQuery] = ...
    ImCurrentSelection: ClassVar[Qt.InputMethodQuery] = ...
    ImCursorPosition: ClassVar[Qt.InputMethodQuery] = ...
    ImCursorRectangle: ClassVar[Qt.InputMethodQuery] = ...
    ImEnabled: ClassVar[Qt.InputMethodQuery] = ...
    ImEnterKeyType: ClassVar[Qt.InputMethodQuery] = ...
    ImFont: ClassVar[Qt.InputMethodQuery] = ...
    ImHints: ClassVar[Qt.InputMethodQuery] = ...
    ImInputItemClipRectangle: ClassVar[Qt.InputMethodQuery] = ...
    ImMaximumTextLength: ClassVar[Qt.InputMethodQuery] = ...
    ImMicroFocus: ClassVar[Qt.InputMethodQuery] = ...
    ImPlatformData: ClassVar[Qt.InputMethodQuery] = ...
    ImPreferredLanguage: ClassVar[Qt.InputMethodQuery] = ...
    ImQueryAll: ClassVar[Qt.InputMethodQuery] = ...
    ImQueryInput: ClassVar[Qt.InputMethodQuery] = ...
    ImSurroundingText: ClassVar[Qt.InputMethodQuery] = ...
    ImTextAfterCursor: ClassVar[Qt.InputMethodQuery] = ...
    ImTextBeforeCursor: ClassVar[Qt.InputMethodQuery] = ...
    ImhDate: ClassVar[Qt.InputMethodHint] = ...
    ImhDialableCharactersOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhDigitsOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhEmailCharactersOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhExclusiveInputMask: ClassVar[Qt.InputMethodHint] = ...
    ImhFormattedNumbersOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhHiddenText: ClassVar[Qt.InputMethodHint] = ...
    ImhLatinOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhLowercaseOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhMultiLine: ClassVar[Qt.InputMethodHint] = ...
    ImhNoAutoUppercase: ClassVar[Qt.InputMethodHint] = ...
    ImhNoEditMenu: ClassVar[Qt.InputMethodHint] = ...
    ImhNoPredictiveText: ClassVar[Qt.InputMethodHint] = ...
    ImhNoTextHandles: ClassVar[Qt.InputMethodHint] = ...
    ImhNone: ClassVar[Qt.InputMethodHint] = ...
    ImhPreferLatin: ClassVar[Qt.InputMethodHint] = ...
    ImhPreferLowercase: ClassVar[Qt.InputMethodHint] = ...
    ImhPreferNumbers: ClassVar[Qt.InputMethodHint] = ...
    ImhPreferUppercase: ClassVar[Qt.InputMethodHint] = ...
    ImhSensitiveData: ClassVar[Qt.InputMethodHint] = ...
    ImhTime: ClassVar[Qt.InputMethodHint] = ...
    ImhUppercaseOnly: ClassVar[Qt.InputMethodHint] = ...
    ImhUrlCharactersOnly: ClassVar[Qt.InputMethodHint] = ...
    InitialSortOrderRole: ClassVar[Qt.ItemDataRole] = ...
    IntersectClip: ClassVar[Qt.ClipOperation] = ...
    IntersectsItemBoundingRect: ClassVar[Qt.ItemSelectionMode] = ...
    IntersectsItemShape: ClassVar[Qt.ItemSelectionMode] = ...
    InvertedLandscapeOrientation: ClassVar[Qt.ScreenOrientation] = ...
    InvertedPortraitOrientation: ClassVar[Qt.ScreenOrientation] = ...
    ItemIsAutoTristate: ClassVar[Qt.ItemFlag] = ...
    ItemIsDragEnabled: ClassVar[Qt.ItemFlag] = ...
    ItemIsDropEnabled: ClassVar[Qt.ItemFlag] = ...
    ItemIsEditable: ClassVar[Qt.ItemFlag] = ...
    ItemIsEnabled: ClassVar[Qt.ItemFlag] = ...
    ItemIsSelectable: ClassVar[Qt.ItemFlag] = ...
    ItemIsTristate: ClassVar[Qt.ItemFlag] = ...
    ItemIsUserCheckable: ClassVar[Qt.ItemFlag] = ...
    ItemIsUserTristate: ClassVar[Qt.ItemFlag] = ...
    ItemNeverHasChildren: ClassVar[Qt.ItemFlag] = ...
    KeepAspectRatio: ClassVar[Qt.AspectRatioMode] = ...
    KeepAspectRatioByExpanding: ClassVar[Qt.AspectRatioMode] = ...
    KeepEmptyParts: ClassVar[Qt.SplitBehaviorFlags] = ...
    Key_0: ClassVar[Qt.Key] = ...
    Key_1: ClassVar[Qt.Key] = ...
    Key_2: ClassVar[Qt.Key] = ...
    Key_3: ClassVar[Qt.Key] = ...
    Key_4: ClassVar[Qt.Key] = ...
    Key_5: ClassVar[Qt.Key] = ...
    Key_6: ClassVar[Qt.Key] = ...
    Key_7: ClassVar[Qt.Key] = ...
    Key_8: ClassVar[Qt.Key] = ...
    Key_9: ClassVar[Qt.Key] = ...
    Key_A: ClassVar[Qt.Key] = ...
    Key_AE: ClassVar[Qt.Key] = ...
    Key_Aacute: ClassVar[Qt.Key] = ...
    Key_Acircumflex: ClassVar[Qt.Key] = ...
    Key_AddFavorite: ClassVar[Qt.Key] = ...
    Key_Adiaeresis: ClassVar[Qt.Key] = ...
    Key_Agrave: ClassVar[Qt.Key] = ...
    Key_Alt: ClassVar[Qt.Key] = ...
    Key_AltGr: ClassVar[Qt.Key] = ...
    Key_Ampersand: ClassVar[Qt.Key] = ...
    Key_Any: ClassVar[Qt.Key] = ...
    Key_Apostrophe: ClassVar[Qt.Key] = ...
    Key_ApplicationLeft: ClassVar[Qt.Key] = ...
    Key_ApplicationRight: ClassVar[Qt.Key] = ...
    Key_Aring: ClassVar[Qt.Key] = ...
    Key_AsciiCircum: ClassVar[Qt.Key] = ...
    Key_AsciiTilde: ClassVar[Qt.Key] = ...
    Key_Asterisk: ClassVar[Qt.Key] = ...
    Key_At: ClassVar[Qt.Key] = ...
    Key_Atilde: ClassVar[Qt.Key] = ...
    Key_AudioCycleTrack: ClassVar[Qt.Key] = ...
    Key_AudioForward: ClassVar[Qt.Key] = ...
    Key_AudioRandomPlay: ClassVar[Qt.Key] = ...
    Key_AudioRepeat: ClassVar[Qt.Key] = ...
    Key_AudioRewind: ClassVar[Qt.Key] = ...
    Key_Away: ClassVar[Qt.Key] = ...
    Key_B: ClassVar[Qt.Key] = ...
    Key_Back: ClassVar[Qt.Key] = ...
    Key_BackForward: ClassVar[Qt.Key] = ...
    Key_Backslash: ClassVar[Qt.Key] = ...
    Key_Backspace: ClassVar[Qt.Key] = ...
    Key_Backtab: ClassVar[Qt.Key] = ...
    Key_Bar: ClassVar[Qt.Key] = ...
    Key_BassBoost: ClassVar[Qt.Key] = ...
    Key_BassDown: ClassVar[Qt.Key] = ...
    Key_BassUp: ClassVar[Qt.Key] = ...
    Key_Battery: ClassVar[Qt.Key] = ...
    Key_Blue: ClassVar[Qt.Key] = ...
    Key_Bluetooth: ClassVar[Qt.Key] = ...
    Key_Book: ClassVar[Qt.Key] = ...
    Key_BraceLeft: ClassVar[Qt.Key] = ...
    Key_BraceRight: ClassVar[Qt.Key] = ...
    Key_BracketLeft: ClassVar[Qt.Key] = ...
    Key_BracketRight: ClassVar[Qt.Key] = ...
    Key_BrightnessAdjust: ClassVar[Qt.Key] = ...
    Key_C: ClassVar[Qt.Key] = ...
    Key_CD: ClassVar[Qt.Key] = ...
    Key_Calculator: ClassVar[Qt.Key] = ...
    Key_Calendar: ClassVar[Qt.Key] = ...
    Key_Call: ClassVar[Qt.Key] = ...
    Key_Camera: ClassVar[Qt.Key] = ...
    Key_CameraFocus: ClassVar[Qt.Key] = ...
    Key_Cancel: ClassVar[Qt.Key] = ...
    Key_CapsLock: ClassVar[Qt.Key] = ...
    Key_Ccedilla: ClassVar[Qt.Key] = ...
    Key_ChannelDown: ClassVar[Qt.Key] = ...
    Key_ChannelUp: ClassVar[Qt.Key] = ...
    Key_Clear: ClassVar[Qt.Key] = ...
    Key_ClearGrab: ClassVar[Qt.Key] = ...
    Key_Close: ClassVar[Qt.Key] = ...
    Key_Codeinput: ClassVar[Qt.Key] = ...
    Key_Colon: ClassVar[Qt.Key] = ...
    Key_Comma: ClassVar[Qt.Key] = ...
    Key_Community: ClassVar[Qt.Key] = ...
    Key_Context1: ClassVar[Qt.Key] = ...
    Key_Context2: ClassVar[Qt.Key] = ...
    Key_Context3: ClassVar[Qt.Key] = ...
    Key_Context4: ClassVar[Qt.Key] = ...
    Key_ContrastAdjust: ClassVar[Qt.Key] = ...
    Key_Control: ClassVar[Qt.Key] = ...
    Key_Copy: ClassVar[Qt.Key] = ...
    Key_Cut: ClassVar[Qt.Key] = ...
    Key_D: ClassVar[Qt.Key] = ...
    Key_DOS: ClassVar[Qt.Key] = ...
    Key_Dead_A: ClassVar[Qt.Key] = ...
    Key_Dead_Abovecomma: ClassVar[Qt.Key] = ...
    Key_Dead_Abovedot: ClassVar[Qt.Key] = ...
    Key_Dead_Abovereversedcomma: ClassVar[Qt.Key] = ...
    Key_Dead_Abovering: ClassVar[Qt.Key] = ...
    Key_Dead_Aboveverticalline: ClassVar[Qt.Key] = ...
    Key_Dead_Acute: ClassVar[Qt.Key] = ...
    Key_Dead_Belowbreve: ClassVar[Qt.Key] = ...
    Key_Dead_Belowcircumflex: ClassVar[Qt.Key] = ...
    Key_Dead_Belowcomma: ClassVar[Qt.Key] = ...
    Key_Dead_Belowdiaeresis: ClassVar[Qt.Key] = ...
    Key_Dead_Belowdot: ClassVar[Qt.Key] = ...
    Key_Dead_Belowmacron: ClassVar[Qt.Key] = ...
    Key_Dead_Belowring: ClassVar[Qt.Key] = ...
    Key_Dead_Belowtilde: ClassVar[Qt.Key] = ...
    Key_Dead_Belowverticalline: ClassVar[Qt.Key] = ...
    Key_Dead_Breve: ClassVar[Qt.Key] = ...
    Key_Dead_Capital_Schwa: ClassVar[Qt.Key] = ...
    Key_Dead_Caron: ClassVar[Qt.Key] = ...
    Key_Dead_Cedilla: ClassVar[Qt.Key] = ...
    Key_Dead_Circumflex: ClassVar[Qt.Key] = ...
    Key_Dead_Currency: ClassVar[Qt.Key] = ...
    Key_Dead_Diaeresis: ClassVar[Qt.Key] = ...
    Key_Dead_Doubleacute: ClassVar[Qt.Key] = ...
    Key_Dead_Doublegrave: ClassVar[Qt.Key] = ...
    Key_Dead_E: ClassVar[Qt.Key] = ...
    Key_Dead_Grave: ClassVar[Qt.Key] = ...
    Key_Dead_Greek: ClassVar[Qt.Key] = ...
    Key_Dead_Hook: ClassVar[Qt.Key] = ...
    Key_Dead_Horn: ClassVar[Qt.Key] = ...
    Key_Dead_I: ClassVar[Qt.Key] = ...
    Key_Dead_Invertedbreve: ClassVar[Qt.Key] = ...
    Key_Dead_Iota: ClassVar[Qt.Key] = ...
    Key_Dead_Longsolidusoverlay: ClassVar[Qt.Key] = ...
    Key_Dead_Lowline: ClassVar[Qt.Key] = ...
    Key_Dead_Macron: ClassVar[Qt.Key] = ...
    Key_Dead_O: ClassVar[Qt.Key] = ...
    Key_Dead_Ogonek: ClassVar[Qt.Key] = ...
    Key_Dead_Semivoiced_Sound: ClassVar[Qt.Key] = ...
    Key_Dead_Small_Schwa: ClassVar[Qt.Key] = ...
    Key_Dead_Stroke: ClassVar[Qt.Key] = ...
    Key_Dead_Tilde: ClassVar[Qt.Key] = ...
    Key_Dead_U: ClassVar[Qt.Key] = ...
    Key_Dead_Voiced_Sound: ClassVar[Qt.Key] = ...
    Key_Dead_a: ClassVar[Qt.Key] = ...
    Key_Dead_e: ClassVar[Qt.Key] = ...
    Key_Dead_i: ClassVar[Qt.Key] = ...
    Key_Dead_o: ClassVar[Qt.Key] = ...
    Key_Dead_u: ClassVar[Qt.Key] = ...
    Key_Delete: ClassVar[Qt.Key] = ...
    Key_Direction_L: ClassVar[Qt.Key] = ...
    Key_Direction_R: ClassVar[Qt.Key] = ...
    Key_Display: ClassVar[Qt.Key] = ...
    Key_Documents: ClassVar[Qt.Key] = ...
    Key_Dollar: ClassVar[Qt.Key] = ...
    Key_Down: ClassVar[Qt.Key] = ...
    Key_E: ClassVar[Qt.Key] = ...
    Key_ETH: ClassVar[Qt.Key] = ...
    Key_Eacute: ClassVar[Qt.Key] = ...
    Key_Ecircumflex: ClassVar[Qt.Key] = ...
    Key_Ediaeresis: ClassVar[Qt.Key] = ...
    Key_Egrave: ClassVar[Qt.Key] = ...
    Key_Eisu_Shift: ClassVar[Qt.Key] = ...
    Key_Eisu_toggle: ClassVar[Qt.Key] = ...
    Key_Eject: ClassVar[Qt.Key] = ...
    Key_End: ClassVar[Qt.Key] = ...
    Key_Enter: ClassVar[Qt.Key] = ...
    Key_Equal: ClassVar[Qt.Key] = ...
    Key_Escape: ClassVar[Qt.Key] = ...
    Key_Excel: ClassVar[Qt.Key] = ...
    Key_Exclam: ClassVar[Qt.Key] = ...
    Key_Execute: ClassVar[Qt.Key] = ...
    Key_Exit: ClassVar[Qt.Key] = ...
    Key_Explorer: ClassVar[Qt.Key] = ...
    Key_F: ClassVar[Qt.Key] = ...
    Key_F1: ClassVar[Qt.Key] = ...
    Key_F10: ClassVar[Qt.Key] = ...
    Key_F11: ClassVar[Qt.Key] = ...
    Key_F12: ClassVar[Qt.Key] = ...
    Key_F13: ClassVar[Qt.Key] = ...
    Key_F14: ClassVar[Qt.Key] = ...
    Key_F15: ClassVar[Qt.Key] = ...
    Key_F16: ClassVar[Qt.Key] = ...
    Key_F17: ClassVar[Qt.Key] = ...
    Key_F18: ClassVar[Qt.Key] = ...
    Key_F19: ClassVar[Qt.Key] = ...
    Key_F2: ClassVar[Qt.Key] = ...
    Key_F20: ClassVar[Qt.Key] = ...
    Key_F21: ClassVar[Qt.Key] = ...
    Key_F22: ClassVar[Qt.Key] = ...
    Key_F23: ClassVar[Qt.Key] = ...
    Key_F24: ClassVar[Qt.Key] = ...
    Key_F25: ClassVar[Qt.Key] = ...
    Key_F26: ClassVar[Qt.Key] = ...
    Key_F27: ClassVar[Qt.Key] = ...
    Key_F28: ClassVar[Qt.Key] = ...
    Key_F29: ClassVar[Qt.Key] = ...
    Key_F3: ClassVar[Qt.Key] = ...
    Key_F30: ClassVar[Qt.Key] = ...
    Key_F31: ClassVar[Qt.Key] = ...
    Key_F32: ClassVar[Qt.Key] = ...
    Key_F33: ClassVar[Qt.Key] = ...
    Key_F34: ClassVar[Qt.Key] = ...
    Key_F35: ClassVar[Qt.Key] = ...
    Key_F4: ClassVar[Qt.Key] = ...
    Key_F5: ClassVar[Qt.Key] = ...
    Key_F6: ClassVar[Qt.Key] = ...
    Key_F7: ClassVar[Qt.Key] = ...
    Key_F8: ClassVar[Qt.Key] = ...
    Key_F9: ClassVar[Qt.Key] = ...
    Key_Favorites: ClassVar[Qt.Key] = ...
    Key_Finance: ClassVar[Qt.Key] = ...
    Key_Find: ClassVar[Qt.Key] = ...
    Key_Flip: ClassVar[Qt.Key] = ...
    Key_Forward: ClassVar[Qt.Key] = ...
    Key_G: ClassVar[Qt.Key] = ...
    Key_Game: ClassVar[Qt.Key] = ...
    Key_Go: ClassVar[Qt.Key] = ...
    Key_Greater: ClassVar[Qt.Key] = ...
    Key_Green: ClassVar[Qt.Key] = ...
    Key_Guide: ClassVar[Qt.Key] = ...
    Key_H: ClassVar[Qt.Key] = ...
    Key_Hangul: ClassVar[Qt.Key] = ...
    Key_Hangul_Banja: ClassVar[Qt.Key] = ...
    Key_Hangul_End: ClassVar[Qt.Key] = ...
    Key_Hangul_Hanja: ClassVar[Qt.Key] = ...
    Key_Hangul_Jamo: ClassVar[Qt.Key] = ...
    Key_Hangul_Jeonja: ClassVar[Qt.Key] = ...
    Key_Hangul_PostHanja: ClassVar[Qt.Key] = ...
    Key_Hangul_PreHanja: ClassVar[Qt.Key] = ...
    Key_Hangul_Romaja: ClassVar[Qt.Key] = ...
    Key_Hangul_Special: ClassVar[Qt.Key] = ...
    Key_Hangul_Start: ClassVar[Qt.Key] = ...
    Key_Hangup: ClassVar[Qt.Key] = ...
    Key_Hankaku: ClassVar[Qt.Key] = ...
    Key_Help: ClassVar[Qt.Key] = ...
    Key_Henkan: ClassVar[Qt.Key] = ...
    Key_Hibernate: ClassVar[Qt.Key] = ...
    Key_Hiragana: ClassVar[Qt.Key] = ...
    Key_Hiragana_Katakana: ClassVar[Qt.Key] = ...
    Key_History: ClassVar[Qt.Key] = ...
    Key_Home: ClassVar[Qt.Key] = ...
    Key_HomePage: ClassVar[Qt.Key] = ...
    Key_HotLinks: ClassVar[Qt.Key] = ...
    Key_Hyper_L: ClassVar[Qt.Key] = ...
    Key_Hyper_R: ClassVar[Qt.Key] = ...
    Key_I: ClassVar[Qt.Key] = ...
    Key_Iacute: ClassVar[Qt.Key] = ...
    Key_Icircumflex: ClassVar[Qt.Key] = ...
    Key_Idiaeresis: ClassVar[Qt.Key] = ...
    Key_Igrave: ClassVar[Qt.Key] = ...
    Key_Info: ClassVar[Qt.Key] = ...
    Key_Insert: ClassVar[Qt.Key] = ...
    Key_J: ClassVar[Qt.Key] = ...
    Key_K: ClassVar[Qt.Key] = ...
    Key_Kana_Lock: ClassVar[Qt.Key] = ...
    Key_Kana_Shift: ClassVar[Qt.Key] = ...
    Key_Kanji: ClassVar[Qt.Key] = ...
    Key_Katakana: ClassVar[Qt.Key] = ...
    Key_KeyboardBrightnessDown: ClassVar[Qt.Key] = ...
    Key_KeyboardBrightnessUp: ClassVar[Qt.Key] = ...
    Key_KeyboardLightOnOff: ClassVar[Qt.Key] = ...
    Key_L: ClassVar[Qt.Key] = ...
    Key_LastNumberRedial: ClassVar[Qt.Key] = ...
    Key_Launch0: ClassVar[Qt.Key] = ...
    Key_Launch1: ClassVar[Qt.Key] = ...
    Key_Launch2: ClassVar[Qt.Key] = ...
    Key_Launch3: ClassVar[Qt.Key] = ...
    Key_Launch4: ClassVar[Qt.Key] = ...
    Key_Launch5: ClassVar[Qt.Key] = ...
    Key_Launch6: ClassVar[Qt.Key] = ...
    Key_Launch7: ClassVar[Qt.Key] = ...
    Key_Launch8: ClassVar[Qt.Key] = ...
    Key_Launch9: ClassVar[Qt.Key] = ...
    Key_LaunchA: ClassVar[Qt.Key] = ...
    Key_LaunchB: ClassVar[Qt.Key] = ...
    Key_LaunchC: ClassVar[Qt.Key] = ...
    Key_LaunchD: ClassVar[Qt.Key] = ...
    Key_LaunchE: ClassVar[Qt.Key] = ...
    Key_LaunchF: ClassVar[Qt.Key] = ...
    Key_LaunchG: ClassVar[Qt.Key] = ...
    Key_LaunchH: ClassVar[Qt.Key] = ...
    Key_LaunchMail: ClassVar[Qt.Key] = ...
    Key_LaunchMedia: ClassVar[Qt.Key] = ...
    Key_Left: ClassVar[Qt.Key] = ...
    Key_Less: ClassVar[Qt.Key] = ...
    Key_LightBulb: ClassVar[Qt.Key] = ...
    Key_LogOff: ClassVar[Qt.Key] = ...
    Key_M: ClassVar[Qt.Key] = ...
    Key_MailForward: ClassVar[Qt.Key] = ...
    Key_Market: ClassVar[Qt.Key] = ...
    Key_Massyo: ClassVar[Qt.Key] = ...
    Key_MediaLast: ClassVar[Qt.Key] = ...
    Key_MediaNext: ClassVar[Qt.Key] = ...
    Key_MediaPause: ClassVar[Qt.Key] = ...
    Key_MediaPlay: ClassVar[Qt.Key] = ...
    Key_MediaPrevious: ClassVar[Qt.Key] = ...
    Key_MediaRecord: ClassVar[Qt.Key] = ...
    Key_MediaStop: ClassVar[Qt.Key] = ...
    Key_MediaTogglePlayPause: ClassVar[Qt.Key] = ...
    Key_Meeting: ClassVar[Qt.Key] = ...
    Key_Memo: ClassVar[Qt.Key] = ...
    Key_Menu: ClassVar[Qt.Key] = ...
    Key_MenuKB: ClassVar[Qt.Key] = ...
    Key_MenuPB: ClassVar[Qt.Key] = ...
    Key_Messenger: ClassVar[Qt.Key] = ...
    Key_Meta: ClassVar[Qt.Key] = ...
    Key_MicMute: ClassVar[Qt.Key] = ...
    Key_MicVolumeDown: ClassVar[Qt.Key] = ...
    Key_MicVolumeUp: ClassVar[Qt.Key] = ...
    Key_Minus: ClassVar[Qt.Key] = ...
    Key_Mode_switch: ClassVar[Qt.Key] = ...
    Key_MonBrightnessDown: ClassVar[Qt.Key] = ...
    Key_MonBrightnessUp: ClassVar[Qt.Key] = ...
    Key_Muhenkan: ClassVar[Qt.Key] = ...
    Key_Multi_key: ClassVar[Qt.Key] = ...
    Key_MultipleCandidate: ClassVar[Qt.Key] = ...
    Key_Music: ClassVar[Qt.Key] = ...
    Key_MySites: ClassVar[Qt.Key] = ...
    Key_N: ClassVar[Qt.Key] = ...
    Key_New: ClassVar[Qt.Key] = ...
    Key_News: ClassVar[Qt.Key] = ...
    Key_No: ClassVar[Qt.Key] = ...
    Key_Ntilde: ClassVar[Qt.Key] = ...
    Key_NumLock: ClassVar[Qt.Key] = ...
    Key_NumberSign: ClassVar[Qt.Key] = ...
    Key_O: ClassVar[Qt.Key] = ...
    Key_Oacute: ClassVar[Qt.Key] = ...
    Key_Ocircumflex: ClassVar[Qt.Key] = ...
    Key_Odiaeresis: ClassVar[Qt.Key] = ...
    Key_OfficeHome: ClassVar[Qt.Key] = ...
    Key_Ograve: ClassVar[Qt.Key] = ...
    Key_Ooblique: ClassVar[Qt.Key] = ...
    Key_Open: ClassVar[Qt.Key] = ...
    Key_OpenUrl: ClassVar[Qt.Key] = ...
    Key_Option: ClassVar[Qt.Key] = ...
    Key_Otilde: ClassVar[Qt.Key] = ...
    Key_P: ClassVar[Qt.Key] = ...
    Key_PageDown: ClassVar[Qt.Key] = ...
    Key_PageUp: ClassVar[Qt.Key] = ...
    Key_ParenLeft: ClassVar[Qt.Key] = ...
    Key_ParenRight: ClassVar[Qt.Key] = ...
    Key_Paste: ClassVar[Qt.Key] = ...
    Key_Pause: ClassVar[Qt.Key] = ...
    Key_Percent: ClassVar[Qt.Key] = ...
    Key_Period: ClassVar[Qt.Key] = ...
    Key_Phone: ClassVar[Qt.Key] = ...
    Key_Pictures: ClassVar[Qt.Key] = ...
    Key_Play: ClassVar[Qt.Key] = ...
    Key_Plus: ClassVar[Qt.Key] = ...
    Key_PowerDown: ClassVar[Qt.Key] = ...
    Key_PowerOff: ClassVar[Qt.Key] = ...
    Key_PreviousCandidate: ClassVar[Qt.Key] = ...
    Key_Print: ClassVar[Qt.Key] = ...
    Key_Printer: ClassVar[Qt.Key] = ...
    Key_Q: ClassVar[Qt.Key] = ...
    Key_Question: ClassVar[Qt.Key] = ...
    Key_QuoteDbl: ClassVar[Qt.Key] = ...
    Key_QuoteLeft: ClassVar[Qt.Key] = ...
    Key_R: ClassVar[Qt.Key] = ...
    Key_Red: ClassVar[Qt.Key] = ...
    Key_Redo: ClassVar[Qt.Key] = ...
    Key_Refresh: ClassVar[Qt.Key] = ...
    Key_Reload: ClassVar[Qt.Key] = ...
    Key_Reply: ClassVar[Qt.Key] = ...
    Key_Return: ClassVar[Qt.Key] = ...
    Key_Right: ClassVar[Qt.Key] = ...
    Key_Romaji: ClassVar[Qt.Key] = ...
    Key_RotateWindows: ClassVar[Qt.Key] = ...
    Key_RotationKB: ClassVar[Qt.Key] = ...
    Key_RotationPB: ClassVar[Qt.Key] = ...
    Key_S: ClassVar[Qt.Key] = ...
    Key_Save: ClassVar[Qt.Key] = ...
    Key_ScreenSaver: ClassVar[Qt.Key] = ...
    Key_ScrollLock: ClassVar[Qt.Key] = ...
    Key_Search: ClassVar[Qt.Key] = ...
    Key_Select: ClassVar[Qt.Key] = ...
    Key_Semicolon: ClassVar[Qt.Key] = ...
    Key_Send: ClassVar[Qt.Key] = ...
    Key_Settings: ClassVar[Qt.Key] = ...
    Key_Shift: ClassVar[Qt.Key] = ...
    Key_Shop: ClassVar[Qt.Key] = ...
    Key_SingleCandidate: ClassVar[Qt.Key] = ...
    Key_Slash: ClassVar[Qt.Key] = ...
    Key_Sleep: ClassVar[Qt.Key] = ...
    Key_Space: ClassVar[Qt.Key] = ...
    Key_Spell: ClassVar[Qt.Key] = ...
    Key_SplitScreen: ClassVar[Qt.Key] = ...
    Key_Standby: ClassVar[Qt.Key] = ...
    Key_Stop: ClassVar[Qt.Key] = ...
    Key_Subtitle: ClassVar[Qt.Key] = ...
    Key_Super_L: ClassVar[Qt.Key] = ...
    Key_Super_R: ClassVar[Qt.Key] = ...
    Key_Support: ClassVar[Qt.Key] = ...
    Key_Suspend: ClassVar[Qt.Key] = ...
    Key_SysReq: ClassVar[Qt.Key] = ...
    Key_T: ClassVar[Qt.Key] = ...
    Key_THORN: ClassVar[Qt.Key] = ...
    Key_Tab: ClassVar[Qt.Key] = ...
    Key_TaskPane: ClassVar[Qt.Key] = ...
    Key_Terminal: ClassVar[Qt.Key] = ...
    Key_Time: ClassVar[Qt.Key] = ...
    Key_ToDoList: ClassVar[Qt.Key] = ...
    Key_ToggleCallHangup: ClassVar[Qt.Key] = ...
    Key_Tools: ClassVar[Qt.Key] = ...
    Key_TopMenu: ClassVar[Qt.Key] = ...
    Key_TouchpadOff: ClassVar[Qt.Key] = ...
    Key_TouchpadOn: ClassVar[Qt.Key] = ...
    Key_TouchpadToggle: ClassVar[Qt.Key] = ...
    Key_Touroku: ClassVar[Qt.Key] = ...
    Key_Travel: ClassVar[Qt.Key] = ...
    Key_TrebleDown: ClassVar[Qt.Key] = ...
    Key_TrebleUp: ClassVar[Qt.Key] = ...
    Key_U: ClassVar[Qt.Key] = ...
    Key_UWB: ClassVar[Qt.Key] = ...
    Key_Uacute: ClassVar[Qt.Key] = ...
    Key_Ucircumflex: ClassVar[Qt.Key] = ...
    Key_Udiaeresis: ClassVar[Qt.Key] = ...
    Key_Ugrave: ClassVar[Qt.Key] = ...
    Key_Underscore: ClassVar[Qt.Key] = ...
    Key_Undo: ClassVar[Qt.Key] = ...
    Key_Up: ClassVar[Qt.Key] = ...
    Key_V: ClassVar[Qt.Key] = ...
    Key_Video: ClassVar[Qt.Key] = ...
    Key_View: ClassVar[Qt.Key] = ...
    Key_VoiceDial: ClassVar[Qt.Key] = ...
    Key_VolumeDown: ClassVar[Qt.Key] = ...
    Key_VolumeMute: ClassVar[Qt.Key] = ...
    Key_VolumeUp: ClassVar[Qt.Key] = ...
    Key_W: ClassVar[Qt.Key] = ...
    Key_WLAN: ClassVar[Qt.Key] = ...
    Key_WWW: ClassVar[Qt.Key] = ...
    Key_WakeUp: ClassVar[Qt.Key] = ...
    Key_WebCam: ClassVar[Qt.Key] = ...
    Key_Word: ClassVar[Qt.Key] = ...
    Key_X: ClassVar[Qt.Key] = ...
    Key_Xfer: ClassVar[Qt.Key] = ...
    Key_Y: ClassVar[Qt.Key] = ...
    Key_Yacute: ClassVar[Qt.Key] = ...
    Key_Yellow: ClassVar[Qt.Key] = ...
    Key_Yes: ClassVar[Qt.Key] = ...
    Key_Z: ClassVar[Qt.Key] = ...
    Key_Zenkaku: ClassVar[Qt.Key] = ...
    Key_Zenkaku_Hankaku: ClassVar[Qt.Key] = ...
    Key_Zoom: ClassVar[Qt.Key] = ...
    Key_ZoomIn: ClassVar[Qt.Key] = ...
    Key_ZoomOut: ClassVar[Qt.Key] = ...
    Key_acute: ClassVar[Qt.Key] = ...
    Key_brokenbar: ClassVar[Qt.Key] = ...
    Key_cedilla: ClassVar[Qt.Key] = ...
    Key_cent: ClassVar[Qt.Key] = ...
    Key_copyright: ClassVar[Qt.Key] = ...
    Key_currency: ClassVar[Qt.Key] = ...
    Key_degree: ClassVar[Qt.Key] = ...
    Key_diaeresis: ClassVar[Qt.Key] = ...
    Key_division: ClassVar[Qt.Key] = ...
    Key_exclamdown: ClassVar[Qt.Key] = ...
    Key_guillemotleft: ClassVar[Qt.Key] = ...
    Key_guillemotright: ClassVar[Qt.Key] = ...
    Key_hyphen: ClassVar[Qt.Key] = ...
    Key_iTouch: ClassVar[Qt.Key] = ...
    Key_macron: ClassVar[Qt.Key] = ...
    Key_masculine: ClassVar[Qt.Key] = ...
    Key_mu: ClassVar[Qt.Key] = ...
    Key_multiply: ClassVar[Qt.Key] = ...
    Key_nobreakspace: ClassVar[Qt.Key] = ...
    Key_notsign: ClassVar[Qt.Key] = ...
    Key_onehalf: ClassVar[Qt.Key] = ...
    Key_onequarter: ClassVar[Qt.Key] = ...
    Key_onesuperior: ClassVar[Qt.Key] = ...
    Key_ordfeminine: ClassVar[Qt.Key] = ...
    Key_paragraph: ClassVar[Qt.Key] = ...
    Key_periodcentered: ClassVar[Qt.Key] = ...
    Key_plusminus: ClassVar[Qt.Key] = ...
    Key_questiondown: ClassVar[Qt.Key] = ...
    Key_registered: ClassVar[Qt.Key] = ...
    Key_section: ClassVar[Qt.Key] = ...
    Key_ssharp: ClassVar[Qt.Key] = ...
    Key_sterling: ClassVar[Qt.Key] = ...
    Key_threequarters: ClassVar[Qt.Key] = ...
    Key_threesuperior: ClassVar[Qt.Key] = ...
    Key_twosuperior: ClassVar[Qt.Key] = ...
    Key_unknown: ClassVar[Qt.Key] = ...
    Key_ydiaeresis: ClassVar[Qt.Key] = ...
    Key_yen: ClassVar[Qt.Key] = ...
    KeyboardModifierMask: ClassVar[Qt.KeyboardModifier] = ...
    KeypadModifier: ClassVar[Qt.KeyboardModifier] = ...
    LandscapeOrientation: ClassVar[Qt.ScreenOrientation] = ...
    LastCursor: ClassVar[Qt.CursorShape] = ...
    LastGestureType: ClassVar[Qt.GestureType] = ...
    LayoutDirectionAuto: ClassVar[Qt.LayoutDirection] = ...
    LeftArrow: ClassVar[Qt.ArrowType] = ...
    LeftButton: ClassVar[Qt.MouseButton] = ...
    LeftDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
    LeftEdge: ClassVar[Qt.Edge] = ...
    LeftSection: ClassVar[Qt.WindowFrameSection] = ...
    LeftToRight: ClassVar[Qt.LayoutDirection] = ...
    LeftToolBarArea: ClassVar[Qt.ToolBarArea] = ...
    LinearGradientPattern: ClassVar[Qt.BrushStyle] = ...
    LinkAction: ClassVar[Qt.DropAction] = ...
    LinksAccessibleByKeyboard: ClassVar[Qt.TextInteractionFlag] = ...
    LinksAccessibleByMouse: ClassVar[Qt.TextInteractionFlag] = ...
    LocalDate: ClassVar[Qt.DateFormat] = ...
    LocalTime: ClassVar[Qt.TimeSpec] = ...
    LocaleDate: ClassVar[Qt.DateFormat] = ...
    LogicalCoordinates: ClassVar[Qt.CoordinateSystem] = ...
    LogicalMoveStyle: ClassVar[Qt.CursorMoveStyle] = ...
    LowEventPriority: ClassVar[Qt.EventPriority] = ...
    META: ClassVar[Qt.Modifier] = ...
    MODIFIER_MASK: ClassVar[Qt.Modifier] = ...
    MPenCapStyle: ClassVar[Qt.PenCapStyle] = ...
    MPenJoinStyle: ClassVar[Qt.PenJoinStyle] = ...
    MPenStyle: ClassVar[Qt.PenStyle] = ...
    MSWindowsFixedSizeDialogHint: ClassVar[Qt.WindowType] = ...
    MSWindowsOwnDC: ClassVar[Qt.WindowType] = ...
    MacWindowToolBarButtonHint: ClassVar[Qt.WindowType] = ...
    MarkdownText: ClassVar[Qt.TextFormat] = ...
    MaskInColor: ClassVar[Qt.MaskMode] = ...
    MaskOutColor: ClassVar[Qt.MaskMode] = ...
    MatchCaseSensitive: ClassVar[Qt.MatchFlag] = ...
    MatchContains: ClassVar[Qt.MatchFlag] = ...
    MatchEndsWith: ClassVar[Qt.MatchFlag] = ...
    MatchExactly: ClassVar[Qt.MatchFlag] = ...
    MatchFixedString: ClassVar[Qt.MatchFlag] = ...
    MatchRecursive: ClassVar[Qt.MatchFlag] = ...
    MatchRegExp: ClassVar[Qt.MatchFlag] = ...
    MatchRegularExpression: ClassVar[Qt.MatchFlag] = ...
    MatchStartsWith: ClassVar[Qt.MatchFlag] = ...
    MatchWildcard: ClassVar[Qt.MatchFlag] = ...
    MatchWrap: ClassVar[Qt.MatchFlag] = ...
    MaxMouseButton: ClassVar[Qt.MouseButton] = ...
    MaximizeUsingFullscreenGeometryHint: ClassVar[Qt.WindowType] = ...
    MaximumSize: ClassVar[Qt.SizeHint] = ...
    MenuBarFocusReason: ClassVar[Qt.FocusReason] = ...
    MetaModifier: ClassVar[Qt.KeyboardModifier] = ...
    MidButton: ClassVar[Qt.MouseButton] = ...
    MiddleButton: ClassVar[Qt.MouseButton] = ...
    MinimumDescent: ClassVar[Qt.SizeHint] = ...
    MinimumSize: ClassVar[Qt.SizeHint] = ...
    MiterJoin: ClassVar[Qt.PenJoinStyle] = ...
    Monday: ClassVar[Qt.DayOfWeek] = ...
    MonoOnly: ClassVar[Qt.ImageConversionFlag] = ...
    MouseButtonMask: ClassVar[Qt.MouseButton] = ...
    MouseEventCreatedDoubleClick: ClassVar[Qt.MouseEventFlag] = ...
    MouseEventFlagMask: ClassVar[Qt.MouseEventFlag] = ...
    MouseEventNotSynthesized: ClassVar[Qt.MouseEventSource] = ...
    MouseEventSynthesizedByApplication: ClassVar[Qt.MouseEventSource] = ...
    MouseEventSynthesizedByQt: ClassVar[Qt.MouseEventSource] = ...
    MouseEventSynthesizedBySystem: ClassVar[Qt.MouseEventSource] = ...
    MouseFocusReason: ClassVar[Qt.FocusReason] = ...
    MoveAction: ClassVar[Qt.DropAction] = ...
    NDockWidgetAreas: ClassVar[Qt.DockWidgetAreaSizes] = ...
    NSizeHints: ClassVar[Qt.SizeHint] = ...
    NToolBarAreas: ClassVar[Qt.ToolBarAreaSizes] = ...
    NavigationModeCursorAuto: ClassVar[Qt.NavigationMode] = ...
    NavigationModeCursorForceVisible: ClassVar[Qt.NavigationMode] = ...
    NavigationModeKeypadDirectional: ClassVar[Qt.NavigationMode] = ...
    NavigationModeKeypadTabOrder: ClassVar[Qt.NavigationMode] = ...
    NavigationModeNone: ClassVar[Qt.NavigationMode] = ...
    NoAlpha: ClassVar[Qt.ImageConversionFlag] = ...
    NoArrow: ClassVar[Qt.ArrowType] = ...
    NoBrush: ClassVar[Qt.BrushStyle] = ...
    NoButton: ClassVar[Qt.MouseButton] = ...
    NoClip: ClassVar[Qt.ClipOperation] = ...
    NoContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
    NoDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
    NoDropShadowWindowHint: ClassVar[Qt.WindowType] = ...
    NoFocus: ClassVar[Qt.FocusPolicy] = ...
    NoFocusReason: ClassVar[Qt.FocusReason] = ...
    NoFormatConversion: ClassVar[Qt.ImageConversionFlag] = ...
    NoGesture: ClassVar[Qt.GestureState] = ...
    NoItemFlags: ClassVar[Qt.ItemFlag] = ...
    NoModifier: ClassVar[Qt.KeyboardModifier] = ...
    NoOpaqueDetection: ClassVar[Qt.ImageConversionFlag] = ...
    NoPen: ClassVar[Qt.PenStyle] = ...
    NoScrollPhase: ClassVar[Qt.ScrollPhase] = ...
    NoSection: ClassVar[Qt.WindowFrameSection] = ...
    NoTabFocus: ClassVar[Qt.TabFocusBehavior] = ...
    NoTextInteraction: ClassVar[Qt.TextInteractionFlag] = ...
    NoToolBarArea: ClassVar[Qt.ToolBarArea] = ...
    NonModal: ClassVar[Qt.WindowModality] = ...
    NormalEventPriority: ClassVar[Qt.EventPriority] = ...
    OddEvenFill: ClassVar[Qt.FillRule] = ...
    OffsetFromUTC: ClassVar[Qt.TimeSpec] = ...
    OpaqueMode: ClassVar[Qt.BGMode] = ...
    OpenHandCursor: ClassVar[Qt.CursorShape] = ...
    OrderedAlphaDither: ClassVar[Qt.ImageConversionFlag] = ...
    OrderedDither: ClassVar[Qt.ImageConversionFlag] = ...
    OtherFocusReason: ClassVar[Qt.FocusReason] = ...
    PanGesture: ClassVar[Qt.GestureType] = ...
    PanNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    PartiallyChecked: ClassVar[Qt.CheckState] = ...
    PinchGesture: ClassVar[Qt.GestureType] = ...
    PlainText: ClassVar[Qt.TextFormat] = ...
    PointingHandCursor: ClassVar[Qt.CursorShape] = ...
    Popup: ClassVar[Qt.WindowType] = ...
    PopupFocusReason: ClassVar[Qt.FocusReason] = ...
    PortraitOrientation: ClassVar[Qt.ScreenOrientation] = ...
    PreciseTimer: ClassVar[Qt.TimerType] = ...
    PreferDither: ClassVar[Qt.ImageConversionFlag] = ...
    PreferredSize: ClassVar[Qt.SizeHint] = ...
    PreventContextMenu: ClassVar[Qt.ContextMenuPolicy] = ...
    PrimaryOrientation: ClassVar[Qt.ScreenOrientation] = ...
    QueuedConnection: ClassVar[Qt.ConnectionType] = ...
    RFC2822Date: ClassVar[Qt.DateFormat] = ...
    RadialGradientPattern: ClassVar[Qt.BrushStyle] = ...
    ReceivePartialGestures: ClassVar[Qt.GestureFlag] = ...
    RelativeSize: ClassVar[Qt.SizeMode] = ...
    RepeatTile: ClassVar[Qt.TileRule] = ...
    ReplaceClip: ClassVar[Qt.ClipOperation] = ...
    ReplaceSelection: ClassVar[Qt.ItemSelectionOperation] = ...
    RichText: ClassVar[Qt.TextFormat] = ...
    RightArrow: ClassVar[Qt.ArrowType] = ...
    RightButton: ClassVar[Qt.MouseButton] = ...
    RightDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
    RightEdge: ClassVar[Qt.Edge] = ...
    RightSection: ClassVar[Qt.WindowFrameSection] = ...
    RightToLeft: ClassVar[Qt.LayoutDirection] = ...
    RightToolBarArea: ClassVar[Qt.ToolBarArea] = ...
    RotateNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    RoundCap: ClassVar[Qt.PenCapStyle] = ...
    RoundJoin: ClassVar[Qt.PenJoinStyle] = ...
    RoundTile: ClassVar[Qt.TileRule] = ...
    SHIFT: ClassVar[Qt.Modifier] = ...
    Saturday: ClassVar[Qt.DayOfWeek] = ...
    ScrollBarAlwaysOff: ClassVar[Qt.ScrollBarPolicy] = ...
    ScrollBarAlwaysOn: ClassVar[Qt.ScrollBarPolicy] = ...
    ScrollBarAsNeeded: ClassVar[Qt.ScrollBarPolicy] = ...
    ScrollBegin: ClassVar[Qt.ScrollPhase] = ...
    ScrollEnd: ClassVar[Qt.ScrollPhase] = ...
    ScrollMomentum: ClassVar[Qt.ScrollPhase] = ...
    ScrollUpdate: ClassVar[Qt.ScrollPhase] = ...
    Sheet: ClassVar[Qt.WindowType] = ...
    ShiftModifier: ClassVar[Qt.KeyboardModifier] = ...
    ShortcutFocusReason: ClassVar[Qt.FocusReason] = ...
    SizeAllCursor: ClassVar[Qt.CursorShape] = ...
    SizeBDiagCursor: ClassVar[Qt.CursorShape] = ...
    SizeFDiagCursor: ClassVar[Qt.CursorShape] = ...
    SizeHintRole: ClassVar[Qt.ItemDataRole] = ...
    SizeHorCursor: ClassVar[Qt.CursorShape] = ...
    SizeVerCursor: ClassVar[Qt.CursorShape] = ...
    SkipEmptyParts: ClassVar[Qt.SplitBehaviorFlags] = ...
    SmartZoomNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    SmoothTransformation: ClassVar[Qt.TransformationMode] = ...
    SolidLine: ClassVar[Qt.PenStyle] = ...
    SolidPattern: ClassVar[Qt.BrushStyle] = ...
    SplashScreen: ClassVar[Qt.WindowType] = ...
    SplitHCursor: ClassVar[Qt.CursorShape] = ...
    SplitVCursor: ClassVar[Qt.CursorShape] = ...
    SquareCap: ClassVar[Qt.PenCapStyle] = ...
    StatusTipPropertyRole: ClassVar[Qt.ItemDataRole] = ...
    StatusTipRole: ClassVar[Qt.ItemDataRole] = ...
    StretchTile: ClassVar[Qt.TileRule] = ...
    StrongFocus: ClassVar[Qt.FocusPolicy] = ...
    SubWindow: ClassVar[Qt.WindowType] = ...
    Sunday: ClassVar[Qt.DayOfWeek] = ...
    SvgMiterJoin: ClassVar[Qt.PenJoinStyle] = ...
    SwipeGesture: ClassVar[Qt.GestureType] = ...
    SwipeNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    SystemLocaleDate: ClassVar[Qt.DateFormat] = ...
    SystemLocaleLongDate: ClassVar[Qt.DateFormat] = ...
    SystemLocaleShortDate: ClassVar[Qt.DateFormat] = ...
    TabFocus: ClassVar[Qt.FocusPolicy] = ...
    TabFocusAllControls: ClassVar[Qt.TabFocusBehavior] = ...
    TabFocusListControls: ClassVar[Qt.TabFocusBehavior] = ...
    TabFocusReason: ClassVar[Qt.FocusReason] = ...
    TabFocusTextControls: ClassVar[Qt.TabFocusBehavior] = ...
    TapAndHoldGesture: ClassVar[Qt.GestureType] = ...
    TapGesture: ClassVar[Qt.GestureType] = ...
    TargetMoveAction: ClassVar[Qt.DropAction] = ...
    TaskButton: ClassVar[Qt.MouseButton] = ...
    TextAlignmentRole: ClassVar[Qt.ItemDataRole] = ...
    TextBrowserInteraction: ClassVar[Qt.TextInteractionFlag] = ...
    TextBypassShaping: ClassVar[Qt.TextFlag] = ...
    TextColorRole: ClassVar[Qt.ItemDataRole] = ...
    TextDate: ClassVar[Qt.DateFormat] = ...
    TextDontClip: ClassVar[Qt.TextFlag] = ...
    TextDontPrint: ClassVar[Qt.TextFlag] = ...
    TextEditable: ClassVar[Qt.TextInteractionFlag] = ...
    TextEditorInteraction: ClassVar[Qt.TextInteractionFlag] = ...
    TextExpandTabs: ClassVar[Qt.TextFlag] = ...
    TextForceLeftToRight: ClassVar[Qt.TextFlag] = ...
    TextForceRightToLeft: ClassVar[Qt.TextFlag] = ...
    TextHideMnemonic: ClassVar[Qt.TextFlag] = ...
    TextIncludeTrailingSpaces: ClassVar[Qt.TextFlag] = ...
    TextJustificationForced: ClassVar[Qt.TextFlag] = ...
    TextLongestVariant: ClassVar[Qt.TextFlag] = ...
    TextSelectableByKeyboard: ClassVar[Qt.TextInteractionFlag] = ...
    TextSelectableByMouse: ClassVar[Qt.TextInteractionFlag] = ...
    TextShowMnemonic: ClassVar[Qt.TextFlag] = ...
    TextSingleLine: ClassVar[Qt.TextFlag] = ...
    TextWordWrap: ClassVar[Qt.TextFlag] = ...
    TextWrapAnywhere: ClassVar[Qt.TextFlag] = ...
    TexturePattern: ClassVar[Qt.BrushStyle] = ...
    ThresholdAlphaDither: ClassVar[Qt.ImageConversionFlag] = ...
    ThresholdDither: ClassVar[Qt.ImageConversionFlag] = ...
    Thursday: ClassVar[Qt.DayOfWeek] = ...
    TimeZone: ClassVar[Qt.TimeSpec] = ...
    TitleBarArea: ClassVar[Qt.WindowFrameSection] = ...
    Tool: ClassVar[Qt.WindowType] = ...
    ToolBarArea_Mask: ClassVar[Qt.ToolBarArea] = ...
    ToolButtonFollowStyle: ClassVar[Qt.ToolButtonStyle] = ...
    ToolButtonIconOnly: ClassVar[Qt.ToolButtonStyle] = ...
    ToolButtonTextBesideIcon: ClassVar[Qt.ToolButtonStyle] = ...
    ToolButtonTextOnly: ClassVar[Qt.ToolButtonStyle] = ...
    ToolButtonTextUnderIcon: ClassVar[Qt.ToolButtonStyle] = ...
    ToolTip: ClassVar[Qt.WindowType] = ...
    ToolTipPropertyRole: ClassVar[Qt.ItemDataRole] = ...
    ToolTipRole: ClassVar[Qt.ItemDataRole] = ...
    TopDockWidgetArea: ClassVar[Qt.DockWidgetArea] = ...
    TopEdge: ClassVar[Qt.Edge] = ...
    TopLeftCorner: ClassVar[Qt.Corner] = ...
    TopLeftSection: ClassVar[Qt.WindowFrameSection] = ...
    TopRightCorner: ClassVar[Qt.Corner] = ...
    TopRightSection: ClassVar[Qt.WindowFrameSection] = ...
    TopSection: ClassVar[Qt.WindowFrameSection] = ...
    TopToolBarArea: ClassVar[Qt.ToolBarArea] = ...
    TouchPointMoved: ClassVar[Qt.TouchPointState] = ...
    TouchPointPressed: ClassVar[Qt.TouchPointState] = ...
    TouchPointReleased: ClassVar[Qt.TouchPointState] = ...
    TouchPointStationary: ClassVar[Qt.TouchPointState] = ...
    TransparentMode: ClassVar[Qt.BGMode] = ...
    Tuesday: ClassVar[Qt.DayOfWeek] = ...
    UI_AnimateCombo: ClassVar[Qt.UIEffect] = ...
    UI_AnimateMenu: ClassVar[Qt.UIEffect] = ...
    UI_AnimateToolBox: ClassVar[Qt.UIEffect] = ...
    UI_AnimateTooltip: ClassVar[Qt.UIEffect] = ...
    UI_FadeMenu: ClassVar[Qt.UIEffect] = ...
    UI_FadeTooltip: ClassVar[Qt.UIEffect] = ...
    UI_General: ClassVar[Qt.UIEffect] = ...
    UNICODE_ACCEL: ClassVar[Qt.Modifier] = ...
    UTC: ClassVar[Qt.TimeSpec] = ...
    Unchecked: ClassVar[Qt.CheckState] = ...
    UniqueConnection: ClassVar[Qt.ConnectionType] = ...
    UpArrow: ClassVar[Qt.ArrowType] = ...
    UpArrowCursor: ClassVar[Qt.CursorShape] = ...
    UserRole: ClassVar[Qt.ItemDataRole] = ...
    VerPattern: ClassVar[Qt.BrushStyle] = ...
    Vertical: ClassVar[Qt.Orientation] = ...
    VeryCoarseTimer: ClassVar[Qt.TimerType] = ...
    VisualMoveStyle: ClassVar[Qt.CursorMoveStyle] = ...
    WA_AcceptDrops: ClassVar[Qt.WidgetAttribute] = ...
    WA_AcceptTouchEvents: ClassVar[Qt.WidgetAttribute] = ...
    WA_AlwaysShowToolTips: ClassVar[Qt.WidgetAttribute] = ...
    WA_AlwaysStackOnTop: ClassVar[Qt.WidgetAttribute] = ...
    WA_AttributeCount: ClassVar[Qt.WidgetAttribute] = ...
    WA_CanHostQMdiSubWindowTitleBar: ClassVar[Qt.WidgetAttribute] = ...
    WA_ContentsMarginsRespectsSafeArea: ClassVar[Qt.WidgetAttribute] = ...
    WA_ContentsPropagated: ClassVar[Qt.WidgetAttribute] = ...
    WA_CustomWhatsThis: ClassVar[Qt.WidgetAttribute] = ...
    WA_DeleteOnClose: ClassVar[Qt.WidgetAttribute] = ...
    WA_Disabled: ClassVar[Qt.WidgetAttribute] = ...
    WA_DontCreateNativeAncestors: ClassVar[Qt.WidgetAttribute] = ...
    WA_DontShowOnScreen: ClassVar[Qt.WidgetAttribute] = ...
    WA_DropSiteRegistered: ClassVar[Qt.WidgetAttribute] = ...
    WA_ForceAcceptDrops: ClassVar[Qt.WidgetAttribute] = ...
    WA_ForceDisabled: ClassVar[Qt.WidgetAttribute] = ...
    WA_ForceUpdatesDisabled: ClassVar[Qt.WidgetAttribute] = ...
    WA_GrabbedShortcut: ClassVar[Qt.WidgetAttribute] = ...
    WA_GroupLeader: ClassVar[Qt.WidgetAttribute] = ...
    WA_Hover: ClassVar[Qt.WidgetAttribute] = ...
    WA_InputMethodEnabled: ClassVar[Qt.WidgetAttribute] = ...
    WA_InputMethodTransparent: ClassVar[Qt.WidgetAttribute] = ...
    WA_InvalidSize: ClassVar[Qt.WidgetAttribute] = ...
    WA_KeyCompression: ClassVar[Qt.WidgetAttribute] = ...
    WA_KeyboardFocusChange: ClassVar[Qt.WidgetAttribute] = ...
    WA_LaidOut: ClassVar[Qt.WidgetAttribute] = ...
    WA_LayoutOnEntireRect: ClassVar[Qt.WidgetAttribute] = ...
    WA_LayoutUsesWidgetRect: ClassVar[Qt.WidgetAttribute] = ...
    WA_MSWindowsUseDirect3D: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacAlwaysShowToolWindow: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacBrushedMetal: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacFrameworkScaled: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacMetalStyle: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacMiniSize: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacNoClickThrough: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacNoShadow: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacNormalSize: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacOpaqueSizeGrip: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacShowFocusRect: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacSmallSize: ClassVar[Qt.WidgetAttribute] = ...
    WA_MacVariableSize: ClassVar[Qt.WidgetAttribute] = ...
    WA_Mapped: ClassVar[Qt.WidgetAttribute] = ...
    WA_MouseNoMask: ClassVar[Qt.WidgetAttribute] = ...
    WA_MouseTracking: ClassVar[Qt.WidgetAttribute] = ...
    WA_Moved: ClassVar[Qt.WidgetAttribute] = ...
    WA_NativeWindow: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoBackground: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoChildEventsForParent: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoChildEventsFromChildren: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoMousePropagation: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoMouseReplay: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoSystemBackground: ClassVar[Qt.WidgetAttribute] = ...
    WA_NoX11EventCompression: ClassVar[Qt.WidgetAttribute] = ...
    WA_OpaquePaintEvent: ClassVar[Qt.WidgetAttribute] = ...
    WA_OutsideWSRange: ClassVar[Qt.WidgetAttribute] = ...
    WA_PaintOnScreen: ClassVar[Qt.WidgetAttribute] = ...
    WA_PaintUnclipped: ClassVar[Qt.WidgetAttribute] = ...
    WA_PendingMoveEvent: ClassVar[Qt.WidgetAttribute] = ...
    WA_PendingResizeEvent: ClassVar[Qt.WidgetAttribute] = ...
    WA_PendingUpdate: ClassVar[Qt.WidgetAttribute] = ...
    WA_QuitOnClose: ClassVar[Qt.WidgetAttribute] = ...
    WA_Resized: ClassVar[Qt.WidgetAttribute] = ...
    WA_RightToLeft: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetCursor: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetFont: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetLayoutDirection: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetLocale: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetPalette: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetStyle: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetWindowIcon: ClassVar[Qt.WidgetAttribute] = ...
    WA_SetWindowModality: ClassVar[Qt.WidgetAttribute] = ...
    WA_ShowModal: ClassVar[Qt.WidgetAttribute] = ...
    WA_ShowWithoutActivating: ClassVar[Qt.WidgetAttribute] = ...
    WA_StaticContents: ClassVar[Qt.WidgetAttribute] = ...
    WA_StyleSheet: ClassVar[Qt.WidgetAttribute] = ...
    WA_StyleSheetTarget: ClassVar[Qt.WidgetAttribute] = ...
    WA_StyledBackground: ClassVar[Qt.WidgetAttribute] = ...
    WA_TabletTracking: ClassVar[Qt.WidgetAttribute] = ...
    WA_TintedBackground: ClassVar[Qt.WidgetAttribute] = ...
    WA_TouchPadAcceptSingleTouchEvents: ClassVar[Qt.WidgetAttribute] = ...
    WA_TranslucentBackground: ClassVar[Qt.WidgetAttribute] = ...
    WA_TransparentForMouseEvents: ClassVar[Qt.WidgetAttribute] = ...
    WA_UnderMouse: ClassVar[Qt.WidgetAttribute] = ...
    WA_UpdatesDisabled: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_AcceptedTouchBeginEvent: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_CompressKeys: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_ConfigPending: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_Created: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_DND: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_ExplicitShowHide: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_Hidden: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_InPaintEvent: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_OwnSizePolicy: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_Polished: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_Reparented: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_Visible: ClassVar[Qt.WidgetAttribute] = ...
    WA_WState_WindowOpacitySet: ClassVar[Qt.WidgetAttribute] = ...
    WA_WindowModified: ClassVar[Qt.WidgetAttribute] = ...
    WA_WindowPropagation: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11BypassTransientForHint: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11DoNotAcceptFocus: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeCombo: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeDND: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeDesktop: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeDialog: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeDock: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeDropDownMenu: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeMenu: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeNotification: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypePopupMenu: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeSplash: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeToolBar: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeToolTip: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11NetWmWindowTypeUtility: ClassVar[Qt.WidgetAttribute] = ...
    WA_X11OpenGLOverlay: ClassVar[Qt.WidgetAttribute] = ...
    WaitCursor: ClassVar[Qt.CursorShape] = ...
    Wednesday: ClassVar[Qt.DayOfWeek] = ...
    WhatsThisCursor: ClassVar[Qt.CursorShape] = ...
    WhatsThisPropertyRole: ClassVar[Qt.ItemDataRole] = ...
    WhatsThisRole: ClassVar[Qt.ItemDataRole] = ...
    WheelFocus: ClassVar[Qt.FocusPolicy] = ...
    WhiteSpaceModeUndefined: ClassVar[Qt.WhiteSpaceMode] = ...
    WhiteSpaceNoWrap: ClassVar[Qt.WhiteSpaceMode] = ...
    WhiteSpaceNormal: ClassVar[Qt.WhiteSpaceMode] = ...
    WhiteSpacePre: ClassVar[Qt.WhiteSpaceMode] = ...
    Widget: ClassVar[Qt.WindowType] = ...
    WidgetShortcut: ClassVar[Qt.ShortcutContext] = ...
    WidgetWithChildrenShortcut: ClassVar[Qt.ShortcutContext] = ...
    WindingFill: ClassVar[Qt.FillRule] = ...
    Window: ClassVar[Qt.WindowType] = ...
    WindowActive: ClassVar[Qt.WindowState] = ...
    WindowCloseButtonHint: ClassVar[Qt.WindowType] = ...
    WindowContextHelpButtonHint: ClassVar[Qt.WindowType] = ...
    WindowDoesNotAcceptFocus: ClassVar[Qt.WindowType] = ...
    WindowFullScreen: ClassVar[Qt.WindowState] = ...
    WindowFullscreenButtonHint: ClassVar[Qt.WindowType] = ...
    WindowMaximizeButtonHint: ClassVar[Qt.WindowType] = ...
    WindowMaximized: ClassVar[Qt.WindowState] = ...
    WindowMinMaxButtonsHint: ClassVar[Qt.WindowType] = ...
    WindowMinimizeButtonHint: ClassVar[Qt.WindowType] = ...
    WindowMinimized: ClassVar[Qt.WindowState] = ...
    WindowModal: ClassVar[Qt.WindowModality] = ...
    WindowNoState: ClassVar[Qt.WindowState] = ...
    WindowOverridesSystemGestures: ClassVar[Qt.WindowType] = ...
    WindowShadeButtonHint: ClassVar[Qt.WindowType] = ...
    WindowShortcut: ClassVar[Qt.ShortcutContext] = ...
    WindowStaysOnBottomHint: ClassVar[Qt.WindowType] = ...
    WindowStaysOnTopHint: ClassVar[Qt.WindowType] = ...
    WindowSystemMenuHint: ClassVar[Qt.WindowType] = ...
    WindowTitleHint: ClassVar[Qt.WindowType] = ...
    WindowTransparentForInput: ClassVar[Qt.WindowType] = ...
    WindowType_Mask: ClassVar[Qt.WindowType] = ...
    X11BypassWindowManagerHint: ClassVar[Qt.WindowType] = ...
    XAxis: ClassVar[Qt.Axis] = ...
    XButton1: ClassVar[Qt.MouseButton] = ...
    XButton2: ClassVar[Qt.MouseButton] = ...
    YAxis: ClassVar[Qt.Axis] = ...
    ZAxis: ClassVar[Qt.Axis] = ...
    ZoomNativeGesture: ClassVar[Qt.NativeGestureType] = ...
    black: ClassVar[Qt.GlobalColor] = ...
    blue: ClassVar[Qt.GlobalColor] = ...
    color0: ClassVar[Qt.GlobalColor] = ...
    color1: ClassVar[Qt.GlobalColor] = ...
    cyan: ClassVar[Qt.GlobalColor] = ...
    darkBlue: ClassVar[Qt.GlobalColor] = ...
    darkCyan: ClassVar[Qt.GlobalColor] = ...
    darkGray: ClassVar[Qt.GlobalColor] = ...
    darkGreen: ClassVar[Qt.GlobalColor] = ...
    darkMagenta: ClassVar[Qt.GlobalColor] = ...
    darkRed: ClassVar[Qt.GlobalColor] = ...
    darkYellow: ClassVar[Qt.GlobalColor] = ...
    gray: ClassVar[Qt.GlobalColor] = ...
    green: ClassVar[Qt.GlobalColor] = ...
    lightGray: ClassVar[Qt.GlobalColor] = ...
    magenta: ClassVar[Qt.GlobalColor] = ...
    red: ClassVar[Qt.GlobalColor] = ...
    transparent: ClassVar[Qt.GlobalColor] = ...
    white: ClassVar[Qt.GlobalColor] = ...
    yellow: ClassVar[Qt.GlobalColor] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @classmethod
    def bin(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def bom(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def center(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def dec(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def endl(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def fixed(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def flush(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def forcepoint(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def forcesign(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def hex(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def left(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def lowercasebase(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def lowercasedigits(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def noforcepoint(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def noforcesign(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def noshowbase(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def oct(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def reset(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def right(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def scientific(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def showbase(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def uppercasebase(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def uppercasedigits(cls, s: QTextStream) -> QTextStream: ...
    @classmethod
    def ws(cls, s: QTextStream) -> QTextStream: ...

class QtMsgType:
    QtCriticalMsg: ClassVar[QtMsgType] = ...
    QtDebugMsg: ClassVar[QtMsgType] = ...
    QtFatalMsg: ClassVar[QtMsgType] = ...
    QtInfoMsg: ClassVar[QtMsgType] = ...
    QtSystemMsg: ClassVar[QtMsgType] = ...
    QtWarningMsg: ClassVar[QtMsgType] = ...
    values: ClassVar[dict] = ...
    name: Any
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __add__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __and__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> Any: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __pos__(self) -> Any: ...
    def __radd__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __rand__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __rmul__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __ror__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __rsub__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __rxor__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __sub__(self, other: typing.SupportsInt) -> QtMsgType: ...
    def __xor__(self, other: typing.SupportsInt) -> QtMsgType: ...

class Signal:
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __get__(self, instance, owner) -> SignalInstance: ...
    def __getitem__(self, index) -> SignalInstance: ...

class SignalInstance:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def connect(self, slot: object, type: typing.Union[type,None] = ...) -> None: ...
    def disconnect(self, slot: typing.Union[object,None] = ...) -> None: ...
    def emit(self, *args: typing.Any) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __getitem__(self, index) -> SignalInstance: ...

class Slot:
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...

def QEnum(arg__1: object) -> object: ...
def QFlag(arg__1: object) -> object: ...
def QT_TRANSLATE_NOOP(arg__1: object, arg__2: object) -> object: ...
def QT_TRANSLATE_NOOP3(arg__1: object, arg__2: object, arg__3: object) -> object: ...
def QT_TRANSLATE_NOOP_UTF8(arg__1: object) -> object: ...
def QT_TR_NOOP(arg__1: object) -> object: ...
def QT_TR_NOOP_UTF8(arg__1: object) -> object: ...
def SIGNAL(arg__1: bytes) -> str: ...
def SLOT(arg__1: bytes) -> str: ...
def __init_feature__() -> None: ...
def __moduleShutdown() -> None: ...
def qAbs(arg__1: float) -> float: ...
def qAcos(v: float) -> float: ...
def qAddPostRoutine(arg__1: object) -> None: ...
def qAsin(v: float) -> float: ...
def qAtan(v: float) -> float: ...
def qAtan2(y: float, x: float) -> float: ...
def qChecksum(s: bytes, len: int) -> int: ...
@overload
def qCompress(data: QByteArray, compressionLevel: int = ...) -> QByteArray: ...
@overload
def qCompress(data: bytes, nbytes: int, compressionLevel: int = ...) -> QByteArray: ...
def qCritical(arg__1: bytes) -> None: ...
def qDebug(arg__1: bytes) -> None: ...
def qExp(v: float) -> float: ...
def qFabs(v: float) -> float: ...
def qFastCos(x: float) -> float: ...
def qFastSin(x: float) -> float: ...
def qFatal(arg__1: bytes) -> None: ...
def qFuzzyCompare(p1: float, p2: float) -> bool: ...
def qFuzzyIsNull(d: float) -> bool: ...
def qInstallMessageHandler(arg__1: object) -> object: ...
def qIsFinite(d: float) -> bool: ...
def qIsInf(d: float) -> bool: ...
def qIsNaN(d: float) -> bool: ...
def qIsNull(d: float) -> bool: ...
def qRegisterResourceData(arg__1: int, arg__2: bytes, arg__3: bytes, arg__4: bytes) -> bool: ...
def qTan(v: float) -> float: ...
@overload
def qUncompress(data: QByteArray) -> QByteArray: ...
@overload
def qUncompress(data: bytes, nbytes: int) -> QByteArray: ...
def qUnregisterResourceData(arg__1: int, arg__2: bytes, arg__3: bytes, arg__4: bytes) -> bool: ...
def qVersion() -> bytes: ...
def qWarning(arg__1: bytes) -> None: ...
def qrand() -> int: ...
def qsrand(seed: int) -> None: ...
def qtTrId(id: bytes, n: int = ...) -> str: ...
